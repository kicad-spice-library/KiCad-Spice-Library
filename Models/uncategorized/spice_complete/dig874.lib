*-------------------------------------------------------------74ACT874----

* Dual 4 Bit D-Type Edge Triggered Flip Flops with Tri-State Outputs
* TI Advanced CMOS Logic Data Book, 1993, pages 2-611 to 2-614
* jat 12/21/95

.SUBCKT 74ACT874
+ OEBAR CLK CLRBAR D1 D2 D3 D4 Q1 Q2 Q3 Q4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ D1 D2 D3 D4 Q1O Q2O Q3O Q4O $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,2) DPWR DGND
+ Q1O Q2O Q3O Q4O
+ OEBAR
+ CLK CLRBAR
+ Q1 Q2 Q3 Q4
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OEBAR
+   Q1 Q2 Q3 Q4 = {
+     CASE(
+       TRN_ZH, DELAY(-1,6.4NS,-1),
+       TRN_ZL, DELAY(-1,8.6NS,-1),
+       TRN_HZ, DELAY(-1,6.9NS,-1),
+       TRN_LZ, DELAY(-1,6.8NS,-1),
+       CLEAR & TRN_HL, DELAY(-1,8.8NS,-1),
+       CLOCK & TRN_LH, DELAY(-1,7.5NS,-1),
+       CLOCK & TRN_HL, DELAY(-1,8.1NS,-1),
+       DELAY(-1,9.8NS,-1))}

U3 CONSTRAINT(6) DPWR DGND
+ CLRBAR CLK D1 D2 D3 D4
+ IO_ACT IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 125MEG
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 2NS
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 2NS
+  MIN_LO = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 1NS
+  HOLDTIME = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_LO = 2NS

.ENDS 74ACT874

* ----------------------------------------------------------- 74ALS874B ------
*  Dual 4-Bit D-Type Edge-Triggered Flip-Flops
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-743 to 2-748
*  bss    6/21/94
*
.SUBCKT 74ALS874B 1OCBAR 1CLK 1CLRBAR 1D1 1D2 1D3 1D4 1Q1 1Q2 1Q3 1Q4 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dff(4) DPWR DGND
+     $D_HI 1CLRBAR 1CLK
+     1D1 1D2 1D3 1D4
+     Q1_O Q2_O Q3_O Q4_O
+     $D_NC $D_NC $D_NC $D_NC
+     D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(4,1,2) DPWR DGND
+     Q1_O Q2_O Q3_O Q4_O
+     1OCBAR
+     1CLRBAR 1CLK
+     1Q1 1Q2 1Q3 1Q4
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     CLEAR = {CHANGED_HL(1CLRBAR,0)}
+     CLOCK = {CHANGED_LH(1CLK,0)}
+
+  TRISTATE:
+     ENABLE LO=1OCBAR
+     1Q1 1Q2 1Q3 1Q4 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(5ns,-1,17ns),
+         CLOCK & TRN_LH, DELAY(4ns,-1,14ns),
+         CLOCK & TRN_HL, DELAY(4ns,-1,14ns),
+         TRN_Z$, DELAY(4ns,-1,18ns),
+         TRN_HZ, DELAY(2ns,-1,10ns),
+         TRN_LZ, DELAY(3ns,-1,12ns),
+         DELAY(6ns,-1,19ns))}

U3CON CONSTRAINT(6) DPWR DGND
+     1CLRBAR 1CLK 1D1 1D2 1D3 1D4
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=1CLRBAR
+     MIN_LO=10ns
+
+  FREQ:
+     NODE=1CLK
+     MAXFREQ=30MEG
+
+  WIDTH:
+     NODE=1CLK
+     MIN_HI=16.5ns
+     MIN_LO=16.5ns
+
+  SETUP_HOLD:
+     CLOCK LH=1CLK
+     DATA(4)=1D1 1D2 1D3 1D4
+     SETUPTIME=15ns
+
+  SETUP_HOLD:
+     CLOCK LH=1CLK
+     DATA(1)=1CLRBAR
+     SETUPTIME_HI=10ns

.ENDS 74ALS874B
*
*
* ----------------------------------------------------------- 74AS874 ------
*  Dual 4-Bit D-Type Edge-Triggered Flip-Flops
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-743 to 2-748
*  bss    6/21/94
*
.SUBCKT 74AS874 1OCBAR 1CLK 1CLRBAR 1D1 1D2 1D3 1D4 1Q1 1Q2 1Q3 1Q4 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dff(4) DPWR DGND
+     $D_HI 1CLRBAR 1CLK
+     1D1 1D2 1D3 1D4
+     Q1_O Q2_O Q3_O Q4_O
+     $D_NC $D_NC $D_NC $D_NC
+     D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(4,1,2) DPWR DGND
+     Q1_O Q2_O Q3_O Q4_O
+     1OCBAR
+     1CLRBAR 1CLK
+     1Q1 1Q2 1Q3 1Q4
+     IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     CLEAR = {CHANGED_HL(1CLRBAR,0)}
+     CLOCK = {CHANGED_LH(1CLK,0)}
+
+  TRISTATE:
+     ENABLE LO=1OCBAR
+     1Q1 1Q2 1Q3 1Q4 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(4ns,-1,9.5ns),
+         CLOCK & TRN_LH, DELAY(3ns,-1,8.5ns),
+         CLOCK & TRN_HL, DELAY(4ns,-1,10.5ns),
+         TRN_ZH, DELAY(2ns,-1,7ns),
+         TRN_ZL, DELAY(3ns,-1,10.5ns),
+         TRN_HZ, DELAY(2ns,-1,6ns),
+         TRN_LZ, DELAY(2ns,-1,7.5ns),
+         DELAY(5ns,-1,11.5ns))}

U3CON CONSTRAINT(6) DPWR DGND
+     1CLRBAR 1CLK 1D1 1D2 1D3 1D4
+     IO_AS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=1CLRBAR
+     MIN_LO=2ns
+
+  FREQ:
+     NODE=1CLK
+     MAXFREQ=125MEG
+
+  WIDTH:
+     NODE=1CLK
+     MIN_HI=3ns
+     MIN_LO=4ns
+
+  SETUP_HOLD:
+     CLOCK LH=1CLK
+     DATA(4)=1D1 1D2 1D3 1D4
+     SETUPTIME=2ns
+     HOLDTIME=1ns
+
+  SETUP_HOLD:
+     CLOCK LH=1CLK
+     DATA(1)=1CLRBAR
+     SETUPTIME_HI=4ns

.ENDS 74AS874
*
*
*-------------------------------------------------------------74ALS876A----

* Dual 4 Bit D-Type Edge Triggered Flip Flops
* TI ALS/AS Logic Data Book, 1986, pages 2-743 to 2-748
* jat 3/26/96

.SUBCKT 74ALS876A
+ OCBAR CLK PREBAR D1 D2 D3 D4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(4) DPWR DGND
+ PREBAR $D_HI CLK
+ D1 D2 D3 D4 $D_NC $D_NC $D_NC $D_NC Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,2) DPWR DGND
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ OCBAR
+ CLK PREBAR
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(PREBAR,0)}
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1BAR Q2BAR Q3BAR Q4BAR = {
+     CASE(
+       TRN_ZH, DELAY(-1,10NS,13NS),
+       TRN_ZL, DELAY(-1,11NS,15NS),
+       TRN_HZ, DELAY(-1,6NS,8NS),
+       TRN_LZ, DELAY(-1,7NS,10NS),
+       SET & TRN_HL, DELAY(-1,10NS,16NS),
+       CLOCK & TRN_LH, DELAY(-1,8NS,11NS),
+       CLOCK & TRN_HL, DELAY(-1,9NS,12NS),
+       DELAY(-1,12NS,17NS))}

U3 CONSTRAINT(6) DPWR DGND
+ PREBAR CLK D1 D2 D3 D4
+ IO_ALS00 IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 30MEG
+ WIDTH:
+  NODE = PREBAR
+  MIN_LO = 10NS
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 16.5NS
+  MIN_LO = 16.5NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = PREBAR
+  SETUPTIME_HI = 10NS

.ENDS 74ALS876A

*-------------------------------------------------------------74AS876----

* Dual 4 Bit D-Type Edge Triggered Flip Flops
* TI ALS/AS Logic Data Book, 1986, pages 2-743 to 2-748
* jat 3/26/96

.SUBCKT 74AS876
+ OCBAR CLK PREBAR D1 D2 D3 D4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(4) DPWR DGND
+ PREBAR $D_HI CLK
+ D1 D2 D3 D4 $D_NC $D_NC $D_NC $D_NC Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,2) DPWR DGND
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ OCBAR
+ CLK PREBAR
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL = {IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(PREBAR,0)}
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1BAR Q2BAR Q3BAR Q4BAR = {
+     CASE(
+       TRN_ZH, DELAY(2NS,-1,8NS),
+       TRN_ZL, DELAY(3NS,-1,11.5NS),
+       TRN_HZ, DELAY(2NS,-1,7NS),
+       TRN_LZ, DELAY(2NS,-1,7NS),
+       SET & TRN_HL, DELAY(4NS,-1,11NS),
+       CLOCK & TRN_LH, DELAY(3NS,-1,11.5NS),
+       CLOCK & TRN_HL, DELAY(4NS,-1,12.5NS),
+       DELAY(5NS,-1,13.5NS))}

U3 CONSTRAINT(6) DPWR DGND
+ PREBAR CLK D1 D2 D3 D4
+ IO_AS00 IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 125MEG
+ WIDTH:
+  NODE = PREBAR
+  MIN_LO = 2NS
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 3NS
+  MIN_LO = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 2NS
+  HOLDTIME = 1NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = PREBAR
+  SETUPTIME_HI = 4NS

.ENDS 74AS876

*------------------------------------------------------------74AS877-----

* 8 Bit Universal Transceiver Port Controllers
* TI ALS/AS Logic Data Book, 1986, pages 2-749 to 2-754
* jat 3/26/96

.SUBCKT 74AS877
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 S0 S1 S2 CLK SERIN Q8
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(28,26) DPWR DGND
+ S0 S1 S2 A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 SERIN 
+ Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8O
+ D1 D2 D3 D4 D5 D6 D7 D8 A1O A2O A3O A4O A5O A6O A7O A8O B1O B2O B3O B4O B5O
+ B6O B7O B8O ENABBA ENABAB
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   S0BAR = {~S0}
+   S1BAR = {~S1}
+   S2BAR = {~S2}
+   ENABBA = {~(S0BAR | (S1 & S2))}
+   ENABAB = {~(S0 | (S2 & S1))}
+   D1 = {(~A1 & S2BAR & S0BAR) | (~B1 & S2BAR & S0) |
+         (~SERIN & S2) | (S0 & S1 & S2)}
+   D2 = {(~A2 & S2BAR & S0BAR) | (~B2 & S2BAR & S0) |
+         (Q1 & S2) | (S0 & S1 & S2)}
+   D3 = {(~A3 & S2BAR & S0BAR) | (~B3 & S2BAR & S0) |
+         (Q2 & S2) | (S0 & S1 & S2)}
+   D4 = {(~A4 & S2BAR & S0BAR) | (~B4 & S2BAR & S0) |
+         (Q3 & S2) | (S0 & S1 & S2)}
+   D5 = {(~A5 & S2BAR & S0BAR) | (~B5 & S2BAR & S0) |
+         (Q4 & S2) | (S0 & S1 & S2)}
+   D6 = {(~A6 & S2BAR & S0BAR) | (~B6 & S2BAR & S0) |
+         (Q5 & S2) | (S0 & S1 & S2)}
+   D7 = {(~A7 & S2BAR & S0BAR) | (~B7 & S2BAR & S0) |
+         (Q6 & S2) | (S0 & S1 & S2)}
+   D8 = {(~A8 & S2BAR & S0BAR) | (~B8 & S2BAR & S0) |
+         (Q7 & S2) | (S0 & S1 & S2)}
+   A1O = {~((~B1 & S2BAR & S1BAR) | (S1 & Q1) | (S2 & Q1))}
+   A2O = {~((~B2 & S2BAR & S1BAR) | (S1 & Q2) | (S2 & Q2))}
+   A3O = {~((~B3 & S2BAR & S1BAR) | (S1 & Q3) | (S2 & Q3))}
+   A4O = {~((~B4 & S2BAR & S1BAR) | (S1 & Q4) | (S2 & Q4))}
+   A5O = {~((~B5 & S2BAR & S1BAR) | (S1 & Q5) | (S2 & Q5))}
+   A6O = {~((~B6 & S2BAR & S1BAR) | (S1 & Q6) | (S2 & Q6))}
+   A7O = {~((~B7 & S2BAR & S1BAR) | (S1 & Q7) | (S2 & Q7))}
+   A8O = {~((~B8 & S2BAR & S1BAR) | (S1 & Q8O) | (S2 & Q8O))}
+   B1O = {~((~A1 & S2BAR & S1BAR) | (S1 & Q1) | (S2 & Q1))}
+   B2O = {~((~A2 & S2BAR & S1BAR) | (S1 & Q2) | (S2 & Q2))}
+   B3O = {~((~A3 & S2BAR & S1BAR) | (S1 & Q3) | (S2 & Q3))}
+   B4O = {~((~A4 & S2BAR & S1BAR) | (S1 & Q4) | (S2 & Q4))}
+   B5O = {~((~A5 & S2BAR & S1BAR) | (S1 & Q5) | (S2 & Q5))}
+   B6O = {~((~A6 & S2BAR & S1BAR) | (S1 & Q6) | (S2 & Q6))}
+   B7O = {~((~A7 & S2BAR & S1BAR) | (S1 & Q7) | (S2 & Q7))}
+   B8O = {~((~A8 & S2BAR & S1BAR) | (S1 & Q8O) | (S2 & Q8O))}

U2 DFF(8) DPWR DGND
+ $D_HI $D_HI CLK
+ D1 D2 D3 D4 D5 D6 D7 D8
+ Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC Q8BAR
+ D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(17,2,20) DPWR DGND
+ A1O A2O A3O A4O A5O A6O A7O A8O B1O B2O B3O B4O B5O B6O B7O B8O Q8BAR
+ ENABAB ENABBA
+ S0 S1 S2 CLK A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 Q8
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    SELECT = {CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0)}
+    EDGE = {CHANGED_LH(CLK,0)}
+    BDATA = {CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) |
+             CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0)}
+    ADATA = {CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+             CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0)}
+ TRISTATE:
+   ENABLE HI = ENABBA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+     CASE(
+       TRN_HZ, DELAY(2NS,-1,6.5NS),
+       TRN_LZ, DELAY(3NS,-1,10.5NS),
+       TRN_ZH, DELAY(2NS,-1,7NS),
+       TRN_ZL, DELAY(3NS,-1,9.5NS),
+       SELECT & TRN_LH, DELAY(3NS,-1,10NS),
+       SELECT & TRN_HL, DELAY(2NS,-1,8NS),
+       EDGE & TRN_LH, DELAY(2NS,-1,9NS),
+       EDGE & TRN_HL, DELAY(3NS,-1,11.5NS),
+       BDATA & TRN_LH, DELAY(2NS,-1,7.5NS),
+       BDATA & TRN_HL, DELAY(3NS,-1,9NS),
+       DELAY(4NS,-1,12.5NS))}
+ TRISTATE:
+   ENABLE HI = ENABAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+     CASE(
+       TRN_HZ, DELAY(2NS,-1,6.5NS),
+       TRN_LZ, DELAY(3NS,-1,10.5NS),
+       TRN_ZH, DELAY(2NS,-1,7NS),
+       TRN_ZL, DELAY(3NS,-1,9.5NS),
+       SELECT & TRN_LH, DELAY(3NS,-1,10NS),
+       SELECT & TRN_HL, DELAY(2NS,-1,8NS),
+       EDGE & TRN_LH, DELAY(2NS,-1,9NS),
+       EDGE & TRN_HL, DELAY(3NS,-1,11.5NS),
+       ADATA & TRN_LH, DELAY(2NS,-1,7NS),
+       ADATA & TRN_HL, DELAY(3NS,-1,9NS),
+       DELAY(4NS,-1,12.5NS))}
+ PINDLY:
+    Q8 = {
+      CASE(
+        EDGE & TRN_LH, DELAY(2NS,-1,8NS),
+        EDGE & TRN_HL, DELAY(3NS,-1,8.5NS),
+        DELAY(4NS,-1,9.5NS))}

U4 CONSTRAINT(21) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 CLK SERIN S0 S1 S2
+ IO_AS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 50MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 10NS
+   MIN_HI = 10NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(20) = A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 SERIN S0 S1 S2
+   SETUPTIME = 5.5NS

.ENDS 74AS877
  
*-------------------------------------------------------------74ALS878A----

* Dual 4 Bit D-Type Edge Triggered Flip Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-755 to 2-760
* jat 3/26/96

.SUBCKT 74ALS878A
+ OCBAR CLK CLRBAR D1 D2 D3 D4 Q1 Q2 Q3 Q4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U0 LOGICEXP(5,4) DPWR DGND
+ D1 D2 D3 D4 CLRBAR
+ D1IN D2IN D3IN D4IN
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    D1IN = {CLRBAR & D1}
+    D2IN = {CLRBAR & D2}
+    D3IN = {CLRBAR & D3}
+    D4IN = {CLRBAR & D4}

U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ D1IN D2IN D3IN D4IN Q1O Q2O Q3O Q4O $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,1) DPWR DGND
+ Q1O Q2O Q3O Q4O
+ OCBAR
+ CLK
+ Q1 Q2 Q3 Q4
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1 Q2 Q3 Q4 = {
+     CASE(
+       TRN_ZH, DELAY(-1,9NS,13NS),
+       TRN_ZL, DELAY(-1,11NS,15NS),
+       TRN_HZ, DELAY(-1,6NS,8NS),
+       TRN_LZ, DELAY(-1,7NS,10NS),
+       CLOCK & TRN_LH, DELAY(-1,8NS,10NS),
+       CLOCK & TRN_HL, DELAY(-1,9NS,13NS),
+       DELAY(-1,12NS,16NS))}

U3 CONSTRAINT(6) DPWR DGND
+ CLRBAR CLK D1 D2 D3 D4
+ IO_ALS00 IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 16.5NS
+  MIN_LO = 16.5NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 15NS
+  HOLDTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_LO = 20NS

.ENDS 74ALS878A

*-------------------------------------------------------------74AS878----

* Dual 4 Bit D-Type Edge Triggered Flip Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-755 to 2-760
* jat 3/26/96

.SUBCKT 74AS878
+ OCBAR CLK CLRBAR D1 D2 D3 D4 Q1 Q2 Q3 Q4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U0 LOGICEXP(5,4) DPWR DGND
+ D1 D2 D3 D4 CLRBAR
+ D1IN D2IN D3IN D4IN
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    D1IN = {CLRBAR & D1}
+    D2IN = {CLRBAR & D2}
+    D3IN = {CLRBAR & D3}
+    D4IN = {CLRBAR & D4}

U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ D1IN D2IN D3IN D4IN Q1O Q2O Q3O Q4O $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,1) DPWR DGND
+ Q1O Q2O Q3O Q4O
+ OCBAR
+ CLK
+ Q1 Q2 Q3 Q4
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1 Q2 Q3 Q4 = {
+     CASE(
+       TRN_ZH, DELAY(2NS,-1,7NS),
+       TRN_ZL, DELAY(3NS,-1,10.5NS),
+       TRN_HZ, DELAY(2NS,-1,6NS),
+       TRN_LZ, DELAY(2NS,-1,6NS),
+       CLOCK & TRN_LH, DELAY(3NS,-1,8.5NS),
+       CLOCK & TRN_HL, DELAY(4NS,-1,10.5NS),
+       DELAY(5NS,-1,11.5NS))}

U3 CONSTRAINT(6) DPWR DGND
+ CLRBAR CLK D1 D2 D3 D4
+ IO_AS00 IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 125MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 4NS
+  MIN_LO = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 2NS
+  HOLDTIME = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_LO = 5.5NS

.ENDS 74AS878

*-------------------------------------------------------------74ALS879A----

* Dual 4 Bit D-Type Edge Triggered Flip Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-755 to 2-760
* jat 3/26/96

.SUBCKT 74ALS879A
+ OCBAR CLK CLRBAR D1 D2 D3 D4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U0 LOGICEXP(5,4) DPWR DGND
+ D1 D2 D3 D4 CLRBAR
+ D1IN D2IN D3IN D4IN
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    D1IN = {CLRBAR & D1}
+    D2IN = {CLRBAR & D2}
+    D3IN = {CLRBAR & D3}
+    D4IN = {CLRBAR & D4}

U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ D1IN D2IN D3IN D4IN $D_NC $D_NC $D_NC $D_NC Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,1) DPWR DGND
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ OCBAR
+ CLK
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1BAR Q2BAR Q3BAR Q4BAR = {
+     CASE(
+       TRN_ZH, DELAY(-1,9NS,13NS),
+       TRN_ZL, DELAY(-1,11NS,15NS),
+       TRN_HZ, DELAY(-1,6NS,8NS),
+       TRN_LZ, DELAY(-1,7NS,10NS),
+       CLOCK & TRN_LH, DELAY(-1,8NS,10NS),
+       CLOCK & TRN_HL, DELAY(-1,9NS,13NS),
+       DELAY(-1,12NS,16NS))}

U3 CONSTRAINT(6) DPWR DGND
+ CLRBAR CLK D1 D2 D3 D4
+ IO_ALS00 IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 16.5NS
+  MIN_LO = 16.5NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 15NS
+  HOLDTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_LO = 20NS

.ENDS 74ALS879A

*-------------------------------------------------------------74AS879----

* Dual 4 Bit D-Type Edge Triggered Flip Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-755 to 2-760
* jat 3/26/96

.SUBCKT 74AS879
+ OCBAR CLK CLRBAR D1 D2 D3 D4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U0 LOGICEXP(5,4) DPWR DGND
+ D1 D2 D3 D4 CLRBAR
+ D1IN D2IN D3IN D4IN
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+    D1IN = {CLRBAR & D1}
+    D2IN = {CLRBAR & D2}
+    D3IN = {CLRBAR & D3}
+    D4IN = {CLRBAR & D4}

U1 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ D1IN D2IN D3IN D4IN $D_NC $D_NC $D_NC $D_NC Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,1) DPWR DGND
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ OCBAR
+ CLK
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLOCK = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1BAR Q2BAR Q3BAR Q4BAR = {
+     CASE(
+       TRN_ZH, DELAY(2NS,-1,7NS),
+       TRN_ZL, DELAY(3NS,-1,10.5NS),
+       TRN_HZ, DELAY(2NS,-1,6NS),
+       TRN_LZ, DELAY(2NS,-1,6NS),
+       CLOCK & TRN_LH, DELAY(3NS,-1,8.5NS),
+       CLOCK & TRN_HL, DELAY(4NS,-1,10.5NS),
+       DELAY(5NS,-1,11.5NS))}

U3 CONSTRAINT(6) DPWR DGND
+ CLRBAR CLK D1 D2 D3 D4
+ IO_AS00 IO_LEVEL = {IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 125MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 4NS
+  MIN_LO = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 2NS
+  HOLDTIME = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_LO = 5.5NS

.ENDS 74AS879

*-------------------------------------------------------------74ALS880A----

* Dual 4 Bit D-Type Latches with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-761 to 2-767
* jat 3/26/96

.SUBCKT 74ALS880A
+ OCBAR C PREBAR D1 D2 D3 D4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DLTCH(4) DPWR DGND
+ PREBAR $D_HI C
+ D1 D2 D3 D4 $D_NC $D_NC $D_NC $D_NC Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,6) DPWR DGND
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ OCBAR
+ C D1 D2 D3 D4 PREBAR
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED(C,0)}
+   DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D4,0)}
+   SET = {CHANGED_HL(PREBAR,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1BAR Q2BAR Q3BAR Q4BAR = {
+     CASE(
+       TRN_ZH, DELAY(-1,12NS,15NS),
+       TRN_ZL, DELAY(-1,13NS,17NS),
+       TRN_HZ, DELAY(-1,6NS,9NS),
+       TRN_LZ, DELAY(-1,8NS,11NS),
+       SET & TRN_HL, DELAY(-1,12NS,16NS),
+       LATCH & TRN_LH, DELAY(-1,17NS,22NS),
+       LATCH & TRN_HL, DELAY(-1,14NS,18NS),
+       DATA & TRN_LH, DELAY(-1,14NS,19NS),
+       DATA & TRN_HL, DELAY(-1,9NS,12NS),
+       DELAY(-1,18NS,23NS))}

U3 CONSTRAINT(6) DPWR DGND
+ PREBAR C D1 D2 D3 D4
+ IO_ALS00 IO_LEVEL = {IO_LEVEL}
+ WIDTH:
+  NODE = C
+  MIN_HI = 15NS
+ WIDTH:
+  NODE = PREBAR
+  MIN_LO = 15NS
+ SETUP_HOLD:
+  CLOCK HL = C
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 10NS
+  HOLDTIME = 10NS

.ENDS 74ALS880A

*-------------------------------------------------------------74AS880----

* Dual 4 Bit D-Type Latches with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-761 to 2-767
* jat 3/26/96

.SUBCKT 74AS880
+ OCBAR C PREBAR D1 D2 D3 D4 Q1BAR Q2BAR Q3BAR Q4BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DLTCH(4) DPWR DGND
+ PREBAR $D_HI C
+ D1 D2 D3 D4 $D_NC $D_NC $D_NC $D_NC Q1BARO Q2BARO Q3BARO Q4BARO
+ D0_GFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,6) DPWR DGND
+ Q1BARO Q2BARO Q3BARO Q4BARO
+ OCBAR
+ C D1 D2 D3 D4 PREBAR
+ Q1BAR Q2BAR Q3BAR Q4BAR
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED(C,0)}
+   DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D4,0)}
+   SET = {CHANGED_HL(PREBAR,0)}
+ TRISTATE:
+   ENABLE LO = OCBAR
+   Q1BAR Q2BAR Q3BAR Q4BAR = {
+     CASE(
+       TRN_ZH, DELAY(2NS,-1,7.5NS),
+       TRN_ZL, DELAY(4NS,-1,10NS),
+       TRN_HZ, DELAY(2NS,-1,6.5NS),
+       TRN_LZ, DELAY(2NS,-1,8NS),
+       SET & TRN_HL, DELAY(4NS,-1,10NS),
+       LATCH & TRN_LH, DELAY(6NS,-1,11.5NS),
+       LATCH & TRN_HL, DELAY(4NS,-1,8NS),
+       DATA & TRN_LH, DELAY(4NS,-1,9.5NS),
+       DATA & TRN_HL, DELAY(4NS,-1,8.5NS),
+       DELAY(7NS,-1,12.5NS))}

U3 CONSTRAINT(6) DPWR DGND
+ PREBAR C D1 D2 D3 D4
+ IO_AS00 IO_LEVEL = {IO_LEVEL}
+ WIDTH:
+  NODE = C
+  MIN_HI = 2.5NS
+ WIDTH:
+  NODE = PREBAR
+  MIN_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK HL = C
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 2NS
+  HOLDTIME = 1NS

.ENDS 74AS880

* ----------------------------------------------------------- 74AS881A ------
*  Arithmetic Logic Units/Function Generators
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-187 to 2-196
*  bss    6/21/94
*
.SUBCKT 74AS881A S0 S1 S2 S3 M CN A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR 
+     B3BAR GBAR CN4 PBAR AEQUALB F0BAR F1BAR F2BAR F3BAR
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1LOG LOGICEXP(14,8) DPWR DGND
+     S0 S1 S2 S3 M CN A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR
+     GBAR_O CN4_O PBAR_O AEQUALB_O F0BAR_O F1BAR_O F2BAR_O F3BAR_O
+     D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  LOGIC:
+     b0 = {~B0BAR}
+     b1 = {~B1BAR}
+     b2 = {~B2BAR}
+     b3 = {~B3BAR}
+     mbar = {~M}
+     in0a = {~((b0 & S1) | (S0 & B0BAR) | A0BAR)}
+     in0b = {~((B0BAR & S3 & A0BAR) | (A0BAR & S2 & b0))}
+     in1a = {~((b1 & S1) | (S0 & B1BAR) | A1BAR)}
+     in1b = {~((B1BAR & S3 & A1BAR) | (A1BAR & S2 & b1))}
+     in2a = {~((b2 & S1) | (S0 & B2BAR) | A2BAR)}
+     in2b = {~((B2BAR & S3 & A2BAR) | (A2BAR & S2 & b2))}
+     in3a = {~((b3 & S1) | (S0 & B3BAR) | A3BAR)}
+     in3b = {~((B3BAR & S3 & A3BAR) | (A3BAR & S2 & b3))}
+     xor0 = {in0a ^ in0b}
+     xor1 = {in1a ^ in1b}
+     xor2 = {in2a ^ in2b}
+     xor3 = {in3a ^ in3b}
+     GBAR_O = {~((mbar & in3a) | (mbar & in3b & in2a) | (mbar & in3b & in2b & in1a) |
+         (mbar & in3b & in2b & in1b & in0a))}
+     f0in = {~(mbar & CN)}
+     F0BAR_O = {f0in ^ xor0}
+     f1in = {~((CN & mbar & in0b) | (in0a & mbar))}
+     F1BAR_O = {f1in ^ xor1}
+     f2in = {~((CN & in0b & in1b & mbar) | (in1b & mbar & in0a) | (in1a & mbar))}
+     F2BAR_O = {f2in ^ xor2}
+     f3in = {~((CN & in0b & in1b & in2b & mbar) | (in1b & in2b & in0a & mbar) |
+         (in2b & in1a & mbar) | (in2a & mbar))}
+     F3BAR_O = {f3in ^ xor3}
+     AEQUALB_O = {F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O}
+     cn4in = {~((M & F0BAR_O & F1BAR_O & F2BAR_O & F3BAR_O & CN) |
+         (mbar & in3b & in2b & in1b & in0b & CN))}
+     CN4_O = {~(cn4in & GBAR_O)}
+     PBAR_O = {~((M & F0BAR_O & F1BAR_O & F2BAR_O & F3BAR_O) |
+         (mbar & in3b & in2b & in1b & in0b))}

U2DLY PINDLY(7,0,14) DPWR DGND
+     GBAR_O CN4_O PBAR_O F0BAR_O F1BAR_O F2BAR_O F3BAR_O
+     A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR M CN S0 S1 S2 S3
+     GBAR CN4 PBAR F0BAR F1BAR F2BAR F3BAR
+     IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     DATA0 = {CHANGED(A0BAR,0) | CHANGED(B0BAR,0)}
+     DATA1 = {CHANGED(A1BAR,0) | CHANGED(B1BAR,0)}
+     DATA2 = {CHANGED(A2BAR,0) | CHANGED(B2BAR,0)}
+     DATA3 = {CHANGED(A3BAR,0) | CHANGED(B3BAR,0)}
+     DATA = {DATA0 | DATA1 | DATA2 | DATA3}
+     CARRY = {CHANGED(CN,0)}
+     SUM = {S0=='1 & S1=='0 & S2=='0 & S3=='1}
+     DIFF = {S0=='0 & S1=='1 & S2=='1 & S3=='0}
+     MHI = {M=='1}
+     MLO = {M=='0}
+     CNHI = {CN=='1}
+     S2HI = {S0=='0 & S1=='0 & S2=='1 & S3=='0}
+
+  PINDLY:
+     F0BAR F1BAR F2BAR F3BAR = {
+       CASE(
+         CARRY & MLO, DELAY(3ns,6ns,9ns),
+         DATA & MLO & SUM, DELAY(2ns,5ns,8ns),
+         DATA & MLO & DIFF, DELAY(2ns,6ns,10ns),
+         MHI, DELAY(2ns,6ns,11ns),
+         DELAY(2ns,6ns,10ns))}
+
+     GBAR = {
+       CASE(
+         DATA & MLO & SUM, DELAY(2ns,5ns,7ns),
+         DATA & MLO & DIFF, DELAY(2ns,6ns,9ns),
+         DELAY(2ns,6ns,9ns))}
+
+     CN4 = {
+       CASE(
+         DATA & CNHI & MHI & SUM, DELAY(2ns,12ns,18ns),
+         DATA & CNHI & MHI & S2HI, DELAY(2ns,13ns,19ns),
+         DATA & MLO & SUM, DELAY(2ns,8ns,12ns),
+         DATA & MLO & DIFF, DELAY(2ns,8ns,16ns),
+         CARRY, DELAY(2ns,7ns,9ns),
+         DELAY(2ns,8ns,16ns))}
+
+     PBAR = {
+       CASE(
+         DATA & CNHI & MHI & SUM, DELAY(2ns,10ns,15ns),
+         DATA & CNHI & MHI & S2HI, DELAY(2ns,10ns,15ns),
+         DATA & MLO & SUM, DELAY(2ns,6ns,8ns),
+         DATA & MLO & DIFF, DELAY(2ns,6ns,10ns),
+         DELAY(2ns,6ns,11ns))}

U3DLY PINDLY(1,0,0) DPWR DGND
+     AEQUALB_O
+     AEQUALB
+     IO_AS00_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  PINDLY:
+     AEQUALB = {
+       CASE(
+         DELAY(4ns,14ns,21ns))}

.ENDS 74AS881A

* -----------------------------------------------------------74AS881B------

* 4-Bit Arithmetic Logic Unit/Function Generator
* National ALS/AS Logic Databook, 1990, pages 3-195 to 3-206
* jat 8/21/96

.SUBCKT 74AS881B
+ S0 S1 S2 S3 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR M CN
+ GBAR CN4 PBAR AEQUALB F0BAR F1BAR F2BAR F3BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,8) DPWR DGND
+ S0 S1 S2 S3 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR M CN
+ GBARO CN4O PBARO F3BARO F2BARO F1BARO F0BARO AEQUALBO
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   NORB3 = {~((B3BAR & S3 & A3BAR) | (A3BAR & S2 & ~B3BAR))}
+   NORA3 = {~((~B3BAR & S1) | (S0 & B3BAR) | A3BAR)}
+   NORB2 = {~((B2BAR & S3 & A2BAR) | (A2BAR & S2 & ~B2BAR))}
+   NORA2 = {~((~B2BAR & S1) | (S0 & B2BAR) | A2BAR)}
+   NORB1 = {~((B1BAR & S3 & A1BAR) | (A1BAR & S2 & ~B1BAR))}
+   NORA1 = {~((~B1BAR & S1) | (S0 & B1BAR) | A1BAR)}
+   NORB0 = {~((B0BAR & S3 & A0BAR) | (A0BAR & S2 & ~B0BAR))}
+   NORA0 = {~((~B0BAR & S1) | (S0 & B0BAR) | A0BAR)}
+   XOR3 = {NORB3 ^ NORA3}
+   XOR2 = {NORB2 ^ NORA2}
+   XOR1 = {NORB1 ^ NORA1}
+   XOR0 = {NORB0 ^ NORA0}
+   NORF3 = {~((CN & NORB2 & NORB1 & NORB0 & ~M) | (NORB2 & NORB1 & NORA0 & ~M) |
+              (NORB2 & NORA1 & ~M) | (NORA2 & ~M))}
+   NORF2 = {~((CN & NORB0 & NORB1 & ~M) | (NORB1 & NORA0 & ~M) | (NORA1 & ~M))}
+   NORF1 = {~((CN & NORB0 & ~M) | (NORA0 & ~M))}
+   F3BARO = {NORF3 ^ XOR3}
+   F2BARO = {NORF2 ^ XOR2}
+   F1BARO = {NORF1 ^ XOR1}
+   F0BARO = {XOR0 ^ (~(CN & ~M))}
+   AEQUALBO = {F3BARO & F2BARO & F1BARO & F0BARO}
+   GBARO = {~((~M & NORA3) | (~M & NORB3 & NORA2) | (~M & NORB3 & NORB2 & NORA1) |
+             (~M & NORB3 & NORB2 & NORB1 & NORA0))}
+   X = {M & F0BARO & F1BARO & F2BARO & F3BARO}
+   CN4O = {~GBARO | ((X & CN) | (~M & NORB3 & NORB2 & NORB1 & NORB0 & CN))}
+   PBARO = {~((NORB3 & NORB2 & NORB1 & NORB0 & ~M) | X)}

U2 PINDLY(8,0,14) DPWR DGND
+ GBARO CN4O PBARO AEQUALBO F3BARO F2BARO F1BARO F0BARO
+ M S0 S1 S2 S3 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR CN
+ GBAR CN4 PBAR AEQUALBUB F3BAR F2BAR F1BAR F0BAR
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = {CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) | CHANGED(A3BAR,0) |
+           CHANGED(B0BAR,0) | CHANGED(B1BAR,0) | CHANGED(B2BAR,0) | CHANGED(B3BAR,0)}
+   CARRY = {CHANGED(CN,0)}
+ PINDLY:
+   GBAR = {
+     CASE(
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(2NS,-1,10NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(2NS,-1,10NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(2NS,-1,12NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(2NS,-1,12NS),
+       DELAY(3NS,-1,13NS))}
+   CN4 = {
+     CASE(
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(2NS,-1,15NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(2NS,-1,15NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(2NS,-1,19NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(2NS,-1,19NS),
+       DATA & M == '1 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         CN=='1 & TRN_LH, DELAY(2NS,-1,21NS),
+       DATA & M == '1 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         CN=='1 & TRN_HL, DELAY(2NS,-1,21NS),
+       DATA & M == '1 & S1 == '0 & S2 == '1 & S0 == '0 & S3 == '0 &
+         CN=='1 & TRN_LH, DELAY(2NS,-1,22NS),
+       DATA & M == '1 & S1 == '0 & S2 == '1 & S0 == '0 & S3 == '0 &
+         CN=='1 & TRN_HL, DELAY(2NS,-1,22NS),
+       CARRY & TRN_LH, DELAY(2NS,-1,12NS),
+       CARRY & TRN_HL, DELAY(2NS,-1,12NS),
+       DELAY(3NS,-1,23NS))}
+   PBAR = {
+     CASE(
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(2NS,-1,11NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(2NS,-1,11NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(2NS,-1,13NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(2NS,-1,13NS),
+       DATA & M == '1 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         CN=='1 & TRN_LH, DELAY(2NS,-1,18NS),
+       DATA & M == '1 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         CN=='1 & TRN_HL, DELAY(2NS,-1,18NS),
+       DATA & M == '1 & S1 == '0 & S2 == '1 & S0 == '0 & S3 == '0 &
+         CN=='1 & TRN_LH, DELAY(2NS,-1,18NS),
+       DATA & M == '1 & S1 == '0 & S2 == '1 & S0 == '0 & S3 == '0 &
+         CN=='1 & TRN_HL, DELAY(2NS,-1,18NS),
+       DELAY(3NS,-1,19NS))}
+    AEQUALBUB = {
+     CASE(
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(4NS,-1,24NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(4NS,-1,24NS),
+       DELAY(5NS,-1,25NS))}
+    F0BAR F1BAR F2BAR F3BAR = {
+     CASE(
+       DATA & M == '1 & TRN_LH, DELAY(2NS,-1,14NS),
+       DATA & M == '1 & TRN_HL, DELAY(2NS,-1,14NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(2NS,-1,11NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(2NS,-1,11NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(2NS,-1,13NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(2NS,-1,13NS),
+       DELAY(6NS,-1,15.5NS))}

U3 BUF DPWR DGND
+ AEQUALBUB AEQUALB
+ D0_GATE IO_AS00_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS 74AS881B

* ----------------------------------------------------------- 74AS882A ------
*  Arithmetic Logic Units/Function Generators
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-769 to 2-776
*  bss    6/21/94
*
.SUBCKT 74AS882A CN P0BAR P1BAR P2BAR P3BAR P4BAR P5BAR P6BAR P7BAR 
+     G0BAR G1BAR G2BAR G3BAR G4BAR G5BAR G6BAR G7BAR CN8 CN16 CN24 CN32
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1LOG LOGICEXP(17,4) DPWR DGND
+     CN P0BAR P1BAR P2BAR P3BAR P4BAR P5BAR P6BAR P7BAR
+     G0BAR G1BAR G2BAR G3BAR G4BAR G5BAR G6BAR G7BAR
+     CN8_O CN16_O CN24_O CN32_O
+     D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  LOGIC:
+     cnbar = {~CN}
+     c327 = {(P7BAR & G7BAR)}
+     c326 = {(G7BAR & G6BAR & P6BAR)}
+     c325 = {(G7BAR & G6BAR & G5BAR & P5BAR)}
+     c324 = {(G7BAR & G6BAR & G5BAR & G4BAR & P4BAR)}
+     c323 = {(G7BAR & G6BAR & G5BAR & G4BAR & G3BAR & P3BAR)}
+     c322 = {(G7BAR & G6BAR & G5BAR & G4BAR & G3BAR & G2BAR & P2BAR)}
+     c321 = {(G7BAR & G6BAR & G5BAR & G4BAR & G3BAR & G2BAR & G1BAR & P1BAR)}
+     c320 = {(G7BAR & G6BAR & G5BAR & G4BAR & G3BAR & G2BAR & G1BAR & G0BAR &
+          P0BAR)}
+     c32c = {(G7BAR & G6BAR & G5BAR & G4BAR & G3BAR & G2BAR & G1BAR & G0BAR &
+          cnbar)}
+     CN32_O = {~(c327 | c326 | c325 | c324 | c323 | c322 | c321 | c320 | c32c)}
+     c245 = {(G5BAR & P5BAR)}
+     c244 = {(G5BAR & G4BAR & P4BAR)}
+     c243 = {(G5BAR & G4BAR & G3BAR & P3BAR)}
+     c242 = {(G5BAR & G4BAR & G3BAR & G2BAR & P2BAR)}
+     c241 = {(G5BAR & G4BAR & G3BAR & G2BAR & G1BAR & P1BAR)}
+     c240 = {(G5BAR & G4BAR & G3BAR & G2BAR & G1BAR & G0BAR & P0BAR)}
+     c24c = {(G5BAR & G4BAR & G3BAR & G2BAR & G1BAR & G0BAR & cnbar)}
+     CN24_O = {~(c245 | c244 | c243 | c242 | c241 | c240 | c24c)}
+     c163 = {(G3BAR & P3BAR)}
+     c162 = {(G3BAR & G2BAR & P2BAR)}
+     c161 = {(G3BAR & G2BAR & G1BAR & P1BAR)}
+     c160 = {(G3BAR & G2BAR & G1BAR & G0BAR & P0BAR)}
+     c16c = {(G3BAR & G2BAR & G1BAR & G0BAR & cnbar)}
+     CN16_O = {~(c163 | c162 | c161 | c160 | c16c)}
+     c81 = {(G1BAR & P1BAR)}
+     c80 = {(G1BAR & G0BAR & P0BAR)}
+     c8c = {(G1BAR & G0BAR & cnbar)}
+     CN8_O = {~(c81 | c80 | c8c)}

U2DLY PINDLY(4,0,17) DPWR DGND
+     CN32_O CN24_O CN16_O CN8_O
+     CN P0BAR P1BAR P2BAR P3BAR P4BAR P5BAR P6BAR P7BAR
+     G0BAR G1BAR G2BAR G3BAR G4BAR G5BAR G6BAR G7BAR
+     CN32 CN24 CN16 CN8
+     IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     DATA8 = {CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(G0BAR,0) |
+         CHANGED(G1BAR,0)} 
+     DATA16 = {DATA8 | CHANGED(P2BAR,0) | CHANGED(P3BAR,0) | 
+         CHANGED(G2BAR,0) | CHANGED(G3BAR,0)}
+     DATA24 = {DATA16 | CHANGED(P4BAR,0) | CHANGED(P5BAR,0) | 
+         CHANGED(G4BAR,0) | CHANGED(G5BAR,0)}
+     DATA32 = {DATA24 | CHANGED(P6BAR,0) | CHANGED(P7BAR,0) | 
+         CHANGED(G6BAR,0) | CHANGED(G7BAR,0)}
+     CARRY = {CHANGED(CN,0)}
+
+  PINDLY:
+     CN32 = {
+       CASE(
+         CARRY & TRN_LH, DELAY(2ns,-1,9ns),
+         CARRY & TRN_HL, DELAY(3ns,-1,14ns),
+         DATA32 & TRN_LH, DELAY(2ns,-1,8ns),
+         DATA32 & TRN_HL, DELAY(2ns,-1,12ns),
+         DELAY(4ns,-1,15ns))}
+
+     CN24 = {
+       CASE(
+         CARRY & TRN_LH, DELAY(2ns,-1,9ns),
+         CARRY & TRN_HL, DELAY(3ns,-1,14ns),
+         DATA24 & TRN_LH, DELAY(2ns,-1,7ns),
+         DATA24 & TRN_HL, DELAY(2ns,-1,10ns),
+         DELAY(4ns,-1,15ns))}
+
+     CN16 = {
+       CASE(
+         CARRY & TRN_LH, DELAY(2ns,-1,9ns),
+         CARRY & TRN_HL, DELAY(3ns,-1,14ns),
+         DATA16 & TRN_LH, DELAY(2ns,-1,7ns),
+         DATA16 & TRN_HL, DELAY(2ns,-1,7ns),
+         DELAY(4ns,-1,15ns))}
+
+     CN8 = {
+       CASE(
+         CARRY & TRN_LH, DELAY(2ns,-1,9ns),
+         CARRY & TRN_HL, DELAY(3ns,-1,14ns),
+         DATA8 & TRN_LH, DELAY(2ns,-1,7ns),
+         DATA8 & TRN_HL, DELAY(2ns,-1,7ns),
+         DELAY(4ns,-1,15ns))}

.ENDS 74AS882A
*
*
*-----------------------------------------------------------74AS885------

* 8 Bit Magnitude Comparitor
* TI ALS/AS Logic Data Book, 1986, pages 2-777 to 2-782
* jat 3/26/96

.SUBCKT 74AS885
+ P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 PLSQIN PGRTQIN
+ PLSQOUT PGRTQOUT PLE L/ABAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(35,2) DPWR DGND
+ P0L P1L P2L P3L P4L P5L P6L P7L
+ P0LBAR P1LBAR P2LBAR P3LBAR P4LBAR P5LBAR P6LBAR P7LBAR
+ Q0L Q1L Q2L Q3L Q4L Q5L Q6L Q7L
+ Q0LBAR Q1LBAR Q2LBAR Q3LBAR Q4LBAR Q5LBAR Q6LBAR Q7LBAR
+ PGRTQIN PLSQIN L/ABAR
+ D1 D2
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  EQ0 = {~((P0LBAR & Q0L) | (Q0LBAR & P0L))}
+  EQ1 = {~((P1LBAR & Q1L) | (Q1LBAR & P1L))}
+  EQ2 = {~((P2LBAR & Q2L) | (Q2LBAR & P2L))}
+  EQ3 = {~((P3LBAR & Q3L) | (Q3LBAR & P3L))}
+  EQ5 = {~((P5LBAR & Q5L) | (Q5LBAR & P5L))}
+  EQ6 = {~((P6LBAR & Q6L) | (Q6LBAR & P6L))}
+  EQ7 = {~((P7LBAR & Q7L) | (Q7LBAR & P7L))}
+  NEQ4A = {P4LBAR & Q4L}
+  NEQ4B = {Q4LBAR & P4L}
+  NEQ5A = {P5LBAR & Q5L}
+  NEQ5B = {Q5LBAR & P5L}
+  NEQ6A = {P6LBAR & Q6L}
+  NEQ6B = {Q6LBAR & P6L}
+  NEQ7A = {P7LBAR & Q7L}
+  NEQ7B = {Q7LBAR & P7L}
+  4MSB = {~(NEQ4A | NEQ4B | NEQ5A | NEQ5B | NEQ6A | NEQ6B | NEQ7A | NEQ7B)}
+  L/A = {~L/ABAR}
+  AND1 = {P7L & Q7LBAR & L/A}
+  AND2 = {P7LBAR & Q7L & L/ABAR}
+  AND3 = {P6LBAR & Q6L & EQ7}
+  AND4 = {P5LBAR & Q5L & EQ7 & EQ6}
+  AND5 = {P4LBAR & Q4L & EQ7 & EQ6 & EQ5}
+  AND6 = {P3LBAR & Q3L & 4MSB}
+  AND7 = {P2LBAR & Q2L & 4MSB & EQ3}
+  AND8 = {P1LBAR & Q1L & 4MSB & EQ3 & EQ2}
+  AND9 = {P0LBAR & Q0L & 4MSB & EQ3 & EQ2 & EQ1}
+  AND10 = {4MSB & EQ3 & EQ2 & EQ1 & EQ0 & PLSQIN}
+  AND11 = {P7L & Q7LBAR & L/ABAR}
+  AND12 = {P7LBAR & Q7L & L/A}
+  AND13 = {P6L & Q6LBAR & EQ7}
+  AND14 = {P5L & Q5LBAR & EQ7 & EQ6}
+  AND15 = {P4L & Q4LBAR & EQ7 & EQ6 & EQ5}
+  AND16 = {P3L & Q3LBAR & 4MSB}
+  AND17 = {P2L & Q2LBAR & EQ3 & 4MSB}
+  AND18 = {P1L & Q1LBAR & 4MSB & EQ3 & EQ2}
+  AND19 = {P0L & Q0LBAR & 4MSB & EQ3 & EQ2 & EQ1}
+  AND20 = {4MSB & EQ3 & EQ2 & EQ1 & EQ0 & PGRTQIN}
+  D1 = {AND1 | AND2 | AND3 | AND4 | AND5 | AND6 | AND7 | AND8 | AND9 | AND10}
+  D2 = {AND11 | AND12 | AND13 | AND14 | AND15 | AND16 | AND17 | AND18 | AND19 | AND20}

U2 DLTCH(8) DPWR DGND
+ $D_HI $D_HI PLE
+ P0 P1 P2 P3 P4 P5 P6 P7
+ P0L P1L P2L P3L P4L P5L P6L P7L
+ P0LBAR P1LBAR P2LBAR P3LBAR P4LBAR P5LBAR P6LBAR P7LBAR
+ D0_GFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(8) DPWR DGND
+ $D_HI $D_HI $D_HI
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ Q0L Q1L Q2L Q3L Q4L Q5L Q6L Q7L
+ Q0LBAR Q1LBAR Q2LBAR Q3LBAR Q4LBAR Q5LBAR Q6LBAR Q7LBAR
+ D0_GFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(2,0,19) DPWR DGND
+ D1 D2
+ L/ABAR PLSQIN PGRTQIN P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ PLSQOUT PGRTQOUT
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LOGIC = {CHANGED(L/ABAR,0)}
+   LG = {CHANGED(PLSQIN,0) | CHANGED(PGRTQIN,0)}
+   DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) |
+           CHANGED(P4,0) | CHANGED(P5,0) | CHANGED(P6,0) | CHANGED(P7,0) |
+           CHANGED(Q0,0) | CHANGED(Q1,0) | CHANGED(Q2,0) | CHANGED(Q3,0) |
+           CHANGED(Q4,0) | CHANGED(Q5,0) | CHANGED(Q6,0) | CHANGED(Q7,0)}
+ PINDLY:
+   PLSQOUT PGRTQOUT = {
+     CASE(
+       LOGIC & TRN_LH, DELAY(-1,8.5NS,13NS),
+       LOGIC & TRN_HL, DELAY(-1,7.5NS,13NS),
+       LG & TRN_LH, DELAY(-1,5NS,8NS),
+       LG & TRN_HL, DELAY(-1,5.5NS,8NS),
+       DATA & TRN_LH, DELAY(-1,13.5NS,17.5NS),
+       DATA & TRN_HL, DELAY(-1,10NS,15NS),
+       DELAY(-1,14.5NS,18.5NS))}

U5 CONSTRAINT(17) DPWR DGND
+ PLE P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_AS00 IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+    CLOCK HL = PLE
+    DATA(8) = P0 P1 P2 P3 P4 P5 P6 P7
+    SETUPTIME = 2NS
+    HOLDTIME = 4NS

.ENDS 74AS885

*-----------------------------------------------------------74AC898------

* 10-Bit Parallel-Out Serial Shift Register
* TI Advanced CMOS Logic Databook, 1993, pages 2-617 to 2-622
* jat 12/26/95

.SUBCKT 74AC898 A B CLK CLRBAR QA QB QC QD QE QF QG QH QI QJ
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ A B DA
+ D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   DA = {A & B}

U2 DFF(10) DPWR DGND
+ $D_HI CLRBAR CLK
+ DA QAO QBO QCO QDO QEO QFO QGO QHO QIO
+ QAO QBO QCO QDO QEO QFO QGO QHO QIO QJO
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(10,0,2) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO QHO QIO QJO
+ CLRBAR CLK
+ QA QB QC QD QE QF QG QH QI QJ
+ IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   CLOCK = {CHANGED_LH(CLK,0)}
+ PINDLY:
+   QA QB QC QD QE QF QG QH QI QJ = {
+     CASE(
+       CLEAR & TRN_HL, DELAY(3.8NS,6.7NS,9.1NS),
+       CLOCK & TRN_LH, DELAY(2.7NS,5.5NS,7.9NS),
+       CLOCK & TRN_HL, DELAY(3.1NS,6.3NS,8.6NS),
+       DELAY(4.8NS,7.7NS,10.1NS))}

U4 CONSTRAINT(4) DPWR DGND
+ CLRBAR CLK A B
+ IO_AC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 60MEG
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 4.5NS
+ WIDTH:
+  NODE = CLK
+  MIN_LO = 8.3NS
+  MIN_HI = 8.3NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(2) = A B
+  SETUPTIME = 8.5NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 1.5NS

.ENDS 74AC898

*------------------------------------------------------------74ACT898------

* 10-Bit Parallel-Out Serial Shift Register
* TI Advanced CMOS Logic Databook, 1993, pages 2-623 to 2-627
* jat 12/26/95

.SUBCKT 74ACT898 A B CLK CLRBAR QA QB QC QD QE QF QG QH QI QJ
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ A B DA
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   DA = {A & B}

U2 DFF(10) DPWR DGND
+ $D_HI CLRBAR CLK
+ DA QAO QBO QCO QDO QEO QFO QGO QHO QIO
+ QAO QBO QCO QDO QEO QFO QGO QHO QIO QJO
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(10,0,2) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO QHO QIO QJO
+ CLRBAR CLK
+ QA QB QC QD QE QF QG QH QI QJ
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   CLOCK = {CHANGED_LH(CLK,0)}
+ PINDLY:
+   QA QB QC QD QE QF QG QH QI QJ = {
+     CASE(
+       CLEAR & TRN_HL, DELAY(4.6NS,6.7NS,11.1NS),
+       CLOCK & TRN_LH, DELAY(4.1NS,5.5NS,8.8NS),
+       CLOCK & TRN_HL, DELAY(4.4NS,6.3NS,9.4NS),
+       DELAY(5.6NS,7.7NS,12.1NS))}

U4 CONSTRAINT(4) DPWR DGND
+ CLRBAR CLK A B
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 40MEG
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 4.5NS
+ WIDTH:
+  NODE = CLK
+  MIN_LO = 12.5NS
+  MIN_HI = 12.5NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(2) = A B
+  SETUPTIME = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 1.5NS

.ENDS 74ACT898

*------------------------------------------------------------74LS952------

* Dual Rank 8-Bit Tri-State Shift Registers
* National LS/S/TTL Logic Data Book, 1989, pages 2-505 to 2-510
* jat 8/15/95

.SUBCKT 74LS952 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8 DISO IS DISI
+ DISTU DISTD DISS OS CLK
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(30,17) DPWR DGND
+ Q1A Q2A Q3A Q4A Q5A Q6A Q7A Q8A Q1B Q2B Q3B Q4B Q5B Q6B Q7B Q8B DISO DISI
+ DISTU DISTD IS DISS I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8
+ D1A D2A D3A D4A D5A D6A D7A D8A D1B D2B D3B D4B D5B D6B D7B D8B OUTENAB
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  D1A = {(Q1A & DISTU & DISI) | (I/O1 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q1B)}
+  D2A = {(Q2A & DISTU & DISI) | (I/O2 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q2B)}
+  D3A = {(Q3A & DISTU & DISI) | (I/O3 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q3B)}
+  D4A = {(Q4A & DISTU & DISI) | (I/O4 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q4B)}
+  D5A = {(Q5A & DISTU & DISI) | (I/O5 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q5B)}
+  D6A = {(Q6A & DISTU & DISI) | (I/O6 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q6B)}
+  D7A = {(Q7A & DISTU & DISI) | (I/O7 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q7B)}
+  D8A = {(Q8A & DISTU & DISI) | (I/O8 & ~DISI) | (~DISTU & (~(~DISTU & ~DISTD)) & Q8B)}
+  D1B = {(Q1B & DISTD & DISS) | (Q1A & (~(~DISTU & ~DISTD)) & ~DISTD) | (IS & ~DISS & DISTD)}
+  D2B = {(Q2B & DISTD & DISS) | (Q2A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q1B & ~DISS & DISTD)}
+  D3B = {(Q3B & DISTD & DISS) | (Q3A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q2B & ~DISS & DISTD)}
+  D4B = {(Q4B & DISTD & DISS) | (Q4A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q3B & ~DISS & DISTD)}
+  D5B = {(Q5B & DISTD & DISS) | (Q5A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q4B & ~DISS & DISTD)}
+  D6B = {(Q6B & DISTD & DISS) | (Q6A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q5B & ~DISS & DISTD)}
+  D7B = {(Q7B & DISTD & DISS) | (Q7A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q6B & ~DISS & DISTD)}
+  D8B = {(Q8B & DISTD & DISS) | (Q8A & (~(~DISTU & ~DISTD)) & ~DISTD) | (Q7B & ~DISS & DISTD)}
+  OUTENAB = {~(DISO | ~DISI)}

U2 DFF(8) DPWR DGND
+ $D_HI $D_HI CLK
+ D1A D2A D3A D4A D5A D6A D7A D8A
+ Q1A Q2A Q3A Q4A Q5A Q6A Q7A Q8A
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(8) DPWR DGND
+ $D_HI $D_HI CLK
+ D1B D2B D3B D4B D5B D6B D7B D8B
+ Q1B Q2B Q3B Q4B Q5B Q6B Q7B Q8B
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(9,1,0) DPWR DGND
+ Q1A Q2A Q3A Q4A Q5A Q6A Q7A Q8A Q8B
+ OUTENAB
+ I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8 OS
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = OUTENAB
+   I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,23NS),
+       TRN_ZL, DELAY(4NS,-1,18NS),
+       TRN_HZ, DELAY(5NS,-1,23NS),
+       TRN_LZ, DELAY(6NS,-1,27NS),
+       TRN_LH, DELAY(7NS,-1,33NS),
+       TRN_HL, DELAY(10NS,-1,48NS),
+       DELAY(11NS,-1,49NS))}
+ PINDLY:
+   OS = {
+     CASE(
+       TRN_LH, DELAY(7NS,-1,33NS),
+       TRN_HL, DELAY(10NS,-1,48NS),
+       DELAY(11NS,-1,49NS))}

U5 CONSTRAINT(10) DPWR DGND
+ CLK IS I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 25MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 17NS
+  MIN_LO = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(9) = IS I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8
+  SETUPTIME = 10NS

.ENDS 74LS952

*------------------------------------------------------------74LS962------

* Dual Rank 8-Bit Tri-State Shift Registers
* National LS/S/TTL Logic Data Book, 1989, pages 2-51 to 2-516
* jat 8/15/95

.SUBCKT 74LS962 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8 DISO IS DISI
+ DISTU DISTD DISS OS CLK
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(30,17) DPWR DGND
+ Q1A Q2A Q3A Q4A Q5A Q6A Q7A Q8A Q1B Q2B Q3B Q4B Q5B Q6B Q7B Q8B DISO DISI
+ DISTU DISTD IS DISS I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8
+ D1A D2A D3A D4A D5A D6A D7A D8A D1B D2B D3B D4B D5B D6B D7B D8B OUTENAB
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  D1A = {(Q1A & DISTU & DISI) | (I/O1 & ~DISI) | (~DISTU & Q1B)}
+  D2A = {(Q2A & DISTU & DISI) | (I/O2 & ~DISI) | (~DISTU & Q2B)}
+  D3A = {(Q3A & DISTU & DISI) | (I/O3 & ~DISI) | (~DISTU & Q3B)}
+  D4A = {(Q4A & DISTU & DISI) | (I/O4 & ~DISI) | (~DISTU & Q4B)}
+  D5A = {(Q5A & DISTU & DISI) | (I/O5 & ~DISI) | (~DISTU & Q5B)}
+  D6A = {(Q6A & DISTU & DISI) | (I/O6 & ~DISI) | (~DISTU & Q6B)}
+  D7A = {(Q7A & DISTU & DISI) | (I/O7 & ~DISI) | (~DISTU & Q7B)}
+  D8A = {(Q8A & DISTU & DISI) | (I/O8 & ~DISI) | (~DISTU & Q8B)}
+  D1B = {(Q1B & DISTD & DISS) | (Q1A & ~DISTD) | (IS & ~DISS & DISTD)}
+  D2B = {(Q2B & DISTD & DISS) | (Q2A & ~DISTD) | (Q1B & ~DISS & DISTD)}
+  D3B = {(Q3B & DISTD & DISS) | (Q3A & ~DISTD) | (Q2B & ~DISS & DISTD)}
+  D4B = {(Q4B & DISTD & DISS) | (Q4A & ~DISTD) | (Q3B & ~DISS & DISTD)}
+  D5B = {(Q5B & DISTD & DISS) | (Q5A & ~DISTD) | (Q4B & ~DISS & DISTD)}
+  D6B = {(Q6B & DISTD & DISS) | (Q6A & ~DISTD) | (Q5B & ~DISS & DISTD)}
+  D7B = {(Q7B & DISTD & DISS) | (Q7A & ~DISTD) | (Q6B & ~DISS & DISTD)}
+  D8B = {(Q8B & DISTD & DISS) | (Q8A & ~DISTD) | (Q7B & ~DISS & DISTD)}
+  OUTENAB = {~(DISO | ~DISI)}

U2 DFF(8) DPWR DGND
+ $D_HI $D_HI CLK
+ D1A D2A D3A D4A D5A D6A D7A D8A
+ Q1A Q2A Q3A Q4A Q5A Q6A Q7A Q8A
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(8) DPWR DGND
+ $D_HI $D_HI CLK
+ D1B D2B D3B D4B D5B D6B D7B D8B
+ Q1B Q2B Q3B Q4B Q5B Q6B Q7B Q8B
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(9,1,0) DPWR DGND
+ Q1A Q2A Q3A Q4A Q5A Q6A Q7A Q8A Q8B
+ OUTENAB
+ I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8 OS
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = OUTENAB
+   I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,23NS),
+       TRN_ZL, DELAY(4NS,-1,18NS),
+       TRN_HZ, DELAY(5NS,-1,23NS),
+       TRN_LZ, DELAY(6NS,-1,27NS),
+       TRN_LH, DELAY(7NS,-1,33NS),
+       TRN_HL, DELAY(10NS,-1,48NS),
+       DELAY(11NS,-1,49NS))}
+ PINDLY:
+   OS = {
+     CASE(
+       TRN_LH, DELAY(7NS,-1,33NS),
+       TRN_HL, DELAY(10NS,-1,48NS),
+       DELAY(11NS,-1,49NS))}

U5 CONSTRAINT(10) DPWR DGND
+ CLK IS I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 25MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 17NS
+  MIN_LO = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(9) = IS I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 I/O8
+  SETUPTIME = 10NS

.ENDS 74LS962

* ----------------------------------------------------------- 74ALS990 ------
*  8-Bit D-Type Transparent Read-Back Latches
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-795 to 2-801
*  bss    6/22/94
*
.SUBCKT 74ALS990 OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dltch(8) DPWR DGND
+     $D_HI $D_HI C
+     1D 2D 3D 4D 5D 6D 7D 8D
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O
+     $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+     D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(16,1,9) DPWR DGND
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O
+     OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D C
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 1D 2D 3D 4D 5D 6D 7D 8D
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     GATE = {CHANGED_LH(C,0)}
+     DATA = {CHANGED(1D,0) | CHANGED(2D,0) | CHANGED(3D,0) | CHANGED(4D,0) |
+         CHANGED(5D,0) | CHANGED(6D,0) | CHANGED(7D,0) | CHANGED(8D,0)}
+
+  TRISTATE:
+     ENABLE LO=OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D = {
+       CASE(
+         TRN_Z$, DELAY(-1,12ns,18ns),
+         TRN_$Z, DELAY(-1,10ns,18ns),
+         DELAY(-1,13ns,19ns))}
+
+  PINDLY:
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q = {
+       CASE(
+         GATE & TRN_LH, DELAY(-1,13ns,22ns),
+         GATE & TRN_HL, DELAY(-1,16ns,23ns),
+         DATA & TRN_LH, DELAY(-1,8ns,14ns),
+         DATA & TRN_HL, DELAY(-1,11ns,22ns),
+         DELAY(-1,17ns,24ns))}

U3CON CONSTRAINT(10) DPWR DGND
+     OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=C
+     MIN_HI=10ns
+
+  SETUP_HOLD:
+     CLOCK HL=C
+     DATA(8)=1D 2D 3D 4D 5D 6D 7D 8D
+     SETUPTIME=10ns
+     HOLDTIME=5ns
+
+  SETUP_HOLD:
+     CLOCK HL=OERBBAR
+     DATA(8)=1D 2D 3D 4D 5D 6D 7D 8D
+     SETUPTIME=10ns

.ENDS 74ALS990
*
*
* ----------------------------------------------------------- 74ALS991 ------
*  8-Bit D-Type Transparent Read-Back Latches
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-795 to 2-801
*  bss    6/22/94
*
.SUBCKT 74ALS991 OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dltch(8) DPWR DGND
+     $D_HI $D_HI C
+     1D 2D 3D 4D 5D 6D 7D 8D
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O
+     1QB 2QB 3QB 4QB 5QB 6QB 7QB 8QB
+     D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(16,1,9) DPWR DGND
+     1QB 2QB 3QB 4QB 5QB 6QB 7QB 8QB
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O
+     OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D C
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 1D 2D 3D 4D 5D 6D 7D 8D
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     GATE = {CHANGED_LH(C,0)}
+     DATA = {CHANGED(1D,0) | CHANGED(2D,0) | CHANGED(3D,0) | CHANGED(4D,0) |
+         CHANGED(5D,0) | CHANGED(6D,0) | CHANGED(7D,0) | CHANGED(8D,0)}
+
+  TRISTATE:
+     ENABLE LO=OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D = {
+       CASE(
+         TRN_Z$, DELAY(-1,12ns,17ns),
+         TRN_$Z, DELAY(-1,8ns,12ns),
+         DELAY(-1,13ns,18ns))}
+
+  PINDLY:
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q = {
+       CASE(
+         GATE & TRN_LH, DELAY(-1,17ns,21ns),
+         GATE & TRN_HL, DELAY(-1,14ns,18ns),
+         DATA & TRN_LH, DELAY(-1,12ns,15ns),
+         DATA & TRN_HL, DELAY(-1,9ns,12ns),
+         DELAY(-1,18ns,22ns))}

U3CON CONSTRAINT(10) DPWR DGND
+     OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=C
+     MIN_HI=10ns
+
+  SETUP_HOLD:
+     CLOCK HL=C
+     DATA(8)=1D 2D 3D 4D 5D 6D 7D 8D
+     SETUPTIME=10ns
+     HOLDTIME=5ns
+
+  SETUP_HOLD:
+     CLOCK HL=OERBBAR
+     DATA(8)=1D 2D 3D 4D 5D 6D 7D 8D
+     SETUPTIME=10ns

.ENDS 74ALS991
*
*
* ----------------------------------------------------------- 74ALS992 ------
*  9-Bit D-Type Transparent Read-Back Latches With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-803 to 2-809
*  bss    6/22/94
*
.SUBCKT 74ALS992 OERBBAR OEQBAR CLRBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dltch(9) DPWR DGND
+     $D_HI CLRBAR C
+     1D 2D 3D 4D 5D 6D 7D 8D 9D
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O
+     $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+     D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(18,2,11) DPWR DGND
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O
+     OERBBAR OEQBAR
+     CLRBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     GATE = {CHANGED_LH(C,0)}
+     CLEAR = {CHANGED_HL(CLRBAR,0)}
+     DATA = {CHANGED(1D,0) | CHANGED(2D,0) | CHANGED(3D,0) | CHANGED(4D,0) |
+         CHANGED(5D,0) | CHANGED(6D,0) | CHANGED(7D,0) | CHANGED(8D,0) | 
+         CHANGED(9D,0)}
+
+  TRISTATE:
+     ENABLE LO=OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D 9D = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,15ns,22ns),
+         TRN_Z$, DELAY(-1,11ns,17ns),
+         TRN_$Z, DELAY(-1,6ns,11ns),
+         DELAY(-1,16ns,23ns))}
+
+  TRISTATE:
+     ENABLE LO=OEQBAR
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,12ns,16ns),
+         GATE & TRN_LH, DELAY(-1,12ns,15ns),
+         GATE & TRN_HL, DELAY(-1,15ns,19ns),
+         DATA & TRN_LH, DELAY(-1,7ns,10ns),
+         DATA & TRN_HL, DELAY(-1,9ns,13ns),
+         TRN_Z$, DELAY(-1,11ns,16ns),
+         TRN_$Z, DELAY(-1,6ns,10ns),
+         DELAY(-1,16ns,20ns))}

U3CON CONSTRAINT(12) DPWR DGND
+     OERBBAR CLRBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=C
+     MIN_HI=10ns
+
+  WIDTH:
+     NODE=CLRBAR
+     MIN_LO=10ns
+
+  SETUP_HOLD:
+     CLOCK HL=C
+     DATA(9)=1D 2D 3D 4D 5D 6D 7D 8D 9D
+     SETUPTIME=10ns
+     HOLDTIME=5ns
+
+  SETUP_HOLD:
+     CLOCK HL=OERBBAR
+     DATA(9)=1D 2D 3D 4D 5D 6D 7D 8D 9D
+     SETUPTIME=10ns

.ENDS 74ALS992
*
*
* ----------------------------------------------------------- 74ALS993 ------
*  9-Bit D-Type Transparent Read-Back Latches With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-803 to 2-809
*  bss    6/22/94
*
.SUBCKT 74ALS993 OERBBAR OEQBAR CLRBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dltch(9) DPWR DGND
+     $D_HI CLRBAR C
+     1D 2D 3D 4D 5D 6D 7D 8D 9D
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O
+     1QB 2QB 3QB 4QB 5QB 6QB 7QB 8QB 9QB
+     D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(18,2,11) DPWR DGND
+     1QB 2QB 3QB 4QB 5QB 6QB 7QB 8QB 9QB
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O
+     OERBBAR OEQBAR
+     CLRBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     GATE = {CHANGED_LH(C,0)}
+     CLEAR = {CHANGED_HL(CLRBAR,0)}
+     DATA = {CHANGED(1D,0) | CHANGED(2D,0) | CHANGED(3D,0) | CHANGED(4D,0) |
+         CHANGED(5D,0) | CHANGED(6D,0) | CHANGED(7D,0) | CHANGED(8D,0) | 
+         CHANGED(9D,0)}
+
+  TRISTATE:
+     ENABLE LO=OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D 9D = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,15ns,22ns),
+         TRN_Z$, DELAY(-1,11ns,17ns),
+         TRN_$Z, DELAY(-1,6ns,11ns),
+         DELAY(-1,16ns,23ns))}
+
+  TRISTATE:
+     ENABLE LO=OEQBAR
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q = {
+       CASE(
+         CLEAR & TRN_LH, DELAY(-1,10ns,13ns),
+         GATE & TRN_LH, DELAY(-1,16ns,20ns),
+         GATE & TRN_HL, DELAY(-1,13ns,16ns),
+         DATA & TRN_LH, DELAY(-1,11ns,14ns),
+         DATA & TRN_HL, DELAY(-1,8ns,11ns),
+         TRN_Z$, DELAY(-1,11ns,16ns),
+         TRN_$Z, DELAY(-1,6ns,10ns),
+         DELAY(-1,17ns,21ns))}

U3CON CONSTRAINT(12) DPWR DGND
+     OERBBAR CLRBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=C
+     MIN_HI=10ns
+
+  WIDTH:
+     NODE=CLRBAR
+     MIN_LO=10ns
+
+  SETUP_HOLD:
+     CLOCK HL=C
+     DATA(9)=1D 2D 3D 4D 5D 6D 7D 8D 9D
+     SETUPTIME=10ns
+     HOLDTIME=5ns
+
+  SETUP_HOLD:
+     CLOCK HL=OERBBAR
+     DATA(9)=1D 2D 3D 4D 5D 6D 7D 8D 9D
+     SETUPTIME=10ns

.ENDS 74ALS993
*
*
* ----------------------------------------------------------- 74ALS994 ------
*  10-Bit D-Type Transparent Read-Back Latches
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-811 to 2-817
*  bss    6/22/94
*
.SUBCKT 74ALS994 OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D 
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dltch(10) DPWR DGND
+     $D_HI $D_HI C
+     1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O 10Q_O
+     $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+     D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(20,1,11) DPWR DGND
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O 10Q_O
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O 10Q_O
+     OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D 9D 10D C
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     GATE = {CHANGED_LH(C,0)}
+     DATA = {CHANGED(1D,0) | CHANGED(2D,0) | CHANGED(3D,0) | CHANGED(4D,0) |
+         CHANGED(5D,0) | CHANGED(6D,0) | CHANGED(7D,0) | CHANGED(8D,0) | 
+         CHANGED(9D,0) | CHANGED(10D,0)}
+
+  TRISTATE:
+     ENABLE LO=OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D 9D 10D = {
+       CASE(
+         TRN_Z$, DELAY(-1,11ns,17ns),
+         TRN_$Z, DELAY(-1,9ns,13ns),
+         DELAY(-1,12ns,18ns))}
+
+  PINDLY:
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q = {
+       CASE(
+         GATE & TRN_LH, DELAY(-1,12ns,16ns),
+         GATE & TRN_HL, DELAY(-1,16ns,21ns),
+         DATA & TRN_LH, DELAY(-1,7ns,10ns),
+         DATA & TRN_HL, DELAY(-1,11ns,15ns),
+         DELAY(-1,17ns,22ns))}

U3CON CONSTRAINT(12) DPWR DGND
+     OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=C
+     MIN_HI=10ns
+
+  SETUP_HOLD:
+     CLOCK HL=C
+     DATA(10)=1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     SETUPTIME=10ns
+     HOLDTIME=5ns
+
+  SETUP_HOLD:
+     CLOCK HL=OERBBAR
+     DATA(10)=1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     SETUPTIME=10ns

.ENDS 74ALS994
*
*
* ----------------------------------------------------------- 74ALS995 ------
*  10-Bit D-Type Transparent Read-Back Latches
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-811 to 2-817
*  bss    6/22/94
*
.SUBCKT 74ALS995 OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D 
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 dltch(10) DPWR DGND
+     $D_HI $D_HI C
+     1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O 10Q_O
+     1QB 2QB 3QB 4QB 5QB 6QB 7QB 8QB 9QB 10QB
+     D0_GFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2DLY PINDLY(20,1,11) DPWR DGND
+     1QB 2QB 3QB 4QB 5QB 6QB 7QB 8QB 9QB 10QB
+     1Q_O 2Q_O 3Q_O 4Q_O 5Q_O 6Q_O 7Q_O 8Q_O 9Q_O 10Q_O
+     OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D 9D 10D C
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     GATE = {CHANGED_LH(C,0)}
+     DATA = {CHANGED(1D,0) | CHANGED(2D,0) | CHANGED(3D,0) | CHANGED(4D,0) |
+         CHANGED(5D,0) | CHANGED(6D,0) | CHANGED(7D,0) | CHANGED(8D,0) | 
+         CHANGED(9D,0) | CHANGED(10D,0)}
+
+  TRISTATE:
+     ENABLE LO=OERBBAR
+     1D 2D 3D 4D 5D 6D 7D 8D 9D 10D = {
+       CASE(
+         TRN_Z$, DELAY(-1,12ns,18ns),
+         TRN_$Z, DELAY(-1,8ns,12ns),
+         DELAY(-1,13ns,19ns))}
+
+  PINDLY:
+     1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q = {
+       CASE(
+         GATE & TRN_LH, DELAY(-1,17ns,23ns),
+         GATE & TRN_HL, DELAY(-1,14ns,19ns),
+         DATA & TRN_LH, DELAY(-1,12ns,16ns),
+         DATA & TRN_HL, DELAY(-1,9ns,12ns),
+         DELAY(-1,18ns,24ns))}

U3CON CONSTRAINT(12) DPWR DGND
+     OERBBAR C 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=C
+     MIN_HI=10ns
+
+  SETUP_HOLD:
+     CLOCK HL=C
+     DATA(10)=1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     SETUPTIME=10ns
+     HOLDTIME=5ns
+
+  SETUP_HOLD:
+     CLOCK HL=OERBBAR
+     DATA(10)=1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+     SETUPTIME=10ns

.ENDS 74ALS995
*
*
*-------------------------------------------------------------74ALS996-----

* 8 Bit D-Type Edge Triggered Read-Back Latches
* TI ALS/AS Logic Data Book, 1986, pages 2-819 to 2-824
* jat 3/27/96

.SUBCKT 74ALS996
+ GBAR T/CBAR CLRBAR RDBAR ENBAR CLK 1D 2D 3D 4D 5D 6D 7D 8D 1Q 2Q 3Q 4Q 5Q
+ 6Q 7Q 8Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,10) DPWR DGND
+ CLK ENBAR RDBAR Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 T/CBAR
+ CLOCK ENABD 1QO 2QO 3QO 4QO 5QO 6QO 7QO 8QO
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CLK | ENBAR}
+   ENABD = {~ENBAR & ~RDBAR}
+   1QO = {Q1 ^ ~T/CBAR}
+   2QO = {Q2 ^ ~T/CBAR}
+   3QO = {Q3 ^ ~T/CBAR}
+   4QO = {Q4 ^ ~T/CBAR}
+   5QO = {Q5 ^ ~T/CBAR}
+   6QO = {Q6 ^ ~T/CBAR}
+   7QO = {Q7 ^ ~T/CBAR}
+   8QO = {Q8 ^ ~T/CBAR}

U2 DFF(8) DPWR DGND
+ $D_HI CLRBAR CLOCK
+ 1D 2D 3D 4D 5D 6D 7D 8D
+ Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,2,5) DPWR DGND
+ 1QO 2QO 3QO 4QO 5QO 6QO 7QO 8QO Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+ ENABD GBAR
+ ENBAR RDBAR CLRBAR CLK T/CBAR
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 1D 2D 3D 4D 5D 6D 7D 8D
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EN = {CHANGED(ENBAR,0)}
+   READ = {CHANGED(RDBAR,0)}
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   EDGE = {CHANGED_LH(CLK,0)}
+   TC = {CHANGED(T/CBAR,0)}
+ TRISTATE:
+   ENABLE HI = ENABD
+   1D 2D 3D 4D 5D 6D 7D 8D = {
+        CASE(
+           EN & TRN_Z$, DELAY(-1,9NS,14NS),
+           EN & TRN_$Z, DELAY(-1,10NS,16NS),
+           READ & TRN_Z$, DELAY(-1,9NS,15NS),
+           READ & TRN_$Z, DELAY(-1,10NS,16NS),
+           CLEAR & TRN_HL, DELAY(-1,19NS,25NS),
+           DELAY(-1,20NS,26NS))}
+ TRISTATE:
+    ENABLE LO = GBAR
+    1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q = {
+        CASE(
+           TRN_$Z, DELAY(-1,4NS,8NS),
+           TRN_Z$, DELAY(-1,8NS,13NS),
+           CLEAR & TRN_LH, DELAY(-1,15NS,23NS),
+           CLEAR & TRN_HL, DELAY(-1,13NS,19NS),
+           EDGE & TRN_LH, DELAY(-1,16NS,24NS),
+           EDGE & TRN_HL, DELAY(-1,16NS,24NS),
+           TC & (TRN_LH | TRN_HL), DELAY(-1,13NS,20NS),
+           DELAY(-1,17NS,25NS))}

U4 CONSTRAINT(12) DPWR DGND
+ CLK CLRBAR 1D 2D 3D 4D 5D 6D 7D 8D ENBAR RDBAR
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 35MEG
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 14.5NS
+   MIN_HI = 14.5NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 10NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(8) = 1D 2D 3D 4D 5D 6D 7D 8D
+   SETUPTIME = 15NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = ENBAR
+   SETUPTIME_LO = 10NS
+   HOLDTIME_LO = 5NS
+ SETUP_HOLD:
+   CLOCK LH = ENBAR
+   DATA(1) = CLK
+   SETUPTIME_HI = 15NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = CLRBAR
+   SETUPTIME_HI = 10NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = RDBAR
+   HOLDTIME_HI = 5NS

.ENDS 74ALS996

* ----------------------------------------------------------- 74ALS1000A ------
*  Quad 2-Input Positive-Nand Buffers/Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-825 to 2-827
*  bss    6/22/94
*
.SUBCKT 74ALS1000A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nand(2) DPWR DGND
+     1A 1B 1Y
+     DLY_ALS1000 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1000 ugate (tplhMN=2ns tplhTY=4ns tplhMX=8ns 
+                              tphlMN=2ns tphlTY=5ns tphlMX=7ns)

.ENDS 74ALS1000A
*
*
* ----------------------------------------------------------- 74AS1000A ------
*  Quad 2-Input Positive-Nand Buffers/Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-825 to 2-827
*  bss    6/22/94
*
.SUBCKT 74AS1000A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nand(2) DPWR DGND
+     1A 1B 1Y
+     DLY_AS1000 IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_AS1000 ugate (tplhMN=1ns tplhMX=4ns tphlMN=1ns tphlMX=4ns)

.ENDS 74AS1000A
*
*
* ----------------------------------------------------------- 74ALS1002A ------
*  Quad 2-Input Positive-Nor Buffers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-829 to 2-830
*  bss    6/22/94
*
.SUBCKT 74ALS1002A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nor(2) DPWR DGND
+     1A 1B 1Y
+     DLY_ALS1002 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1002 ugate (tplhMN=2ns tplhTY=4ns tplhMX=8ns 
+                              tphlMN=2ns tphlTY=4ns tphlMX=7ns)

.ENDS 74ALS1002A
*
*
* ----------------------------------------------------------- 74ALS1003A ------
*  Quad 2-Input Positive-Nand Buffers With Open-Collector Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-831 to 2-832
*  bss    6/22/94
*
.SUBCKT 74ALS1003A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nand(2) DPWR DGND
+     1A 1B 1Y
+     DLY_ALS1003 IO_ALS000_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1003 ugate (tplhMN=10ns tplhTY=18ns tplhMX=33ns 
+                              tphlMN=2ns tphlTY=7ns tphlMX=12ns)

.ENDS 74ALS1003A
*
*
* ----------------------------------------------------------- 74ALS1004 ------
*  Hex Inverting Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-833 to 2-835
*  bss    6/27/94
*
.SUBCKT 74ALS1004 1A 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     1A 1Y
+     DLY_ALS1004 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1004 ugate (tplhMN=1ns tplhMX=7ns tphlMN=1ns tphlMX=6ns)

.ENDS 74ALS1004
*
*
* ----------------------------------------------------------- 74AS1004A ------
*  Hex Inverting Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-833 to 2-835
*  bss    6/27/94
*
.SUBCKT 74AS1004A 1A 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     1A 1Y
+     DLY_AS1004 IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_AS1004 ugate (tplhMN=1ns tplhMX=4ns tphlMN=1ns tphlMX=4ns)

.ENDS 74AS1004A
*
*
* ----------------------------------------------------------- 74ALS1005 ------
*  Hex Inverting Drivers With Open-Collector Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-837 to 2-838
*  bss    6/27/94
*
.SUBCKT 74ALS1005 1A 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     1A 1Y
+     DLY_ALS1005 IO_ALS000_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1005 ugate (tplhMN=5ns tplhMX=30ns tphlMN=2ns tphlMX=10ns)

.ENDS 74ALS1005
*
*
* ----------------------------------------------------------- 74ALS1008A ------
*  Quad 2-Input Positive-And Buffers/Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-839 to 2-841
*  bss    6/27/94
*
.SUBCKT 74ALS1008A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 and(2) DPWR DGND
+     1A 1B 1Y
+     DLY_ALS1008 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1008 ugate (tplhMN=2ns tplhMX=9ns tphlMN=3ns tphlMX=9ns)

.ENDS 74ALS1008A
*
*
* ----------------------------------------------------------- 74AS1008A ------
*  Quad 2-Input Positive-And Buffers/Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-839 to 2-841
*  bss    6/27/94
*
.SUBCKT 74AS1008A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 and(2) DPWR DGND
+     1A 1B 1Y
+     DLY_AS1008 IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_AS1008 ugate (tplhMN=1ns tplhMX=6ns tphlMN=1ns tphlMX=6ns)

.ENDS 74AS1008A
*
*
* ----------------------------------------------------------- 74ALS1010A ------
*  Triple 3-Input Positive-Nand Buffers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-843 to 2-844
*  bss    6/27/94
*
.SUBCKT 74ALS1010A 1A 1B 1C 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nand(3) DPWR DGND
+     1A 1B 1C 1Y
+     DLY_ALS1010 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1010 ugate (tplhMN=2ns tplhMX=8ns tphlMN=2ns tphlMX=8ns)

.ENDS 74ALS1010A
*
*
* ----------------------------------------------------------- 74ALS1011A ------
*  Triple 3-Input Positive-And Buffers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-845 to 2-846
*  bss    6/27/94
*
.SUBCKT 74ALS1011A 1A 1B 1C 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 and(3) DPWR DGND
+     1A 1B 1C 1Y
+     DLY_ALS1011 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1011 ugate (tplhMN=2ns tplhMX=10ns tphlMN=3ns tphlMX=9ns)

.ENDS 74ALS1011A
*
*
* ----------------------------------------------------------- 74ALS1020A ------
*  Dual 4-Input Positive-Nand Buffers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-847 to 2-848
*  bss    6/27/94
*
.SUBCKT 74ALS1020A 1A 1B 1C 1D 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nand(4) DPWR DGND
+     1A 1B 1C 1D 1Y
+     DLY_ALS1020 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1020 ugate (tplhMN=2ns tplhMX=8ns tphlMN=2ns tphlTY=5ns tphlMX=7ns)

.ENDS 74ALS1020A
*
*
* ----------------------------------------------------------- 74ALS1032A ------
*  Quad 2-Input Positive-Or Buffers/Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-849 to 2-851
*  bss    6/27/94
*
.SUBCKT 74ALS1032A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 or(2) DPWR DGND
+     1A 1B 1Y
+     DLY_ALS1032 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1032 ugate (tplhMN=2ns tplhTY=6ns tplhMX=9ns
+                                    tphlMN=3ns tphlTY=7ns tphlMX=12ns)

.ENDS 74ALS1032A
*
*
* ----------------------------------------------------------- 74AS1032A ------
*  Quad 2-Input Positive-Or Buffers/Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-849 to 2-851
*  bss    6/27/94
*
.SUBCKT 74AS1032A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 or(2) DPWR DGND
+     1A 1B 1Y
+     DLY_AS1032 IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_AS1032 ugate (tplhMN=1ns tplhMX=6.3ns tphlMN=1ns tphlMX=6.3ns)

.ENDS 74AS1032A
*
*
* ----------------------------------------------------------- 74ALS1034 ------
*  Hex Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-853 to 2-855
*  bss    6/27/94
*
.SUBCKT 74ALS1034 1A 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 buf DPWR DGND
+     1A 1Y
+     DLY_ALS1034 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1034 ugate (tplhMN=1ns tplhMX=8ns tphlMN=1ns tphlMX=8ns)

.ENDS 74ALS1034
*
*
* ----------------------------------------------------------- 74AS1034A ------
*  Hex Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-853 to 2-855
*  bss    6/27/94
*
.SUBCKT 74AS1034A 1A 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 buf DPWR DGND
+     1A 1Y
+     DLY_AS1034 IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_AS1034 ugate (tplhMN=1ns tplhMX=6ns tphlMN=1ns tphlMX=6ns)

.ENDS 74AS1034A
*
*
* ----------------------------------------------------------- 74ALS1035 ------
*  Hex Noninverting Buffers With Open-Collector Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-857 to 2-858
*  bss    6/27/94
*
.SUBCKT 74ALS1035 1A 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 buf DPWR DGND
+     1A 1Y
+     DLY_ALS1035 IO_ALS000_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1035 ugate (tplhMN=5ns tplhMX=30ns tphlMN=2ns tphlMX=12ns)

.ENDS 74ALS1035
*
*
* ----------------------------------------------------------- 74AS1036A ------
*  Quad 2-Input Positive-Nor Drivers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-859 to 2-860
*  bss    6/27/94
*
.SUBCKT 74AS1036A 1A 1B 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nor(2) DPWR DGND
+     1A 1B 1Y
+     DLY_AS1036 IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_AS1036 ugate (tplhMN=1ns tplhMX=4.3ns tphlMN=1ns tphlMX=4.3ns)

.ENDS 74AS1036A
*
*
* -----------------------------------------------------------74AS1181------

* Arithmetic Logic Units/Function Generators
* TI ALS/AS Logic Data Book, 1986, pages 2-861 to 2-872
* jat 3/27/96

.SUBCKT 74AS1181
+ S0 S1 S2 S3 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR M CN
+ GBAR CN4 PBAR AEQB F0BAR F1BAR F2BAR F3BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,8) DPWR DGND
+ S0 S1 S2 S3 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR M CN
+ GBARO CN4O PBARO F3BARO F2BARO F1BARO F0BARO AEQBO
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   NORB3 = {~((B3BAR & S3 & A3BAR) | (A3BAR & S2 & ~B3BAR))}
+   NORA3 = {~((~B3BAR & S1) | (S0 & B3BAR) | A3BAR)}
+   NORB2 = {~((B2BAR & S3 & A2BAR) | (A2BAR & S2 & ~B2BAR))}
+   NORA2 = {~((~B2BAR & S1) | (S0 & B2BAR) | A2BAR)}
+   NORB1 = {~((B1BAR & S3 & A1BAR) | (A1BAR & S2 & ~B1BAR))}
+   NORA1 = {~((~B1BAR & S1) | (S0 & B1BAR) | A1BAR)}
+   NORB0 = {~((B0BAR & S3 & A0BAR) | (A0BAR & S2 & ~B0BAR))}
+   NORA0 = {~((~B0BAR & S1) | (S0 & B0BAR) | A0BAR)}
+   GBARO = {~(NORA3 | (NORB3 & NORA2) | (NORB3 & NORB2 & NORA1) |
+             (NORB3 & NORB2 & NORB1 & NORA0))}
+   CN4O = {~GBARO | (NORB3 & NORB2 & NORB1 & NORB0 & CN)}
+   PBARO = {~(NORB3 & NORB2 & NORB1 & NORB0)}
+   XOR3 = {NORB3 ^ NORA3}
+   XOR2 = {NORB2 ^ NORA2}
+   XOR1 = {NORB1 ^ NORA1}
+   XOR0 = {NORB0 ^ NORA0}
+   NORF3 = {~((CN & NORB2 & NORB1 & NORB0 & ~M) | (NORB2 & NORB1 & NORA0 & ~M) |
+              (NORB2 & NORA1 & ~M) | (NORA2 & ~M))}
+   NORF2 = {~((CN & NORB0 & NORB1 & ~M) | (NORB1 & NORA0 & ~M) | (NORA1 & ~M))}
+   NORF1 = {~((CN & NORB0 & ~M) | (NORA0 & ~M))}
+   F3BARO = {NORF3 ^ XOR3}
+   F2BARO = {NORF2 ^ XOR2}
+   F1BARO = {NORF1 ^ XOR1}
+   F0BARO = {XOR0 ^ (~(CN & ~M))}
+   AEQBO = {F3BARO & F2BARO & F1BARO & F0BARO}

U2 PINDLY(8,0,14) DPWR DGND
+ GBARO CN4O PBARO AEQBO F3BARO F2BARO F1BARO F0BARO
+ M S0 S1 S2 S3 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR CN
+ GBAR CN4 PBAR AEQB F3BAR F2BAR F1BAR F0BAR
+ IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   MODE = {CHANGED(M,0)}
+   SELECT = {CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0) | CHANGED(S3,0)}
+   DATA = {CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) | CHANGED(A3BAR,0) |
+           CHANGED(B0BAR,0) | CHANGED(B1BAR,0) | CHANGED(B2BAR,0) | CHANGED(B3BAR,0)}
+   CARRY = {CHANGED(CN,0)}
+ PINDLY:
+   GBAR = {
+     CASE(
+       SELECT & M == '0 & TRN_LH, DELAY(3NS,-1,9NS),
+       SELECT & M == '0 & TRN_HL, DELAY(2NS,-1,6NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(3NS,-1,8NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(2NS,-1,6NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(3NS,-1,9.5NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(2NS,-1,7NS),
+       DELAY(4NS,-1,10.5NS))}
+   CN4 = {
+     CASE(
+       SELECT & M == '1 & TRN_LH, DELAY(4.5NS,-1,15.5NS),
+       SELECT & M == '1 & TRN_HL, DELAY(3NS,-1,12NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(5NS,-1,12NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(5NS,-1,12NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(5NS,-1,12NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(5NS,-1,12.5NS),
+       CARRY & TRN_LH, DELAY(3NS,-1,8.5NS),
+       CARRY & TRN_HL, DELAY(2NS,-1,6.5NS),
+       DELAY(6NS,-1,16.5NS))}
+   PBAR = {
+     CASE(
+       SELECT & M == '1 & TRN_LH, DELAY(3NS,-1,7.5NS),
+       SELECT & M == '1 & TRN_HL, DELAY(2NS,-1,6.5NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(3NS,-1,7.5NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(2NS,-1,6NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(3NS,-1,9NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(3NS,-1,8NS),
+       DELAY(4NS,-1,10NS))}
+    AEQB = {
+     CASE(
+       MODE & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 & TRN_LH, DELAY(7NS,-1,17.5NS),
+       MODE & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 & TRN_HL, DELAY(8NS,-1,17.5NS),
+       SELECT & M == '0 & TRN_LH, DELAY(5NS,-1,18NS),
+       SELECT & M == '0 & TRN_HL, DELAY(5NS,-1,18NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(4NS,-1,17NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(5NS,-1,15NS),
+       DELAY(9NS,-1,19NS))}
+    F0BAR F1BAR F2BAR F3BAR = {
+     CASE(
+       MODE & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 & TRN_LH, DELAY(5NS,-1,11.5NS),
+       MODE & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 & TRN_HL, DELAY(5NS,-1,11.5NS),
+       SELECT & M == '0 & TRN_LH, DELAY(3NS,-1,11NS),
+       SELECT & M == '0 & TRN_HL, DELAY(3NS,-1,11NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_LH, DELAY(3NS,-1,12NS),
+       DATA & M == '0 & S1 == '0 & S2 == '0 & S0 == '1 & S3 == '1 &
+         TRN_HL, DELAY(3NS,-1,11.5NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_LH, DELAY(3NS,-1,14.5NS),
+       DATA & M == '0 & S1 == '1 & S2 == '1 & S0 == '0 & S3 == '0 &
+         TRN_HL, DELAY(3NS,-1,12.5NS),
+       CARRY & M == '0 & TRN_LH, DELAY(3NS,-1,9NS),
+       CARRY & M == '0 & TRN_HL, DELAY(3NS,-1,7.5NS),
+       DELAY(6NS,-1,15.5NS))}

.ENDS 74AS1181

* ----------------------------------------------------------- 74ALS1240 ------
*  Octal Buffers And Line Drivers With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-873 to 2-876
*  bss    6/27/94
*
.SUBCKT 74ALS1240 1GBAR 1A1 1A2 1A3 1A4 1Y1 1Y2 1Y3 1Y4 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     1GBAR 1G
+     D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 inv3a(4) DPWR DGND
+     1A1 1A2 1A3 1A4
+     1G
+     1Y1 1Y2 1Y3 1Y4
+     DLY_ALS1240 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1240 utgate (tplhMN=2ns tplhTY=7.5ns tplhMX=13ns
+                                 tphlMN=2ns tphlTY=6.5ns tphlMX=13ns
+                                 tpzhMN=4ns tpzhTY=11.5ns tpzhMX=20ns
+                                 tpzlMN=6ns tpzlTY=14ns tpzlMX=22ns
+                                 tphzMN=2ns tphzTY=7.5ns tphzMX=10ns
+                                 tplzMN=3ns tplzTY=8ns tplzMX=13ns)

.ENDS 74ALS1240

*------------------------------------------------------------74ALS1240A-----

* Octal Tri-State Bus Driver
* National Advanced Bipolar Logic Databook, 1995, pages 9-205 to 9-207
* jat 8/21/96

.SUBCKT 74ALS1240A 1GBAR 1A1 1A2 1A3 1A4 1Y1 1Y2 1Y3 1Y4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(4,4) DPWR DGND
+ 1A1 1A2 1A3 1A4
+ 1Y1O 1Y2O 1Y3O 1Y4O
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1Y1O = {~1A1}
+   1Y2O = {~1A2}
+   1Y3O = {~1A3}
+   1Y4O = {~1A4}

U2 PINDLY(4,1,0) DPWR DGND
+ 1Y1O 1Y2O 1Y3O 1Y4O
+ 1GBAR
+ 1Y1 1Y2 1Y3 1Y4
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE LO = 1GBAR
+   1Y1 1Y2 1Y3 1Y4 = {
+     CASE(
+       TRN_ZH, DELAY(4NS,-1,20NS),
+       TRN_ZL, DELAY(6NS,-1,22NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(3NS,-1,13NS),
+       TRN_LH, DELAY(2NS,-1,13NS),
+       TRN_HL, DELAY(2NS,-1,13NS),
+       DELAY(6NS,-1,23NS))}

.ENDS 74ALS1240A

*------------------------------------------------------------74F1240-----

* Octal Inverter Buffer (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 837 to 841
* jat 7/30/96

.SUBCKT 74F1240 I0 I1 I2 I3  OEBAR Y0 Y1 Y2 Y3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(4,4) DPWR DGND
+ I0 I1 I2 I3
+ Y0O Y1O Y2O Y3O
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   Y0O = {~I0}
+   Y1O = {~I1}
+   Y2O = {~I2}
+   Y3O = {~I3}

U2 PINDLY(4,1,0) DPWR DGND
+ Y0O Y1O Y2O Y3O
+ OEBAR
+ Y0 Y1 Y2 Y3
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE LO = OEBAR
+   Y0 Y1 Y2 Y3 = {
+     CASE(
+       TRN_ZH, DELAY(3NS,5.5NS,7.5NS),
+       TRN_ZL, DELAY(4NS,7NS,9NS),
+       TRN_HZ, DELAY(2NS,4NS,6NS),
+       TRN_LZ, DELAY(2NS,4NS,5.5NS),
+       TRN_LH, DELAY(3NS,4.5NS,6.5NS),
+       TRN_HL, DELAY(1.5NS,2.5NS,4.5NS),
+       DELAY(5NS,8NS,10NS))}

.ENDS 74F1240

*------------------------------------------------------------74ALS1241A-----

* Octal Tri-State Bus Driver
* National ALS/AS Logic Databook, 1990, pages 2-288 to 2-291
* jat 8/21/96

.SUBCKT 74ALS1241A 1GBAR 2G 1A1 1A2 1A3 1A4 1Y1 1Y2 1Y3 1Y4 2A1 2A2 2A3 2A4
+ 2Y1 2Y2 2Y3 2Y4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(8,2,0) DPWR DGND
+ 1A1 1A2 1A3 1A4 2A1 2A2 2A3 2A4
+ 1GBAR 2G
+ 1Y1 1Y2 1Y3 1Y4 2Y1 2Y2 2Y3 2Y4
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE LO = 1GBAR
+   1Y1 1Y2 1Y3 1Y4 = {
+     CASE(
+       TRN_ZH, DELAY(6NS,-1,21NS),
+       TRN_ZL, DELAY(6NS,-1,21NS),
+       TRN_HZ, DELAY(2NS,-1,11NS),
+       TRN_LZ, DELAY(3NS,-1,16NS),
+       TRN_LH, DELAY(3NS,-1,11NS),
+       TRN_HL, DELAY(3NS,-1,12NS),
+       DELAY(7NS,-1,22NS))}
+ TRISTATE:
+ ENABLE HI = 2G
+   2Y1 2Y2 2Y3 2Y4 = {
+     CASE(
+       TRN_ZH, DELAY(6NS,-1,21NS),
+       TRN_ZL, DELAY(6NS,-1,21NS),
+       TRN_HZ, DELAY(2NS,-1,11NS),
+       TRN_LZ, DELAY(3NS,-1,16NS),
+       TRN_LH, DELAY(3NS,-1,11NS),
+       TRN_HL, DELAY(3NS,-1,12NS),
+       DELAY(7NS,-1,22NS))}

.ENDS 74ALS1241A

*------------------------------------------------------------74F1241-----

* Octal Buffer (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 837 to 841
* jat 7/30/96

.SUBCKT 74F1241 IA0 IA1 IA2 IA3 IB0 IB1 IB2 IB3 OEABAR OEB YA0 YA1 YA2 YA3
+ YB0 YB1 YB2 YB3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U2 PINDLY(8,2,0) DPWR DGND
+ IA0 IA1 IA2 IA3 IB0 IB1 IB2 IB3
+ OEABAR OEB
+ YA0 YA1 YA2 YA3 YB0 YB1 YB2 YB3
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE LO = OEABAR
+   YA0 YA1 YA2 YA3 = {
+     CASE(
+       TRN_ZH, DELAY(3NS,5.5NS,7NS),
+       TRN_ZL, DELAY(3NS,6.5NS,8NS),
+       TRN_HZ, DELAY(3NS,5.5NS,7.5NS),
+       TRN_LZ, DELAY(3NS,6NS,8NS),
+       TRN_LH, DELAY(2.5NS,4NS,5.5NS),
+       TRN_HL, DELAY(2.5NS,5NS,6.5NS),
+       DELAY(4NS,7.5NS,9NS))}
+ TRISTATE:
+ ENABLE HI = OEB
+   YB0 YB1 YB2 YB3 = {
+     CASE(
+       TRN_ZH, DELAY(3NS,5.5NS,7NS),
+       TRN_ZL, DELAY(3NS,6.5NS,8NS),
+       TRN_HZ, DELAY(3NS,5.5NS,7.5NS),
+       TRN_LZ, DELAY(3NS,6NS,8NS),
+       TRN_LH, DELAY(2.5NS,4NS,5.5NS),
+       TRN_HL, DELAY(2.5NS,5NS,6.5NS),
+       DELAY(4NS,7.5NS,9NS))}

.ENDS 74F1241

* ----------------------------------------------------------- 74ALS1242 ------
*  Quad Bus Transceivers With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-877 to 2-880
*  bss    6/27/94
*
.SUBCKT 74ALS1242 GABBAR GBA A1 A2 A3 A4 B1 B2 B3 B4 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     GABBAR GAB
+     D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 inv3a(4) DPWR DGND
+     A1 A2 A3 A4
+     GAB
+     B1 B2 B3 B4
+     DLY_ALS1242AB IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 inv3a(4) DPWR DGND
+     B1 B2 B3 B4
+     GBA
+     A1 A2 A3 A4
+     DLY_ALS1242BA IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1242AB utgate (tplhMN=2ns tplhTY=6ns tplhMX=12ns
+                                 tphlMN=2ns tphlTY=5ns tphlMX=10ns
+                                 tpzhMN=4ns tpzhTY=10ns tpzhMX=17ns
+                                 tpzlMN=5ns tpzlTY=13ns tpzlMX=21ns
+                                 tphzMN=2ns tphzTY=6ns tphzMX=10ns
+                                 tplzMN=2ns tplzTY=5ns tplzMX=10ns)

.model DLY_ALS1242BA utgate (tplhMN=2ns tplhTY=6ns tplhMX=12ns
+                                 tphlMN=2ns tphlTY=5ns tphlMX=10ns
+                                 tpzhMN=5ns tpzhTY=12ns tpzhMX=20ns
+                                 tpzlMN=6ns tpzlTY=14ns tpzlMX=23ns
+                                 tphzMN=2ns tphzTY=6ns tphzMX=10ns
+                                 tplzMN=2ns tplzTY=6ns tplzMX=12ns)

.ENDS 74ALS1242

*------------------------------------------------------------74ALS1242A-----

* Quad Bidirectional Bus Driver
* National ALS/AS Logic Databook, 1990, pages 2-292 to 2-295
* jat 8/21/96

.SUBCKT 74ALS1242A A1 A2 A3 A4 B1 B2 B3 B4 GABBAR GBA
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(8,8) DPWR DGND
+ A1 A2 A3 A4 B1 B2 B3 B4
+ B1O B2O B3O B4O A1O A2O A3O A4O
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   B1O = {~A1}
+   B2O = {~A2}
+   B3O = {~A3}
+   B4O = {~A4}
+   A1O = {~B1}
+   A2O = {~B2}
+   A3O = {~B3}
+   A4O = {~B4}

U2 PINDLY(8,2,0) DPWR DGND
+ A1O A2O A3O A4O B1O B2O B3O B4O
+ GBA GABBAR
+ A1 A2 A3 A4 B1 B2 B3 B4
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = GBA
+   A1 A2 A3 A4 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,20NS),
+       TRN_ZL, DELAY(6NS,-1,23NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(2NS,-1,16NS),
+       TRN_LH, DELAY(2NS,-1,12NS),
+       TRN_HL, DELAY(2NS,-1,10NS),
+       DELAY(6NS,-1,22NS))}
+ TRISTATE:
+ ENABLE LO = GABBAR
+   B1 B2 B3 B4 = {
+     CASE(
+       TRN_ZH, DELAY(4NS,-1,17NS),
+       TRN_ZL, DELAY(5NS,-1,21NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(2NS,-1,10NS),
+       TRN_LH, DELAY(2NS,-1,12NS),
+       TRN_HL, DELAY(2NS,-1,10NS),
+       DELAY(6NS,-1,22NS))}

.ENDS 74ALS1242A

*------------------------------------------------------------74F1242-----

* Quad Transceiver, Inverting (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 842 to 846
* jat 7/30/96

.SUBCKT 74F1242 A0 A1 A2 A3 B0 B1 B2 B3 OEABAR OEB
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(8,8) DPWR DGND
+ A0 A1 A2 A3 B0 B1 B2 B3
+ B0O B1O B2O B3O A0O A1O A2O A3O
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   B0O = {~A0}
+   B1O = {~A1}
+   B2O = {~A2}
+   B3O = {~A3}
+   A0O = {~B0}
+   A1O = {~B1}
+   A2O = {~B2}
+   A3O = {~B3}

U2 PINDLY(8,2,0) DPWR DGND
+ A0O A1O A2O A3O B0O B1O B2O B3O
+ OEABAR OEB
+ A0 A1 A2 A3 B0 B1 B2 B3
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = OEB
+   A0 A1 A2 A3 = {
+     CASE(
+       TRN_ZH, DELAY(3.5NS,5.5NS,7.5NS),
+       TRN_ZL, DELAY(3NS,5.5NS,7.5NS),
+       TRN_HZ, DELAY(3.5NS,6NS,8NS),
+       TRN_LZ, DELAY(3NS,5NS,7.5NS),
+       TRN_LH, DELAY(3NS,4.5NS,6NS),
+       TRN_HL, DELAY(1.5NS,2.5NS,4NS),
+       DELAY(4.5NS,6NS,9NS))}
+ TRISTATE:
+ ENABLE LO = OEABAR
+   B0 B1 B2 B3 = {
+     CASE(
+       TRN_ZH, DELAY(3.5NS,5.5NS,7.5NS),
+       TRN_ZL, DELAY(3NS,5.5NS,7.5NS),
+       TRN_HZ, DELAY(3.5NS,6NS,8NS),
+       TRN_LZ, DELAY(3NS,5NS,7.5NS),
+       TRN_LH, DELAY(3NS,4.5NS,6NS),
+       TRN_HL, DELAY(1.5NS,2.5NS,4NS),
+       DELAY(4.5NS,6NS,9NS))}

.ENDS 74F1242

*------------------------------------------------------------74ALS1243A-----

* Quad Bidirectional Bus Driver
* National ALS/AS Logic Databook, 1990, pages 2-292 to 2-295
* jat 8/21/96

.SUBCKT 74ALS1243A A1 A2 A3 A4 B1 B2 B3 B4 GBA GABBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(8,2,0) DPWR DGND
+ A1 A2 A3 A4 B1 B2 B3 B4
+ GBA GABBAR
+ B1 B2 B3 B4 A1 A2 A3 A4
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = GBA
+   A1 A2 A3 A4 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,21NS),
+       TRN_ZL, DELAY(6NS,-1,21NS),
+       TRN_HZ, DELAY(2NS,-1,11NS),
+       TRN_LZ, DELAY(2NS,-1,16NS),
+       TRN_LH, DELAY(2NS,-1,11NS),
+       TRN_HL, DELAY(2NS,-1,12NS),
+       DELAY(6NS,-1,22NS))}
+ TRISTATE:
+ ENABLE LO = GABBAR
+   B1 B2 B3 B4 = {
+     CASE(
+       TRN_ZH, DELAY(4NS,-1,21NS),
+       TRN_ZL, DELAY(5NS,-1,21NS),
+       TRN_HZ, DELAY(2NS,-1,8NS),
+       TRN_LZ, DELAY(2NS,-1,12NS),
+       TRN_LH, DELAY(2NS,-1,11NS),
+       TRN_HL, DELAY(2NS,-1,12NS),
+       DELAY(6NS,-1,22NS))}

.ENDS 74ALS1243A

*------------------------------------------------------------74F1243-----

* Quad Transceiver (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 842 to 846
* jat 7/30/96

.SUBCKT 74F1243 A0 A1 A2 A3 B0 B1 B2 B3 OEABAR OEB
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(8,2,0) DPWR DGND
+ B0 B1 B2 B3 A0 A1 A2 A3
+ OEABAR OEB
+ A0 A1 A2 A3 B0 B1 B2 B3
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = OEB
+   A0 A1 A2 A3 = {
+     CASE(
+       TRN_ZH, DELAY(2.5NS,5.5NS,8NS),
+       TRN_ZL, DELAY(2.5NS,5NS,7.5NS),
+       TRN_HZ, DELAY(3.5NS,6.5NS,8.5NS),
+       TRN_LZ, DELAY(2NS,5NS,7.5NS),
+       TRN_LH, DELAY(2NS,4NS,5.5NS),
+       TRN_HL, DELAY(3NS,5NS,6.5NS),
+       DELAY(4.5NS,7.5NS,9.5NS))}
+ TRISTATE:
+ ENABLE LO = OEABAR
+   B0 B1 B2 B3 = {
+     CASE(
+       TRN_ZH, DELAY(2.5NS,5.5NS,8NS),
+       TRN_ZL, DELAY(2.5NS,5NS,7.5NS),
+       TRN_HZ, DELAY(3.5NS,6.5NS,8.5NS),
+       TRN_LZ, DELAY(2NS,5NS,7.5NS),
+       TRN_LH, DELAY(2NS,4NS,5.5NS),
+       TRN_HL, DELAY(3NS,5NS,6.5NS),
+       DELAY(4.5NS,7.5NS,9.5NS))}

.ENDS 74F1243

* ----------------------------------------------------------- 74ALS1244A ------
*  Octal Buffer And Driver With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-881 to 2-883
*  bss    6/27/94
*
.SUBCKT 74ALS1244A 1GBAR 1A1 1A2 1A3 1A4 1Y1 1Y2 1Y3 1Y4 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     1GBAR 1G
+     D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 buf3a(4) DPWR DGND
+     1A1 1A2 1A3 1A4
+     1G
+     1Y1 1Y2 1Y3 1Y4
+     DLY_ALS1244 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1244 utgate (tplhMN=3ns tplhMX=14ns tphlMN=3ns tphlMX=14ns
+                                 tpzhMN=6ns tpzhMX=22ns tpzlMN=6ns tpzlMX=22ns
+                                 tphzMN=2ns tphzMX=10ns tplzMN=3ns tplzMX=13ns)

.ENDS 74ALS1244A

*------------------------------------------------------------74F1244-----

* Octal Buffer (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 847 to 850
* jat 7/30/96

.SUBCKT 74F1244 I0 I1 I2 I3 OEBAR Y0 Y1 Y2 Y3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(4,1,0) DPWR DGND
+ I0 I1 I2 I3
+ OEBAR
+ Y0 Y1 Y2 Y3
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE LO = OEBAR
+   Y0 Y1 Y2 Y3 = {
+     CASE(
+       TRN_ZH, DELAY(3NS,6NS,7.5NS),
+       TRN_ZL, DELAY(3NS,6.5NS,8NS),
+       TRN_HZ, DELAY(2NS,4NS,5.5NS),
+       TRN_LZ, DELAY(2NS,4NS,5.5NS),
+       TRN_LH, DELAY(2.5NS,4NS,5.5NS),
+       TRN_HL, DELAY(2NS,5NS,7NS),
+       DELAY(4NS,7NS,9NS))}

.ENDS 74F1244

* ----------------------------------------------------------- 74ALS1245A ------
*  Octal Bus Transceivers With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-885 to 2-887
*  bss    6/27/94
*
.SUBCKT 74ALS1245A GBAR DIR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1LOG LOGICEXP(2,2) DPWR DGND
+     GBAR DIR
+     ENAB ENBA
+     D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  LOGIC:
+     gen = {~GBAR}
+     dirbar = {~DIR}
+     ENAB = {gen & DIR}
+     ENBA = {gen & dirbar}

U2 buf3a(8) DPWR DGND
+     A1 A2 A3 A4 A5 A6 A7 A8
+     ENAB
+     B1 B2 B3 B4 B5 B6 B7 B8
+     DLY_ALS1245 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 buf3a(8) DPWR DGND
+     B1 B2 B3 B4 B5 B6 B7 B8
+     ENBA
+     A1 A2 A3 A4 A5 A6 A7 A8
+     DLY_ALS1245 IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS1245 utgate (tplhMN=2ns tplhMX=13ns tphlMN=2ns tphlMX=13ns
+                                 tpzhMN=8ns tpzhMX=25ns tpzlMN=8ns tpzlMX=25ns
+                                 tphzMN=2ns tphzMX=12ns tplzMN=3ns tplzMX=18ns)

.ENDS 74ALS1245A

*------------------------------------------------------------74F1245-----

* Octal Transceiver (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 851 to 854
* jat 7/31/96

.SUBCKT 74F1245 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 OEBAR T/RBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,2) DPWR DGND
+ T/RBAR OEBAR
+ AB BA
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   AB = {T/RBAR & ~OEBAR}
+   BA = {~T/RBAR & ~OEBAR}

U2 PINDLY(16,2,0) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ AB BA
+ B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7 
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = BA
+   A0 A1 A2 A3 A4 A5 A6 A7 = {
+     CASE(
+       TRN_ZH, DELAY(3NS,6NS,8NS),
+       TRN_ZL, DELAY(4NS,7.5NS,10NS),
+       TRN_HZ, DELAY(2NS,5NS,8NS),
+       TRN_LZ, DELAY(4NS,7NS,10NS),
+       TRN_LH, DELAY(2NS,4NS,6.5NS),
+       TRN_HL, DELAY(2.5NS,5NS,7.5NS),
+       DELAY(5NS,8.5NS,11NS))}
+ TRISTATE:
+ ENABLE HI = AB
+   B0 B1 B2 B3 B4 B5 B6 B7 = {
+     CASE(
+       TRN_ZH, DELAY(3NS,6NS,8NS),
+       TRN_ZL, DELAY(4NS,7.5NS,10NS),
+       TRN_HZ, DELAY(2NS,5NS,8NS),
+       TRN_LZ, DELAY(4NS,7NS,10NS),
+       TRN_LH, DELAY(2NS,4NS,6.5NS),
+       TRN_HL, DELAY(2.5NS,5NS,7.5NS),
+       DELAY(5NS,8.5NS,11NS))}

.ENDS 74F1245

*------------------------------------------------------------74F1604-----

* Latch
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 855 to 859
* jat 7/31/96

.SUBCKT 74F1604 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 
+ LEBAR A/BBAR Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(18,9) DPWR DGND
+ LEBAR A/BBAR QA0 QA1 QA2 QA3 QA4 QA5 QA6 QA7 QB0 QB1 QB2 QB3 QB4 QB5 QB6
+ QB7
+ LE Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LE = {~LEBAR}
+   Q0O = {(QA0 & A/BBAR) | (QB0 & ~A/BBAR)}
+   Q1O = {(QA1 & A/BBAR) | (QB1 & ~A/BBAR)}
+   Q2O = {(QA2 & A/BBAR) | (QB2 & ~A/BBAR)}
+   Q3O = {(QA3 & A/BBAR) | (QB3 & ~A/BBAR)}
+   Q4O = {(QA4 & A/BBAR) | (QB4 & ~A/BBAR)}
+   Q5O = {(QA5 & A/BBAR) | (QB5 & ~A/BBAR)}
+   Q6O = {(QA6 & A/BBAR) | (QB6 & ~A/BBAR)}
+   Q7O = {(QA7 & A/BBAR) | (QB7 & ~A/BBAR)}

U2 DLTCH(16) DPWR DGND
+ $D_HI $D_HI LE
+ A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ QA0 QA1 QA2 QA3 QA4 QA5 QA6 QA7 QB0 QB1 QB2 QB3 QB4 QB5 QB6 QB7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC
+ D0_GFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,0,18) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O
+ LEBAR A/BBAR A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED_HL(LEBAR,0)}
+   SEL = {CHANGED(A/BBAR,0)}
+   DATA = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) |
+           CHANGED(A4,0) | CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) |
+           CHANGED(B0,0) | CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) |
+           CHANGED(B4,0) | CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0)}
+ PINDLY:
+   Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 = {
+     CASE(
+       LATCH & TRN_LH, DELAY(6.5NS,9.5NS,13NS),
+       LATCH & TRN_HL, DELAY(6NS,9NS,12.5NS),
+       SEL & TRN_LH, DELAY(3NS,5.5NS,8.5NS),
+       SEL & TRN_HL, DELAY(3.5NS,6.5NS,10NS),
+       DATA & TRN_LH, DELAY(4NS,6.5NS,9.5NS),
+       DATA & TRN_HL, DELAY(4NS,7NS,10.5NS),
+       DELAY(7.5NS,10.5NS,14NS))}

U4 CONSTRAINT(17) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 LEBAR
+ IO_F IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+   CLOCK LH = LEBAR
+   DATA(16) = A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+   SETUPTIME_LO = 1NS
+   HOLDTIME_HI = 1.5NS
+   HOLDTIME_LO = 3NS
+ WIDTH:
+   NODE = LEBAR
+   MIN_LO = 6.5NS

.ENDS 74F1604

*-------------------------------------------------------------74ALS1640A---

* Octal Bus Transceivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-889 to 2-892
* jat 3/27/96

.SUBCKT 74ALS1640A
+ DIR GBAR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(18,18) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 GBAR DIR
+ A1O A2O A3O A4O A5O A6O A7O A8O B1O B2O B3O B4O B5O B6O B7O B8O ENABAB ENABBA
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABAB = {~GBAR & DIR}
+   ENABBA = {~GBAR & ~DIR}
+   B1O = {~A1}
+   B2O = {~A2}
+   B3O = {~A3}
+   B4O = {~A4}
+   B5O = {~A5}
+   B6O = {~A6}
+   B7O = {~A7}
+   B8O = {~A8}
+   A1O = {~B1}
+   A2O = {~B2}
+   A3O = {~B3}
+   A4O = {~B4}
+   A5O = {~B5}
+   A6O = {~B6}
+   A7O = {~B7}
+   A8O = {~B8}

U2 PINDLY(16,2,16) DPWR DGND
+ A1O A2O A3O A4O A5O A6O A7O A8O B1O B2O B3O B4O B5O B6O B7O B8O
+ ENABAB ENABBA
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATAA = {CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+            CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0)}
+   DATAB = {CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) |
+            CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0)}
+ TRISTATE:
+   ENABLE HI = ENABAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,20NS),
+       TRN_ZL, DELAY(5NS,-1,22NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(5NS,-1,13NS),
+       DATAA & TRN_LH, DELAY(5NS,-1,15NS),
+       DATAA & TRN_HL, DELAY(2NS,-1,10NS),
+       DELAY(6NS,-1,23NS))}
+ TRISTATE:
+   ENABLE HI = ENABBA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,20NS),
+       TRN_ZL, DELAY(5NS,-1,22NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(5NS,-1,13NS),
+       DATAB & TRN_LH, DELAY(5NS,-1,15NS),
+       DATAB & TRN_HL, DELAY(2NS,-1,10NS),
+       DELAY(6NS,-1,23NS))}

.ENDS 74ALS1640A

*-------------------------------------------------------------74ALS1645A---

* Octal Bus Transceivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-889 to 2-892
* jat 3/27/96

.SUBCKT 74ALS1645A
+ DIR GBAR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(18,18) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8 GBAR DIR
+ A1O A2O A3O A4O A5O A6O A7O A8O B1O B2O B3O B4O B5O B6O B7O B8O ENABAB ENABBA
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABAB = {~GBAR & DIR}
+   ENABBA = {~GBAR & ~DIR}
+   B1O = {A1}
+   B2O = {A2}
+   B3O = {A3}
+   B4O = {A4}
+   B5O = {A5}
+   B6O = {A6}
+   B7O = {A7}
+   B8O = {A8}
+   A1O = {B1}
+   A2O = {B2}
+   A3O = {B3}
+   A4O = {B4}
+   A5O = {B5}
+   A6O = {B6}
+   A7O = {B7}
+   A8O = {B8}

U2 PINDLY(16,2,16) DPWR DGND
+ A1O A2O A3O A4O A5O A6O A7O A8O B1O B2O B3O B4O B5O B6O B7O B8O
+ ENABAB ENABBA
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATAA = {CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) | CHANGED(A4,0) |
+            CHANGED(A5,0) | CHANGED(A6,0) | CHANGED(A7,0) | CHANGED(A8,0)}
+   DATAB = {CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) | CHANGED(B4,0) |
+            CHANGED(B5,0) | CHANGED(B6,0) | CHANGED(B7,0) | CHANGED(B8,0)}
+ TRISTATE:
+   ENABLE HI = ENABAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+     CASE(
+       TRN_ZH, DELAY(8NS,-1,25NS),
+       TRN_ZL, DELAY(8NS,-1,25NS),
+       TRN_HZ, DELAY(2NS,-1,12NS),
+       TRN_LZ, DELAY(3NS,-1,18NS),
+       DATAA & TRN_LH, DELAY(2NS,-1,13NS),
+       DATAA & TRN_HL, DELAY(2NS,-1,13NS),
+       DELAY(9NS,-1,26NS))}
+ TRISTATE:
+   ENABLE HI = ENABBA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+     CASE(
+       TRN_ZH, DELAY(8NS,-1,25NS),
+       TRN_ZL, DELAY(8NS,-1,25NS),
+       TRN_HZ, DELAY(2NS,-1,12NS),
+       TRN_LZ, DELAY(3NS,-1,18NS),
+       DATAA & TRN_LH, DELAY(2NS,-1,13NS),
+       DATAA & TRN_HL, DELAY(2NS,-1,13NS),
+       DELAY(9NS,-1,26NS))}

.ENDS 74ALS1645A

*----------------------------------------------------------74F1762-------

* Memory Address Multiplexer
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 860 to 866
* jat 7/31/96

.SUBCKT 74F1762 RA0 RA1 RA2 RA3 RA4 RA5 RA6 RA7 RA8 RA9 RA10 CA0 CA1 CA2
+ CA3 CA4 CA5 CA6 CA7 CA8 CA9 CA10 COUNT MR MUX REFENBAR MA0BAR MA1BAR
+ MA2BAR MA3BAR MA4BAR MA5BAR MA6BAR MA7BAR MA8BAR MA9BAR MA10BAR
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(37,13) DPWR DGND
+ MR COUNT RA0 RA1 RA2 RA3 RA4 RA5 RA6 RA7 RA8 RA9 RA10 CA0 CA1 CA2 CA3 CA4
+ CA5 CA6 CA7 CA8 CA9 CA10 MUX REFENBAR Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR 
+ Q5BAR Q6BAR Q7BAR Q8BAR Q9BAR Q10BAR
+ MRBAR COUNTBAR MA0BARO MA1BARO MA2BARO MA3BARO MA4BARO MA5BARO MA6BARO
+ MA7BARO MA8BARO MA9BARO MA10BARO 
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MRBAR = {~MR}
+   COUNTBAR = {~COUNT}
+   MA0BARO = {~((RA0 & ~MUX & REFENBAR) | (CA0 & MUX & REFENBAR) | (Q0BAR & ~REFENBAR))}
+   MA1BARO = {~((RA1 & ~MUX & REFENBAR) | (CA1 & MUX & REFENBAR) | (Q1BAR & ~REFENBAR))}
+   MA2BARO = {~((RA2 & ~MUX & REFENBAR) | (CA2 & MUX & REFENBAR) | (Q2BAR & ~REFENBAR))}
+   MA3BARO = {~((RA3 & ~MUX & REFENBAR) | (CA3 & MUX & REFENBAR) | (Q3BAR & ~REFENBAR))}
+   MA4BARO = {~((RA4 & ~MUX & REFENBAR) | (CA4 & MUX & REFENBAR) | (Q4BAR & ~REFENBAR))}
+   MA5BARO = {~((RA5 & ~MUX & REFENBAR) | (CA5 & MUX & REFENBAR) | (Q5BAR & ~REFENBAR))}
+   MA6BARO = {~((RA6 & ~MUX & REFENBAR) | (CA6 & MUX & REFENBAR) | (Q6BAR & ~REFENBAR))}
+   MA7BARO = {~((RA7 & ~MUX & REFENBAR) | (CA7 & MUX & REFENBAR) | (Q7BAR & ~REFENBAR))}
+   MA8BARO = {~((RA8 & ~MUX & REFENBAR) | (CA8 & MUX & REFENBAR) | (Q8BAR & ~REFENBAR))}
+   MA9BARO = {~((RA9 & ~MUX & REFENBAR) | (CA9 & MUX & REFENBAR) | (Q9BAR & ~REFENBAR))}
+   MA10BARO = {~((RA10 & ~MUX & REFENBAR) | (CA10 & MUX & REFENBAR) | (Q10BAR & ~REFENBAR))}

U2 JKFF(1) DPWR DGND
+ $D_HI MRBAR COUNTBAR
+ $D_HI $D_HI Q0 Q0BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q0
+ $D_HI $D_HI Q1 Q1BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q1
+ $D_HI $D_HI Q2 Q2BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q2
+ $D_HI $D_HI Q3 Q3BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q3
+ $D_HI $D_HI Q4 Q4BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q4
+ $D_HI $D_HI Q5 Q5BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q5
+ $D_HI $D_HI Q6 Q6BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q6
+ $D_HI $D_HI Q7 Q7BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q7
+ $D_HI $D_HI Q8 Q8BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q8
+ $D_HI $D_HI Q9 Q9BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+ $D_HI MRBAR Q9
+ $D_HI $D_HI Q10 Q10BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 PINDLY(11,0,26) DPWR DGND
+ MA0BARO MA1BARO MA2BARO MA3BARO MA4BARO MA5BARO MA6BARO MA7BARO MA8BARO
+ MA9BARO MA10BARO
+ MR COUNT REFENBAR MUX RA0 RA1 RA2 RA3 RA4 RA5 RA6 RA7 RA8 RA9 RA10 CA0 CA1
+ CA2 CA3 CA4 CA5 CA6 CA7 CA8 CA9 CA10
+ MA0BAR MA1BAR MA2BAR MA3BAR MA4BAR MA5BAR MA6BAR MA7BAR MA8BAR MA9BAR MA10BAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(RA0,0) | CHANGED(RA1,0) | CHANGED(RA2,0) | CHANGED(RA3,0) |
+            CHANGED(RA4,0) | CHANGED(RA5,0) | CHANGED(RA6,0) | CHANGED(RA7,0) |
+            CHANGED(RA8,0) | CHANGED(RA9,0) | CHANGED(RA10,0) | CHANGED(CA0,0) |
+            CHANGED(CA1,0) | CHANGED(CA2,0) | CHANGED(CA3,0) | CHANGED(CA4,0) |
+            CHANGED(CA5,0) | CHANGED(CA6,0) | CHANGED(CA7,0) | CHANGED(CA8,0) |
+            CHANGED(CA9,0) | CHANGED(CA10,0)}
+    MUXUP = {CHANGED_LH(MUX,0)}
+    MUXDOWN = {CHANGED_HL(MUX,0)}
+    REFUP = {CHANGED_LH(REFENBAR,0)}
+    REFDOWN = {CHANGED_HL(REFENBAR,0)}
+    EDGE = {CHANGED_LH(COUNT,0)}
+    CLEAR = {CHANGED_LH(MR,0)}
+ PINDLY:
+    MA0BAR MA1BAR MA2BAR MA3BAR MA4BAR MA5BAR MA6BAR MA7BAR MA8BAR MA9BAR MA10BAR = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(3NS,5.8NS,10.5NS),
+        REFUP & TRN_LH, DELAY(2NS,4.3NS,7.5NS),
+        REFUP & TRN_HL, DELAY(2NS,4.5NS,8NS),
+        REFDOWN & TRN_LH, DELAY(4NS,6.9NS,10.5NS),
+        REFDOWN & TRN_HL, DELAY(2NS,4.7NS,7.5NS),
+        MUXUP & TRN_LH, DELAY(2NS,4.5NS,7.5NS),
+        MUXUP & TRN_HL, DELAY(2.5NS,5NS,8NS),
+        MUXDOWN & TRN_LH, DELAY(4NS,6.5NS,9.5NS),
+        MUXDOWN & TRN_HL, DELAY(2NS,4.5NS,7.5NS),
+        EDGE & (TRN_LH | TRN_HL), DELAY(2NS,15NS,35NS),
+        DATA & TRN_LH, DELAY(1NS,3NS,6NS),
+        DATA & TRN_HL, DELAY(.5NS,2.2NS,5NS),
+        DELAY(5NS,16NS,36NS))}

U14 CONSTRAINT(2) DPWR DGND
+ COUNT MR
+ IO_F IO_LEVEL={IO_LEVEL}
+ WIDTH:
+   NODE = COUNT
+   MIN_HI = 5NS
+   MIN_LO = 5NS
+ WIDTH:
+   NODE = MR
+   MIN_HI = 5NS
+ SETUP_HOLD:
+   CLOCK LH = COUNT
+   DATA(1) = MR
+   SETUPTIME_LO = 5NS

.ENDS 74F1762

*---------------------------------------------------------74F1779------

* 8 Bit Bidirectional Binary Counter with Tri-State Outputs
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 916 to 921
* jat 7/31/96

.SUBCKT 74F1779 I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 CP CETBAR OEBAR S0 S1
+ TCBAR
+ OPTIONAL: DPWR=$D_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(27,9) DPWR DGND
+ S0 S1 I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 CETBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+ D0 D1 D2 D3 D4 D5 D6 D7 TCBARO
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LOAD = {~S0 & ~S1}
+   UP = {~S0 & S1}
+   DOWN = {S0 & ~S1}
+   TOG0 = {CETBAR}
+   ANDUP1 = {~CETBAR & UP & Q0}
+   ANDDOWN1 = {~CETBAR & DOWN & Q0BAR}
+   TOG1 = {~(ANDUP1 | ANDDOWN1)}
+   ANDUP2 = {ANDUP1 & Q1}
+   ANDDOWN2 = {ANDDOWN1 & Q1BAR}
+   TOG2 = {~(ANDUP2 | ANDDOWN2)}
+   ANDUP3 = {ANDUP2 & Q2}
+   ANDDOWN3 = {ANDDOWN2 & Q2BAR}
+   TOG3 = {~(ANDUP3 | ANDDOWN3)}
+   ANDUP4 = {ANDUP3 & Q3}
+   ANDDOWN4 = {ANDDOWN3 & Q3BAR}
+   TOG4 = {~(ANDUP4 | ANDDOWN4)}
+   ANDUP5 = {ANDUP4 & Q4}
+   ANDDOWN5 = {ANDDOWN4 & Q4BAR}
+   TOG5 = {~(ANDUP5 | ANDDOWN5)}
+   ANDUP6 = {ANDUP5 & Q5}
+   ANDDOWN6 = {ANDDOWN5 & Q5BAR}
+   TOG6 = {~(ANDUP6 | ANDDOWN6)}
+   ANDUP7 = {ANDUP6 & Q6}
+   ANDDOWN7 = {ANDDOWN6 & Q6BAR}
+   TOG7 = {~(ANDUP7 | ANDDOWN7)}
+   TCBARO = {~((~CETBAR & DOWN & Q0BAR & Q1BAR & Q2BAR & Q3BAR & Q4BAR & Q5BAR & Q6BAR & Q7BAR) | 
+               (~CETBAR &  UP & Q0 & Q1 & Q2 & Q3 & Q4 & Q5 & Q6 & Q7))}
+   D0 = {(S0 & S1 & Q0) | ((~(S0 & S1)) & ((I/O0 & LOAD) | (TOG0 & ~LOAD & Q0) | (~LOAD & ~TOG0 & Q0BAR)))}
+   D1 = {(I/O1 & LOAD) | (TOG1 & ~LOAD & Q1) | (~LOAD & ~TOG1 & Q1BAR)}
+   D2 = {(I/O2 & LOAD) | (TOG2 & ~LOAD & Q2) | (~LOAD & ~TOG2 & Q2BAR)}
+   D3 = {(I/O3 & LOAD) | (TOG3 & ~LOAD & Q3) | (~LOAD & ~TOG3 & Q3BAR)}
+   D4 = {(I/O4 & LOAD) | (TOG4 & ~LOAD & Q4) | (~LOAD & ~TOG4 & Q4BAR)}
+   D5 = {(I/O5 & LOAD) | (TOG5 & ~LOAD & Q5) | (~LOAD & ~TOG5 & Q5BAR)}
+   D6 = {(I/O6 & LOAD) | (TOG6 & ~LOAD & Q6) | (~LOAD & ~TOG6 & Q6BAR)}
+   D7 = {(I/O7 & LOAD) | (TOG7 & ~LOAD & Q7) | (~LOAD & ~TOG7 & Q7BAR)}

U2 DFF(8) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3 D4 D5 D6 D7
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+ D0_EFF IO_F MNTYMXDLY={MNYTMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(9,1,10) DPWR DGND
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 TCBARO
+ OEBAR
+ CP I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 CETBAR
+ I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 TCBAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CET = {CHANGED(CETBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ TRISTATE:
+   ENABLE LO = OEBAR
+   I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 = {
+     CASE(
+       TRN_ZH, DELAY(2NS,4NS,6.5NS),
+       TRN_ZL, DELAY(4.5NS,6.5NS,9NS),
+       TRN_HZ, DELAY(1NS,3NS,6NS),
+       TRN_LZ, DELAY(1NS,4NS,7NS),
+       EDGE & TRN_LH, DELAY(4NS,6.5NS,10NS),
+       EDGE & TRN_HL, DELAY(5NS,7NS,10.5NS),
+       DELAY(6NS,8NS,11.5NS))}
+ PINDLY:
+  TCBAR = {
+     CASE(
+       CET & TRN_LH, DELAY(2NS,4NS,6.5NS),
+       CET & TRN_HL, DELAY(2.5NS,4.5NS,7NS),
+       EDGE & TRN_LH, DELAY(4NS,6.5NS,9NS),
+       EDGE & TRN_HL, DELAY(4.5NS,6.5NS,9NS),
+       DELAY(5.5NS,7.5NS,10NS))}

U4 CONSTRAINT(12) DPWR DGND
+ I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7 CP S0 S1 CETBAR
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 130MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 3NS
+   MIN_LO = 4.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(8) = I/O0 I/O1 I/O2 I/O3 I/O4 I/O5 I/O6 I/O7
+   SETUPTIME_HI = 4NS
+   SETUPTIME_LO = 3.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = CETBAR
+   SETUPTIME_HI = 4.5NS
+   SETUPTIME_LO = 7NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(2) = S0 S1
+   SETUPTIME_HI = 7.5NS
+   SETUPTIME_LO = 8.5NS

.ENDS 74F1779

*-------------------------------------------------------------74F1803-----

* Clock Driver (Quad D-Type Flip Flop) with matched propagation delays
* Motorola FAST and LS TTL Data, 1992, pages 4-272 to 4-275
* jat 7/31/96

.SUBCKT 74F1803 CP D0 D1 D2 D3 O0BAR O1BAR O2BAR O3BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3
+ $D_NC $D_NC $D_NC $D_NC
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,0,0) DPWR DGND
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ O0BAR O1BAR O2BAR O3BAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   O0BAR O1BAR O2BAR O3BAR = {
+      CASE(
+        (TRN_LH | TRN_HL), DELAY(3NS,-1,7.5NS),
+        DELAY(4NS,-1,8.5NS))}

U3 CONSTRAINT(5) DPWR DGND
+ D0 D1 D2 D3 CP
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 70MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 7NS
+  MIN_LO = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 3NS
+  HOLDTIME = 4NS

.ENDS 74F1803

*-------------------------------------------------------------74ALS1804A----

* Hex 2-Input NAND Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-893 to 2-895
* jat 3/27/96

.SUBCKT 74ALS1804A
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {~(1A & 1B)}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH | TRN_HL, DELAY(-1,4NS,-1),
+       DELAY(-1,5NS,-1))}

.ENDS 74ALS1804A

*-------------------------------------------------------------74AS1804----

* Hex 2-Input NAND Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-893 to 2-895
* jat 3/27/96

.SUBCKT 74AS1804
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {~(1A & 1B)}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH | TRN_HL, DELAY(1NS,-1,4NS),
+       DELAY(2NS,-1,5NS))}

.ENDS 74AS1804

*------------------------------------------------------------74F1804----

* Hex 2-Input NAND Drivers
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 770 to 773
* jat 7/25/96

.SUBCKT 74F1804 D0A D0B Q0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 NAND(2) DPWR DGND
+ D0A D0B Q0BAR
+ DLY_F1804 IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F1804 UGATE (TPLHMN=1NS TPLHTY=2NS TPLHMX=4NS
+                      TPHLMN=1NS TPHLTY=3NS TPHLMX=4.5NS)

.ENDS 74F1804

*-------------------------------------------------------------74ALS1805A----

* Hex 2-Input NOR Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-897 to 2-899
* jat 3/27/96

.SUBCKT 74ALS1805A
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {~(1A | 1B)}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH, DELAY(-1,4NS,-1),
+       TRN_HL, DELAY(-1,5NS,-1),
+       DELAY(-1,6NS,-1))}

.ENDS 74ALS1805A

*-------------------------------------------------------------74AS1805----

* Hex 2-Input NOR Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-897 to 2-899
* jat 3/27/96

.SUBCKT 74AS1805
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {~(1A | 1B)}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH | TRN_HL, DELAY(1NS,-1,4.3NS),
+       DELAY(2NS,-1,5.3NS))}

.ENDS 74AS1805

*------------------------------------------------------------74F1805----

* Hex 2-Input NOR Drivers
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 774 to 777
* jat 7/25/96

.SUBCKT 74F1805 D0A D0B Q0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 NOR(2) DPWR DGND
+ D0A D0B Q0BAR
+ DLY_F1805 IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F1805 UGATE (TPLHMN=1NS TPLHTY=2NS TPLHMX=4NS
+                      TPHLMN=1NS TPHLTY=2.5NS TPHLMX=4.5NS)

.ENDS 74F1805

*-------------------------------------------------------------74ALS1808A----

* Hex 2-Input AND Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-901 to 2-903
* jat 3/27/96

.SUBCKT 74ALS1808A
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {1A & 1B}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH, DELAY(-1,6NS,-1),
+       TRN_HL, DELAY(-1,4NS,-1),
+       DELAY(-1,7NS,-1))}

.ENDS 74ALS1808A

*-------------------------------------------------------------74AS1808----

* Hex 2-Input AND Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-901 to 2-903
* jat 3/27/96

.SUBCKT 74AS1808
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {1A & 1B}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH | TRN_HL, DELAY(1NS,-1,6NS),
+       DELAY(2NS,-1,7NS))}

.ENDS 74AS1808

*-------------------------------------------------------------74F1808----

* Hex 2-Input AND Drivers
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 786 to 789
* jat 7/25/96

.SUBCKT 74F1808
+ D0A D0B Q0
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ D0A D0B Q0O
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   Q0O = {D0A & D0B}

U2 PINDLY(1,0,0) DPWR DGND
+ Q0O
+ Q0
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    Q0 = {
+      CASE(
+       TRN_LH, DELAY(2NS,4.5NS,6.3NS),
+       TRN_HL, DELAY(2NS,3.5NS,6NS),
+       DELAY(3NS,5.5NS,7.3NS))}

.ENDS 74F1808

*-------------------------------------------------------------74ALS1832A----

* Hex 2-Input OR Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-905 to 2-907
* jat 3/27/96

.SUBCKT 74ALS1832A
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {1A | 1B}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH, DELAY(-1,6NS,-1),
+       TRN_HL, DELAY(-1,4NS,-1),
+       DELAY(-1,7NS,-1))}

.ENDS 74ALS1832A

*-------------------------------------------------------------74AS1832----

* Hex 2-Input OR Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-905 to 2-907
* jat 3/27/96

.SUBCKT 74AS1832
+ 1A 1B 1Y
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1YO
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {1A | 1B}

U2 PINDLY(1,0,0) DPWR DGND
+ 1YO
+ 1Y
+ IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+    1Y = {
+      CASE(
+       TRN_LH | TRN_HL, DELAY(1NS,-1,6.3NS),
+       DELAY(2NS,-1,7.3NS))}

.ENDS 74AS1832

*------------------------------------------------------------74F1832----

* Hex 2-Input NOR Drivers
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 808 to 811
* jat 7/25/96

.SUBCKT 74F1832 D0A D0B Q0
+ OPTIONAL: DPWR=$G_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(2) DPWR DGND
+ D0A D0B Q0
+ DLY_F1832 IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F1832 UGATE (TPLHMN=2NS TPLHTY=4NS TPLHMX=6NS
+                      TPHLMN=2NS TPHLTY=3.5NS TPHLMX=6NS)

.ENDS 74F1832

*------------------------------------------------------------74ALS2240----

* Octal Buffers and Line Drivers/MOS Drivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-909 to 2-911
* jat 3/28/96

.SUBCKT 74ALS2240
+ GBAR A1 A2 A3 A4 Y1 Y2 Y3 Y4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(4) DPWR DGND
+ A1 A2 A3 A4 A1BAR A2BAR A3BAR A4BAR
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,0) DPWR DGND
+ A1BAR A2BAR A3BAR A4BAR
+ GBAR
+ Y1 Y2 Y3 Y4
+ IO_ALS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE LO = GBAR
+   Y1 Y2 Y3 Y4 = {
+      CASE(
+        TRN_ZH, DELAY(-1,10NS,-1),
+        TRN_ZL, DELAY(-1,12NS,-1),
+        TRN_HZ, DELAY(-1,7NS,-1),
+        TRN_LZ, DELAY(-1,9NS,-1),
+        TRN_LH | TRN_HL, DELAY(-1,6NS,-1),
+        DELAY(-1,13NS,-1))}

.ENDS 74ALS2240

*------------------------------------------------------------74F2240----

* Octal Inverter Buffer with 30-Ohm equivalent output termination (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 922 to 926
* jat 7/31/96

.SUBCKT 74F2240
+ OEBAR I0 I1 I2 I3 Y0 Y1 Y2 Y3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(4) DPWR DGND
+ I0 I1 I2 I3 Y0O Y1O Y2O Y3O
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(4,1,0) DPWR DGND
+ Y0O Y1O Y2O Y3O
+ OEBAR
+ Y0 Y1 Y2 Y3
+ IO_F_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE LO = OEBAR
+   Y0 Y1 Y2 Y3 = {
+      CASE(
+        TRN_ZH, DELAY(3NS,4.5NS,7NS),
+        TRN_ZL, DELAY(3.5NS,5NS,8NS),
+        TRN_HZ, DELAY(2NS,3.5NS,6.5NS),
+        TRN_LZ, DELAY(1NS,2.5NS,5.5NS),
+        TRN_LH, DELAY(3NS,5NS,7NS),
+        TRN_HL, DELAY(2NS,3.5NS,5.5NS),
+        DELAY(4.5NS,6NS,9NS))}

.ENDS 74F2240

*------------------------------------------------------------74F2241----

* Octal Buffer with 30-Ohm equivalent output termination (Tri-State)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 922 to 926
* jat 7/31/96

.SUBCKT 74F2241
+ OEABAR IA0 IA1 IA2 IA3 YA0 YA1 YA2 YA3 IB0 IB1 IB2 IB3 YB0 YB1 YB2 YB3 OEB
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(8,2,0) DPWR DGND
+ IA0 IA1 IA2 IA3 IB0 IB1 IB2 IB3
+ OEABAR OEB
+ YA0 YA1 YA2 YA3 YB0 YB1 YB2 YB3
+ IO_F_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE LO = OEABAR
+   YA0 YA1 YA2 YA3 = {
+      CASE(
+        TRN_ZH, DELAY(3NS,5NS,7NS),
+        TRN_ZL, DELAY(3.5NS,5.5NS,7.5NS),
+        TRN_HZ, DELAY(2NS,4NS,6NS),
+        TRN_LZ, DELAY(1.5NS,3.5NS,6NS),
+        TRN_LH, DELAY(3NS,4.5NS,7NS),
+        TRN_HL, DELAY(2.5NS,4.5NS,6.5NS),
+        DELAY(4.5NS,6.5NS,8NS))}
+ TRISTATE:
+   ENABLE HI = OEB
+   YB0 YB1 YB2 YB3 = {
+      CASE(
+        TRN_ZH, DELAY(3NS,5NS,7NS),
+        TRN_ZL, DELAY(3.5NS,5.5NS,7.5NS),
+        TRN_HZ, DELAY(2NS,4NS,6NS),
+        TRN_LZ, DELAY(1.5NS,3.5NS,6NS),
+        TRN_LH, DELAY(3NS,4.5NS,7NS),
+        TRN_HL, DELAY(2.5NS,4.5NS,6.5NS),
+        DELAY(4.5NS,6.5NS,8NS))}

.ENDS 74F2241

*-------------------------------------------------------------74ALS2242-----

* Quadruple Bus Transceivers/MOS Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-913 to 2-915
* jat 3/28/96

.SUBCKT 74ALS2242
+ GABBAR GBA A1 A2 A3 A4 B1 B2 B3 B4
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(8) DPWR DGND
+ A1 A2 A3 A4 B1 B2 B3 B4
+ B1O B2O B3O B4O A1O A2O A3O A4O
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(8,2,0) DPWR DGND
+ B1O B2O B3O B4O A1O A2O A3O A4O
+ GABBAR GBA
+ B1 B2 B3 B4 A1 A2 A3 A4
+ IO_ALS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE LO = GABBAR
+   B1 B2 B3 B4 = {
+      CASE(
+         TRN_ZH, DELAY(-1,8NS,-1),
+         TRN_ZL, DELAY(-1,11NS,-1),
+         TRN_HZ, DELAY(-1,6NS,-1),
+         TRN_LZ, DELAY(-1,6NS,-1),
+         TRN_LH | TRN_HL, DELAY(-1,5NS,-1),
+         DELAY(-1,12NS,-1))}
+ TRISTATE:
+   ENABLE LO = GBA
+   A1 A2 A3 A4 = {
+      CASE(
+         TRN_ZH, DELAY(-1,10NS,-1),
+         TRN_ZL, DELAY(-1,12NS,-1),
+         TRN_HZ, DELAY(-1,6NS,-1),
+         TRN_LZ, DELAY(-1,6NS,-1),
+         TRN_LH | TRN_HL, DELAY(-1,5NS,-1),
+         DELAY(-1,13NS,-1))}

.ENDS 74ALS2242

*------------------------------------------------------------74F2243----

* Quad Bus Transceiver with 25-Ohm Series Resistors in the Outputs
* National Advanced Bipolar Logic Data Book, 1995, pages 7-553 to 7-556
* jat 7/31/96

.SUBCKT 74F2243
+ E1BAR E2 A0 A1 A2 A3 B0 B1 B2 B3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(8,2,0) DPWR DGND
+ A0 A1 A2 A3 B0 B1 B2 B3
+ E1BAR E2
+ B0 B1 B2 B3 A0 A1 A2 A3
+ IO_F_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE LO = E1BAR
+   B0 B1 B2 B3 = {
+      CASE(
+        TRN_ZH, DELAY(1.5NS,-1,9NS),
+        TRN_ZL, DELAY(2.5NS,-1,11.5NS),
+        TRN_HZ, DELAY(1.5NS,-1,9NS),
+        TRN_LZ, DELAY(1.5NS,-1,8.5NS),
+        TRN_LH, DELAY(1.5NS,-1,7NS),
+        TRN_HL, DELAY(2.5NS,-1,8NS),
+        DELAY(3.5NS,-1,12.5NS))}
+ TRISTATE:
+   ENABLE HI = E2
+   A0 A1 A2 A3 = {
+      CASE(
+        TRN_ZH, DELAY(1.5NS,-1,9NS),
+        TRN_ZL, DELAY(2.5NS,-1,11.5NS),
+        TRN_HZ, DELAY(1.5NS,-1,9NS),
+        TRN_LZ, DELAY(1.5NS,-1,8.5NS),
+        TRN_LH, DELAY(1.5NS,-1,7NS),
+        TRN_HL, DELAY(2.5NS,-1,8NS),
+        DELAY(3.5NS,-1,12.5NS))}

.ENDS 74F2243

*------------------------------------------------------------74F2244----

* 25 Ohm Octal Buffers/Drivers with 3-State Outputs
* TI F Logic Data Book, 1994, pages 2-301 to 2-304
* jat 7/3/96

.SUBCKT 74F2244
+ 1OEBAR 1A1 1A2 1A3 1A4 1Y1 1Y2 1Y3 1Y4
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(4,1,0) DPWR DGND
+ 1A1 1A2 1A3 1A4
+ 1OEBAR
+ 1Y1 1Y2 1Y3 1Y4
+ IO_F_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE LO = 1OEBAR
+   1Y1 1Y2 1Y3 1Y4 = {
+      CASE(
+        TRN_ZH, DELAY(1.5NS,-1,9NS),
+        TRN_ZL, DELAY(2.5NS,-1,11.5NS),
+        TRN_HZ, DELAY(1.5NS,-1,9NS),
+        TRN_LZ, DELAY(1.5NS,-1,8.5NS),
+        TRN_LH, DELAY(1.5NS,-1,7NS),
+        TRN_HL, DELAY(2.5NS,-1,8NS),
+        DELAY(3.5NS,-1,12.5NS))}

.ENDS 74F2244

* ----------------------------------------------------------- 74ALS2540 ------
*  Octal Line Drivers/Mos Drivers With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-917 to 2-920
*  bss    6/28/94
*
.SUBCKT 74ALS2540 G1BAR G2BAR A1 A2 A3 A4 A5 A6 A7 A8 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nor(2) DPWR DGND
+     G1BAR G2BAR GEN
+     D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 inv3a(8) DPWR DGND
+     A1 A2 A3 A4 A5 A6 A7 A8
+     GEN
+     Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+     DLY_ALS2540 IO_ALS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS2540 utgate (tplhMN=2ns tplhTY=7.5ns tplhMX=12ns
+                                 tphlMN=2ns tphlTY=5.6ns tphlMX=11ns
+                                 tpzhMN=5ns tpzhTY=9ns tpzhMX=15ns
+                                 tpzlMN=8ns tpzlTY=12.6ns tpzlMX=20ns
+                                 tphzMN=1ns tphzTY=4ns tphzMX=10ns
+                                 tplzMN=2ns tplzTY=7ns tplzMX=12ns)

.ENDS 74ALS2540
*
*
* ----------------------------------------------------------- 74ALS2541 ------
*  Octal Line Drivers/Mos Drivers With 3-State Outputs
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-917 to 2-920
*  bss    6/28/94
*
.SUBCKT 74ALS2541 G1BAR G2BAR A1 A2 A3 A4 A5 A6 A7 A8 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nor(2) DPWR DGND
+     G1BAR G2BAR GEN
+     D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 buf3a(8) DPWR DGND
+     A1 A2 A3 A4 A5 A6 A7 A8
+     GEN
+     Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+     DLY_ALS2541 IO_ALS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_ALS2541 utgate (tplhMN=2ns tplhTY=8.7ns tplhMX=15ns
+                                 tphlMN=2ns tphlTY=7ns tphlMX=12ns
+                                 tpzhMN=5ns tpzhTY=9ns tpzhMX=15ns
+                                 tpzlMN=8ns tpzlTY=12.6ns tpzlMX=20ns
+                                 tphzMN=1ns tphzTY=4ns tphzMX=10ns
+                                 tplzMN=2ns tplzTY=7ns tplzMX=12ns)

.ENDS 74ALS2541
*
*
*-------------------------------------------------------------74AS2620-----

* Octal Bus Transceivers/MOS Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-921 to 2-924
* jat 3/28/96

.SUBCKT 74AS2620
+ GAB GBABAR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(16) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ B1O B2O B3O B4O B5O B6O B7O B8O A1O A2O A3O A4O A5O A6O A7O A8O
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(16,2,0) DPWR DGND
+ B1O B2O B3O B4O B5O B6O B7O B8O A1O A2O A3O A4O A5O A6O A7O A8O
+ GAB GBABAR
+ B1 B2 B3 B4 B5 B6 B7 B8 A1 A2 A3 A4 A5 A6 A7 A8
+ IO_AS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE HI = GAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+      CASE(
+         TRN_ZH, DELAY(1NS,-1,8NS),
+         TRN_ZL, DELAY(1NS,-1,8NS),
+         TRN_HZ, DELAY(1NS,-1,11NS),
+         TRN_LZ, DELAY(1NS,-1,11NS),
+         TRN_LH, DELAY(1NS,-1,8NS),
+         TRN_HL, DELAY(1NS,-1,6.5NS),
+         DELAY(2NS,-1,12NS))}
+ TRISTATE:
+   ENABLE LO = GBABAR
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+      CASE(
+         TRN_ZH, DELAY(1NS,-1,10NS),
+         TRN_ZL, DELAY(1NS,-1,11NS),
+         TRN_HZ, DELAY(1NS,-1,6NS),
+         TRN_LZ, DELAY(1NS,-1,12NS),
+         TRN_LH, DELAY(1NS,-1,8NS),
+         TRN_HL, DELAY(1NS,-1,6.5NS),
+         DELAY(2NS,-1,13NS))}

.ENDS 74AS2620

*-------------------------------------------------------------74AS2623-----

* Octal Bus Transceivers/MOS Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-921 to 2-924
* jat 3/28/96

.SUBCKT 74AS2623
+ GAB GBABAR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(16,2,0) DPWR DGND
+ B1 B2 B3 B4 B5 B6 B7 B8 A1 A2 A3 A4 A5 A6 A7 A8
+ GAB GBABAR
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ IO_AS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE HI = GAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+      CASE(
+         TRN_ZH, DELAY(1NS,-1,12NS),
+         TRN_ZL, DELAY(1NS,-1,12NS),
+         TRN_HZ, DELAY(1NS,-1,7NS),
+         TRN_LZ, DELAY(1NS,-1,12.5NS),
+         TRN_LH, DELAY(1NS,-1,8.5NS),
+         TRN_HL, DELAY(1NS,-1,7.5NS),
+         DELAY(2NS,-1,13.5NS))}
+ TRISTATE:
+   ENABLE LO = GBABAR
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+      CASE(
+         TRN_ZH, DELAY(1NS,-1,11NS),
+         TRN_ZL, DELAY(1NS,-1,11NS),
+         TRN_HZ, DELAY(1NS,-1,7.5NS),
+         TRN_LZ, DELAY(1NS,-1,12NS),
+         TRN_LH, DELAY(1NS,-1,9NS),
+         TRN_HL, DELAY(1NS,-1,7.5NS),
+         DELAY(2NS,-1,13NS))}

.ENDS 74AS2623

*-------------------------------------------------------------74AS2640-----

* Octal Bus Transceivers/MOS Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-925 to 2-928
* jat 3/28/96

.SUBCKT 74AS2640
+ GBAR DIR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(16) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ B1O B2O B3O B4O B5O B6O B7O B8O A1O A2O A3O A4O A5O A6O A7O A8O
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 LOGICEXP(2,2) DPWR DGND
+ GBAR DIR
+ ENABAB ENABBA
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABAB = {~GBAR & DIR}
+   ENABBA = {~GBAR & ~DIR}

U3 PINDLY(16,2,0) DPWR DGND
+ B1O B2O B3O B4O B5O B6O B7O B8O A1O A2O A3O A4O A5O A6O A7O A8O
+ ENABAB ENABBA
+ B1 B2 B3 B4 B5 B6 B7 B8 A1 A2 A3 A4 A5 A6 A7 A8
+ IO_AS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE HI = ENABAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+      CASE(
+         TRN_ZH, DELAY(2NS,-1,9NS),
+         TRN_ZL, DELAY(2NS,-1,10NS),
+         TRN_HZ, DELAY(1NS,-1,7NS),
+         TRN_LZ, DELAY(2NS,-1,13NS),
+         TRN_LH, DELAY(1NS,-1,7.5NS),
+         TRN_HL, DELAY(1NS,-1,6.5NS),
+         DELAY(3NS,-1,14NS))}
+ TRISTATE:
+   ENABLE HI = ENABBA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+      CASE(
+         TRN_ZH, DELAY(2NS,-1,9NS),
+         TRN_ZL, DELAY(2NS,-1,10NS),
+         TRN_HZ, DELAY(1NS,-1,7NS),
+         TRN_LZ, DELAY(2NS,-1,13NS),
+         TRN_LH, DELAY(1NS,-1,7.5NS),
+         TRN_HL, DELAY(1NS,-1,6.5NS),
+         DELAY(3NS,-1,14NS))}

.ENDS 74AS2640

*-------------------------------------------------------------74AS2645-----

* Octal Bus Transceivers/MOS Drivers
* TI ALS/AS Logic Data Book, 1986, pages 2-925 to 2-928
* jat 3/28/96

.SUBCKT 74AS2645
+ GBAR DIR A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ OPTIONAL: DPWR = $G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U2 LOGICEXP(2,2) DPWR DGND
+ GBAR DIR
+ ENABAB ENABBA
+ D0_GATE IO_AS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABAB = {~GBAR & DIR}
+   ENABBA = {~GBAR & ~DIR}

U3 PINDLY(16,2,0) DPWR DGND
+ B1 B2 B3 B4 B5 B6 B7 B8 A1 A2 A3 A4 A5 A6 A7 A8
+ ENABAB ENABBA
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ IO_AS_25 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+   ENABLE HI = ENABAB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+      CASE(
+         TRN_ZH, DELAY(1NS,-1,11.5NS),
+         TRN_ZL, DELAY(1NS,-1,10.5NS),
+         TRN_HZ, DELAY(1NS,-1,8NS),
+         TRN_LZ, DELAY(1NS,-1,12NS),
+         TRN_LH, DELAY(1NS,-1,10NS),
+         TRN_HL, DELAY(1NS,-1,9.5NS),
+         DELAY(2NS,-1,12.5NS))}
+ TRISTATE:
+   ENABLE HI = ENABBA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+      CASE(
+         TRN_ZH, DELAY(1NS,-1,11.5NS),
+         TRN_ZL, DELAY(1NS,-1,10.5NS),
+         TRN_HZ, DELAY(1NS,-1,8NS),
+         TRN_LZ, DELAY(1NS,-1,12NS),
+         TRN_LH, DELAY(1NS,-1,10NS),
+         TRN_HL, DELAY(1NS,-1,9.5NS),
+         DELAY(2NS,-1,12.5NS))}

.ENDS 74AS2645

*------------------------------------------------------------74F2645-----

* Octal Bus Transceiver with 25-Ohm Series Resistors in the Outputs
* National Advanced Bipolar Logic Data Book, 1995, pages 7-557 to 7-560
* jat 7/31/96

.SUBCKT 74F2645 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 OEBAR T/RBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,2) DPWR DGND
+ T/RBAR OEBAR
+ AB BA
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   AB = {T/RBAR & ~OEBAR}
+   BA = {~T/RBAR & ~OEBAR}

U2 PINDLY(16,2,0) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ AB BA
+ B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7 
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = BA
+   A0 A1 A2 A3 A4 A5 A6 A7 = {
+     CASE(
+       TRN_ZH, DELAY(2.5NS,-1,8NS),
+       TRN_ZL, DELAY(2.5NS,-1,8.5NS),
+       TRN_HZ, DELAY(1.5NS,-1,7NS),
+       TRN_LZ, DELAY(1NS,-1,5.5NS),
+       TRN_LH, DELAY(1.5NS,-1,6NS),
+       TRN_HL, DELAY(2.5NS,-1,7.5NS),
+       DELAY(3.5NS,-1,9.5NS))}
+ TRISTATE:
+ ENABLE HI = AB
+   B0 B1 B2 B3 B4 B5 B6 B7 = {
+     CASE(
+       TRN_ZH, DELAY(2.5NS,-1,7.5NS),
+       TRN_ZL, DELAY(2.5NS,-1,8.5NS),
+       TRN_HZ, DELAY(1.5NS,-1,6.5NS),
+       TRN_LZ, DELAY(1NS,-1,6.5NS),
+       TRN_LH, DELAY(1.5NS,-1,6NS),
+       TRN_HL, DELAY(2.5NS,-1,7.5NS),
+       DELAY(3.5NS,-1,9.5NS))}

.ENDS 74F2645

*-----------------------------------------------------------74F2952-----

* Registered Transceiver, Non-Inverting (Tri-State)
* Philips FAST TTL Logic Series Data Book, 1992, pages 931 to 938
* jat 7/31/96

.SUBCKT 74F2952 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ CPAB CPBA CEABBAR CEBABAR OEABBAR OEBABAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND

U1 LOGICEXP(4,2) DPWR DGND
+ CEABBAR CPAB CEBABAR CPBA
+ CLOCKAB CLOCKBA
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCKAB = {~CEABBAR & CPAB}
+   CLOCKBA = {~CEBABAR & CPBA}

U2 DFF(8) DPWR DGND
+ $D_HI $D_HI CLOCKAB
+ A0 A1 A2 A3 A4 A5 A6 A7
+ QA0 QA1 QA2 QA3 QA4 QA5 QA6 QA7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(8) DPWR DGND
+ $D_HI $D_HI CLOCKBA
+ B0 B1 B2 B3 B4 B5 B6 B7
+ QB0 QB1 QB2 QB3 QB4 QB5 QB6 QB7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(16,2,0) DPWR DGND
+ QA0 QA1 QA2 QA3 QA4 QA5 QA6 QA7 QB0 QB1 QB2 QB3 QB4 QB5 QB6 QB7
+ OEABBAR OEBABAR
+ B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+  ENABLE LO = OEABBAR
+  B0 B1 B2 B3 B4 B5 B6 B7 = {
+    CASE(
+      TRN_ZH, DELAY(2NS,4.5NS,7NS),
+      TRN_ZL, DELAY(3.5NS,6NS,9.5NS),
+      TRN_HZ, DELAY(2NS,4NS,8NS),
+      TRN_LZ, DELAY(1.5NS,3.5NS,6.5NS),
+      TRN_LH, DELAY(3NS,5NS,7.5NS),
+      TRN_HL, DELAY(3.5NS,6NS,8.5NS),
+      DELAY(4.5NS,7NS,10.5NS))}
+ TRISTATE:
+  ENABLE LO = OEBABAR
+  A0 A1 A2 A3 A4 A5 A6 A7 = {
+    CASE(
+      TRN_ZH, DELAY(2NS,4.5NS,7NS),
+      TRN_ZL, DELAY(3.5NS,6NS,9.5NS),
+      TRN_HZ, DELAY(2NS,4NS,8NS),
+      TRN_LZ, DELAY(1.5NS,3.5NS,6.5NS),
+      TRN_LH, DELAY(3NS,5NS,7.5NS),
+      TRN_HL, DELAY(3.5NS,6NS,8.5NS),
+      DELAY(4.5NS,7NS,10.5NS))}

U5 CONSTRAINT(20) DPWR DGND
+ CPAB CPBA CEABBAR CEBABAR B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  CPAB
+  MAXFREQ = 160MEG
+ FREQ:
+  NODE =  CPBA
+  MAXFREQ = 160MEG
+ WIDTH:
+  NODE = CPAB
+  MIN_HI = 3NS
+  MIN_LO = 3.5NS
+ WIDTH:
+  NODE = CPBA
+  MIN_HI = 3NS
+  MIN_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPAB
+  DATA(8) = A0 A1 A2 A3 A4 A5 A6 A7
+  SETUPTIME_HI = 4.5NS
+  SETUPTIME_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPBA
+  DATA(8) = B0 B1 B2 B3 B4 B5 B6 B7
+  SETUPTIME_HI = 4.5NS
+  SETUPTIME_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPAB
+  DATA(1) = CEABBAR
+  SETUPTIME_LO = 4NS
+  HOLDTIME = 2.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPBA
+  DATA(1) = CEBABAR
+  SETUPTIME_LO = 4NS
+  HOLDTIME = 2.5NS

.ENDS 74F2952

*-----------------------------------------------------------74F2953-----

* Registered Transceiver, Inverting (Tri-State)
* Philips FAST TTL Logic Series Data Book, 1992, pages 931 to 938
* jat 7/31/96

.SUBCKT 74F2953 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ CPAB CPBA CEABBAR CEBABAR OEABBAR OEBABAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND

U1 LOGICEXP(4,2) DPWR DGND
+ CEABBAR CPAB CEBABAR CPBA
+ CLOCKAB CLOCKBA
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCKAB = {~CEABBAR & CPAB}
+   CLOCKBA = {~CEBABAR & CPBA}

U2 DFF(8) DPWR DGND
+ $D_HI $D_HI CLOCKAB
+ A0 A1 A2 A3 A4 A5 A6 A7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ QA0BAR QA1BAR QA2BAR QA3BAR QA4BAR QA5BAR QA6BAR QA7BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(8) DPWR DGND
+ $D_HI $D_HI CLOCKBA
+ B0 B1 B2 B3 B4 B5 B6 B7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ QB0BAR QB1BAR QB2BAR QB3BAR QB4BAR QB5BAR QB6BAR QB7BAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(16,2,0) DPWR DGND
+ QA0BAR QA1BAR QA2BAR QA3BAR QA4BAR QA5BAR QA6BAR QA7BAR
+ QB0BAR QB1BAR QB2BAR QB3BAR QB4BAR QB5BAR QB6BAR QB7BAR
+ OEABBAR OEBABAR
+ B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+  ENABLE LO = OEABBAR
+  B0 B1 B2 B3 B4 B5 B6 B7 = {
+    CASE(
+      TRN_ZH, DELAY(2NS,4.5NS,7NS),
+      TRN_ZL, DELAY(3.5NS,6NS,9.5NS),
+      TRN_HZ, DELAY(2NS,4NS,8NS),
+      TRN_LZ, DELAY(1.5NS,3.5NS,6.5NS),
+      TRN_LH, DELAY(3NS,5NS,7.5NS),
+      TRN_HL, DELAY(3.5NS,6NS,8.5NS),
+      DELAY(4.5NS,7NS,10.5NS))}
+ TRISTATE:
+  ENABLE LO = OEBABAR
+  A0 A1 A2 A3 A4 A5 A6 A7 = {
+    CASE(
+      TRN_ZH, DELAY(2NS,4.5NS,7NS),
+      TRN_ZL, DELAY(3.5NS,6NS,9.5NS),
+      TRN_HZ, DELAY(2NS,4NS,8NS),
+      TRN_LZ, DELAY(1.5NS,3.5NS,6.5NS),
+      TRN_LH, DELAY(3NS,5NS,7.5NS),
+      TRN_HL, DELAY(3.5NS,6NS,8.5NS),
+      DELAY(4.5NS,7NS,10.5NS))}

U5 CONSTRAINT(20) DPWR DGND
+ CPAB CPBA CEABBAR CEBABAR B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  CPAB
+  MAXFREQ = 160MEG
+ FREQ:
+  NODE =  CPBA
+  MAXFREQ = 160MEG
+ WIDTH:
+  NODE = CPAB
+  MIN_HI = 3NS
+  MIN_LO = 3.5NS
+ WIDTH:
+  NODE = CPBA
+  MIN_HI = 3NS
+  MIN_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPAB
+  DATA(8) = A0 A1 A2 A3 A4 A5 A6 A7
+  SETUPTIME_HI = 4NS
+  SETUPTIME_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPBA
+  DATA(8) = B0 B1 B2 B3 B4 B5 B6 B7
+  SETUPTIME_HI = 4NS
+  SETUPTIME_LO = 3.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPAB
+  DATA(1) = CEABBAR
+  SETUPTIME_LO = 4NS
+  HOLDTIME = 2.5NS
+ SETUP_HOLD:
+  CLOCK LH = CPBA
+  DATA(1) = CEBABAR
+  SETUPTIME_LO = 4NS
+  HOLDTIME = 2.5NS

.ENDS 74F2953

*------------------------------------------------------------74F3037----

* Quad 2-Input NAND 30-Ohm Drivers
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 939 to 941
* jat 7/31/96

.SUBCKT 74F3037 D0A D0B Q0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 NAND(2) DPWR DGND
+ D0A D0B Q0BAR
+ DLY_F3037 IO_F_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F3037 UGATE (TPLHMN=1NS TPLHTY=2NS TPLHMX=5NS
+                      TPHLMN=1NS TPHLTY=2NS TPHLMX=4.5NS)

.ENDS 74F3037

*------------------------------------------------------------74F3038----

* Quad 2-Input NAND 30-Ohm Drivers (Open Collector)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 942 to 945
* jat 7/31/96

.SUBCKT 74F3038 D0A D0B Q0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 NAND(2) DPWR DGND
+ D0A D0B Q0BAR
+ DLY_F3038 IO_F_OC_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F3038 UGATE (TPLHMN=6NS TPLHTY=8.5NS TPLHMX=11.5NS
+                      TPHLMN=1NS TPHLTY=2NS TPHLMX=5NS)

.ENDS 74F3038

*------------------------------------------------------------74F3040----

* Dual 4-Input NAND 30-Ohm Line Driver
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 946 to 949
* jat 7/31/96

.SUBCKT 74F3040 D0A D0B D0C D0D Q0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$D_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 NAND(4) DPWR DGND
+ D0A D0B D0C D0D Q0BAR
+ DLY_F3040 IO_F_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F3040 UGATE (TPLHMN=1NS TPLHTY=2NS TPLHMX=5NS
+                      TPHLMN=1NS TPHLTY=2NS TPHLMX=4.5NS)

.ENDS 74F3040

* ----------------------------------------------------------- 74HC4002 ------
*  Dual 4-Input Nor Gates
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-613 to 2-615
*  bss    6/28/94
*
.SUBCKT 74HC4002 1A 1B 1C 1D 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nor(4) DPWR DGND
+     1A 1B 1C 1D 1Y
+     DLY_HC4002 IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_HC4002 ugate (tplhTY=12ns tplhMX=22ns tphlTY=12ns tphlMX=22ns)

.ENDS 74HC4002
*
*
* ----------------------------------------------------------- 74HCT4002 ------
*  Dual 4-Input Nor Gates
*
*  The High Speed CMOS Logic Data Book, 1994, Philips Pages 789 to 792
*  bss    6/28/94
*
.SUBCKT 74HCT4002 1A 1B 1C 1D 1Y 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 nor(4) DPWR DGND
+     1A 1B 1C 1D 1Y
+     DLY_HCT4002 IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DLY_HCT4002 ugate (tplhTY=13ns tplhMX=22ns tphlTY=13ns tphlMX=22ns)

.ENDS 74HCT4002

*-----------------------------------------------------------74HC4015------

* Dual 4-Bit Serial-In/Parallel-Out Shift Register
* Philips High-Speed CMOS Family Logic Data Handbook, 1994, pages 793 to 797
* jat 9/12/96

.SUBCKT 74HC4015 1D 1CP 1MR 1Q0 1Q1 1Q2 1Q3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INV DPWR DGND
+ 1MR MRBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR 1CP
+ 1D 1Q0O 1Q1O 1Q2O
+ 1Q0O 1Q1O 1Q2O 1Q3O
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,2) DPWR DGND
+ 1Q0O 1Q1O 1Q2O 1Q3O
+ 1CP 1MR
+ 1Q0 1Q1 1Q2 1Q3
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_LH(1MR,0)}
+   CLOCK = {CHANGED_LH(1CP,0)}
+ PINDLY:
+   1Q0 1Q1 1Q2 1Q3 = {
+     CASE(
+       CLEAR & TRN_HL, DELAY(-1,16NS,35NS),
+       CLOCK & (TRN_LH | TRN_HL), DELAY(-1,19NS,35NS),
+       DELAY(-1,20NS,36NS))}

U4 CONSTRAINT(3) DPWR DGND
+ 1CP 1MR 1D
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = 1CP
+  MAXFREQ = 100MEG
+ WIDTH:
+  NODE = 1MR
+  MIN_HI = 6NS
+ WIDTH:
+  NODE = 1CP
+  MIN_LO = 6NS
+  MIN_HI = 6NS
+ SETUP_HOLD:
+  CLOCK LH = 1CP
+  DATA(1) = 1D
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = 1CP
+  DATA(1) = 1MR
+  SETUPTIME_LO = 6NS

.ENDS 74HC4015

*-----------------------------------------------------------74HCT4015------

* Dual 4-Bit Serial-In/Parallel-Out Shift Register
* Philips High-Speed CMOS Family Logic Data Handbook, 1994, pages 793 to 797
* jat 9/12/96

.SUBCKT 74HCT4015 1D 1CP 1MR 1Q0 1Q1 1Q2 1Q3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INV DPWR DGND
+ 1MR MRBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR 1CP
+ 1D 1Q0O 1Q1O 1Q2O
+ 1Q0O 1Q1O 1Q2O 1Q3O
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,2) DPWR DGND
+ 1Q0O 1Q1O 1Q2O 1Q3O
+ 1CP 1MR
+ 1Q0 1Q1 1Q2 1Q3
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_LH(1MR,0)}
+   CLOCK = {CHANGED_LH(1CP,0)}
+ PINDLY:
+   1Q0 1Q1 1Q2 1Q3 = {
+     CASE(
+       CLEAR & TRN_HL, DELAY(-1,18NS,35NS),
+       CLOCK & (TRN_LH | TRN_HL), DELAY(-1,21NS,35NS),
+       DELAY(-1,22NS,36NS))}

U4 CONSTRAINT(3) DPWR DGND
+ 1CP 1MR 1D
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = 1CP
+  MAXFREQ = 67MEG
+ WIDTH:
+  NODE = 1MR
+  MIN_HI = 5NS
+ WIDTH:
+  NODE = 1CP
+  MIN_LO = 7NS
+  MIN_HI = 7NS
+ SETUP_HOLD:
+  CLOCK LH = 1CP
+  DATA(1) = 1D
+  SETUPTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = 1CP
+  DATA(1) = 1MR
+  SETUPTIME_LO = 10NS

.ENDS 74HCT4015

*-------------------------------------------------------------74HC4017------

* Decade Counters/Dividers
* TI High-Speed CMOS Logic Data Book, 1989, pages 2-625 to 2-629
* jat 12/29/95

.SUBCKT 74HC4017
+ CLKENBAR CLK CLR Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 CO
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,14) DPWR DGND
+ CLK CLKENBAR CLR Q1 Q2 Q3 Q4 Q5 Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR
+ CLOCK CLRBAR D3 Y0O Y1O Y2O Y3O Y4O Y5O Y6O Y7O Y8O Y9O COO
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CLK & (~CLKENBAR)}
+   CLRBAR ={~CLR}
+   D3 = {Q2 & (Q1 | Q3)}
+   Y0O = {Q1BAR & Q5BAR}
+   Y1O = {Q1 & Q2BAR}
+   Y2O = {Q2 & Q3BAR}
+   Y3O = {Q3 & Q4BAR}
+   Y4O = {Q4 & Q5BAR}
+   Y5O = {Q1 & Q5}
+   Y6O = {Q2 & Q1BAR}
+   Y7O = {Q3 & Q2BAR}
+   Y8O = {Q4 & Q3BAR}
+   Y9O = {Q5 & Q4BAR}
+   COO = {Q5BAR}

U2 DFF(5) DPWR DGND
+ $D_HI CLRBAR CLOCK
+ Q5BAR Q1 D3 Q3 Q4
+ Q1 Q2 Q3 Q4 Q5
+ Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(11,0,3) DPWR DGND
+ Y0O Y1O Y2O Y3O Y4O Y5O Y6O Y7O Y8O Y9O COO
+ CLR CLKENBAR CLK
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 CO
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  CLEAR = {CHANGED(CLR,0)}
+  ENAB = {CHANGED(CLKENBAR,0)}
+  EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+  Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9  = {
+    CASE(
+        CLEAR & (TRN_LH | TRN_HL), DELAY(-1,23NS,46NS),
+        ENAB & (TRN_LH | TRN_HL), DELAY(-1,25NS,50NS),
+        EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,46NS),
+        DELAY(-1,26NS,51NS))}
+ PINDLY:
+    CO = {
+      CASE(
+        CLEAR & TRN_LH, DELAY(-1,23NS,46NS),
+        ENAB & (TRN_LH | TRN_HL), DELAY(-1,25NS,50NS),
+        EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,46NS),
+        DELAY(-1,26NS,51NS))}

U4 CONSTRAINT(3) DPWR DGND
+ CLK CLKENBAR CLR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 31MEG
+ FREQ:
+  NODE = CLKENBAR
+  MAXFREQ = 31MEG
+ WIDTH:
+  NODE = CLK
+  MIN_LO = 16NS
+  MIN_HI = 16NS
+ WIDTH:
+  NODE = CLKENBAR
+  MIN_LO = 16NS
+  MIN_HI = 16NS
+ WIDTH:
+  NODE = CLR
+  MIN_HI = 16NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLKENBAR
+  SETUPTIME_LO = 10NS
+  HOLDTIME_LO = 5NS
+ SETUP_HOLD:
+  CLOCK HL = CLKENBAR
+  DATA(1) = CLK
+  SETUPTIME_HI = 10NS
+  HOLDTIME_HI = 5NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLR
+  SETUPTIME_LO = 10NS
+ SETUP_HOLD:
+  CLOCK HL = CLKENBAR
+  DATA(1) = CLR
+  SETUPTIME_LO = 10NS

.ENDS 74HC4017

*-------------------------------------------------------------74HCT4017------

* Johnson Decade Counter with 10 Decoded Outputs
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 811 to 817
* jat 9/12/96

.SUBCKT 74HCT4017
+ CP0 CP1BAR MR Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q59BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,14) DPWR DGND
+ CP0 CP1BAR MR QA QB QC QD QE QABAR QBBAR QCBAR QDBAR QEBAR
+ CLOCK MRBAR DC Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O Q8O Q9O Q59BARO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CP0 & ~CP1BAR}
+   MRBAR ={~MR}
+   DC = {QB & (QA | QC)}
+   Q0O = {QABAR & QEBAR}
+   Q1O = {QA & QBBAR}
+   Q2O = {QB & QCBAR}
+   Q3O = {QC & QDBAR}
+   Q4O = {QD & QEBAR}
+   Q5O = {QA & QE}
+   Q6O = {QB & QABAR}
+   Q7O = {QC & QBBAR}
+   Q8O = {QD & QCBAR}
+   Q9O = {QE & QDBAR}
+   Q59BARO = {QEBAR}

U2 DFF(5) DPWR DGND
+ $D_HI MRBAR CLOCK
+ QEBAR QA DC QC QD
+ QA QB QC QD QE
+ QABAR QBBAR QCBAR QDBAR QEBAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(11,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O Q8O Q9O Q59BARO
+ MR CP0 CP1BAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q59BAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  CLEAR = {CHANGED_LH(MR,0)}
+  CLK1 = {CHANGED_HL(CP1BAR,0)}
+  CLK0 = {CHANGED_LH(CP0,0)}
+ PINDLY:
+  Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 = {
+    CASE(
+        CLEAR & (TRN_LH | TRN_HL), DELAY(-1,22NS,46NS),
+        CLK1 & (TRN_LH | TRN_HL), DELAY(-1,25NS,50NS),
+        CLK0 & (TRN_LH | TRN_HL), DELAY(-1,25NS,46NS),
+        DELAY(-1,26NS,51NS))}
+  Q0 Q59BAR= {
+    CASE(
+        CLEAR & (TRN_LH | TRN_HL), DELAY(-1,20NS,46NS),
+        CLK1 & (TRN_LH | TRN_HL), DELAY(-1,25NS,50NS),
+        CLK0 & (TRN_LH | TRN_HL), DELAY(-1,25NS,46NS),
+        DELAY(-1,26NS,51NS))}

U4 CONSTRAINT(3) DPWR DGND
+ CP0 CP1BAR MR
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP0
+  MAXFREQ = 61MEG
+ FREQ:
+  NODE = CP1BAR
+  MAXFREQ = 61MEG
+ WIDTH:
+  NODE = CP0
+  MIN_LO = 7NS
+  MIN_HI = 7NS
+ WIDTH:
+  NODE = CP1BAR
+  MIN_LO = 7NS
+  MIN_HI = 7NS
+ WIDTH:
+  NODE = MR
+  MIN_HI = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP0
+  DATA(1) = CP1BAR
+  HOLDTIME_LO = 6NS
+ SETUP_HOLD:
+  CLOCK HL = CP1BAR
+  DATA(1) = CP0
+  HOLDTIME_HI = 6NS

.ENDS 74HCT4017

* ----------------------------------------------------------- 74AC4020 ------
*  14-Stage Binary Ripple Counter
*
*  The FACT Data Data Book, 1993, Motorola Pages 5-391 to 5-394
*  bss    6/28/94
*
.SUBCKT 74AC4020 CLK RESET Q1 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     RESET RESETBAR
+     D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 JKFF(1) DPWR DGND
+     $D_HI RESETBAR CLK $D_HI $D_HI Q1_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q1_O $D_HI $D_HI Q2_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q2_O $D_HI $D_HI Q3_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q3_O $D_HI $D_HI Q4_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q4_O $D_HI $D_HI Q5_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q5_O $D_HI $D_HI Q6_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q6_O $D_HI $D_HI Q7_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q7_O $D_HI $D_HI Q8_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q8_O $D_HI $D_HI Q9_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q9_O $D_HI $D_HI Q10_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q10_O $D_HI $D_HI Q11_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q11_O $D_HI $D_HI Q12_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q12_O $D_HI $D_HI Q13_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U15 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q13_O $D_HI $D_HI Q14_O $D_NC
+     D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U16DLY PINDLY(12,0,2) DPWR DGND
+     Q1_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O Q10_O Q11_O Q12_O Q13_O Q14_O
+     RESET CLK
+     Q1 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14
+     IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     CLOCK = {CHANGED_HL(CLK,0)}
+     CLEAR = {CHANGED_LH(RESET,0)}
+
+  PINDLY:
+     Q1 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,8ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,8ns),
+         DELAY(4ns,-1,11ns))}
+
+     Q4 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,13ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+         DELAY(4ns,-1,14ns))}
+
+     Q5 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,16.5ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,16.5ns),
+         DELAY(4ns,-1,17.5ns))}
+
+     Q6 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,20ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,20ns),
+         DELAY(4ns,-1,21ns))}
+
+     Q7 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,23.5ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,23.5ns),
+         DELAY(4ns,-1,24.5ns))}
+
+     Q8 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,27ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,27ns),
+         DELAY(4ns,-1,28ns))}
+
+     Q9 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,30.5ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,30.5ns),
+         DELAY(4ns,-1,31.5ns))}
+
+     Q10 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,34ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,34ns),
+         DELAY(4ns,-1,35ns))}
+
+     Q11 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,37.5ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,37.5ns),
+         DELAY(4ns,-1,38.5ns))}
+
+     Q12 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,41ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,41ns),
+         DELAY(4ns,-1,42ns))}
+
+     Q13 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,44.5ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,44.5ns),
+         DELAY(4ns,-1,45.5ns))}
+
+     Q14 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(3ns,-1,10ns),
+         CLOCK & TRN_LH, DELAY(2ns,-1,48ns),
+         CLOCK & TRN_HL, DELAY(2ns,-1,48ns),
+         DELAY(4ns,-1,49ns))}

U17CON CONSTRAINT(2) DPWR DGND
+     CLK RESET
+     IO_AC IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=RESET
+     MIN_HI=3.5ns
+
+  WIDTH:
+     NODE=CLK
+     MIN_HI=3.5ns
+     MIN_LO=3.5ns

.ENDS 74AC4020
*
*
* ----------------------------------------------------------- 74HC4020 ------
*  Asynchronous 14-Bit Binary Counters
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-631 to 2-634
*  bss    6/28/94
*
.SUBCKT 74HC4020 CLK CLR QA QD QE QF QG QH QI QJ QK QL QM QN 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     CLR RESETBAR
+     D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 JKFF(1) DPWR DGND
+     $D_HI RESETBAR CLK $D_HI $D_HI QA_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QA_O $D_HI $D_HI QB_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QB_O $D_HI $D_HI QC_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QC_O $D_HI $D_HI QD_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QD_O $D_HI $D_HI QE_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QE_O $D_HI $D_HI QF_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QF_O $D_HI $D_HI QG_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QG_O $D_HI $D_HI QH_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QH_O $D_HI $D_HI QI_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QI_O $D_HI $D_HI QJ_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QJ_O $D_HI $D_HI QK_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QK_O $D_HI $D_HI QL_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QL_O $D_HI $D_HI QM_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U15 JKFF(1) DPWR DGND
+     $D_HI RESETBAR QM_O $D_HI $D_HI QN_O $D_NC
+     D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U16DLY PINDLY(12,0,2) DPWR DGND
+     QA_O QD_O QE_O QF_O QG_O QH_O QI_O QJ_O QK_O QL_O QM_O QN_O
+     CLR CLK
+     QA QD QE QF QG QH QI QJ QK QL QM QN
+     IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     CLOCK = {CHANGED_HL(CLK,0)}
+     CLEAR = {CHANGED_LH(CLR,0)}
+
+  PINDLY:
+     QA = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,16ns,30ns),
+         CLOCK & TRN_HL, DELAY(-1,16ns,30ns),
+         DELAY(-1,18ns,31ns))}
+
+     QD = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,40ns,75ns),
+         CLOCK & TRN_HL, DELAY(-1,40ns,75ns),
+         DELAY(-1,41ns,76ns))}
+
+     QE = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,48ns,90ns),
+         CLOCK & TRN_HL, DELAY(-1,48ns,90ns),
+         DELAY(-1,49ns,91ns))}
+
+     QF = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,56ns,105ns),
+         CLOCK & TRN_HL, DELAY(-1,56ns,105ns),
+         DELAY(-1,57ns,106ns))}
+
+     QG = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,64ns,120ns),
+         CLOCK & TRN_HL, DELAY(-1,64ns,120ns),
+         DELAY(-1,65ns,121ns))}
+
+     QH = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,72ns,135ns),
+         CLOCK & TRN_HL, DELAY(-1,72ns,135ns),
+         DELAY(-1,73ns,136ns))}
+
+     QI = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,80ns,150ns),
+         CLOCK & TRN_HL, DELAY(-1,80ns,150ns),
+         DELAY(-1,81ns,151ns))}
+
+     QJ = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,88ns,165ns),
+         CLOCK & TRN_HL, DELAY(-1,88ns,165ns),
+         DELAY(-1,89ns,166ns))}
+
+     QK = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,96ns,180ns),
+         CLOCK & TRN_HL, DELAY(-1,96ns,180ns),
+         DELAY(-1,97ns,181ns))}
+
+     QL = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,104ns,195ns),
+         CLOCK & TRN_HL, DELAY(-1,104ns,195ns),
+         DELAY(-1,105ns,196ns))}
+
+     QM = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,112ns,210ns),
+         CLOCK & TRN_HL, DELAY(-1,112ns,210ns),
+         DELAY(-1,113ns,211ns))}
+
+     QN = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,17ns,28ns),
+         CLOCK & TRN_LH, DELAY(-1,120ns,225ns),
+         CLOCK & TRN_HL, DELAY(-1,120ns,225ns),
+         DELAY(-1,121ns,226ns))}

U17CON CONSTRAINT(2) DPWR DGND
+     CLK CLR
+     IO_HC IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=CLR
+     MIN_HI=18ns
+
+  WIDTH:
+     NODE=CLK
+     MIN_HI=23ns
+     MIN_LO=23ns
+
+	SETUP_HOLD:
+		CLOCK HL=CLK
+		DATA(1)=CLR
+		SETUPTIME_LO=15ns

.ENDS 74HC4020
*
*
* ----------------------------------------------------------- 74HCT4020 ------
*  14-Stage Binary Ripple Counter
*
*  The High Speed CMOS Logic Data Book, 1994, Philips Pages 819 to 823
*  bss    6/28/94
*
.SUBCKT 74HCT4020 CP MR Q0 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 
+     optional:  DPWR=$G_DPWR DGND=$G_DGND
+     params:  MNTYMXDLY=0 IO_LEVEL=0

U1 inv DPWR DGND
+     MR RESETBAR
+     D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q0_O $D_HI $D_HI Q1_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q1_O $D_HI $D_HI Q2_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q2_O $D_HI $D_HI Q3_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q3_O $D_HI $D_HI Q4_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q4_O $D_HI $D_HI Q5_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q5_O $D_HI $D_HI Q6_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q6_O $D_HI $D_HI Q7_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q7_O $D_HI $D_HI Q8_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q8_O $D_HI $D_HI Q9_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q9_O $D_HI $D_HI Q10_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q10_O $D_HI $D_HI Q11_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q11_O $D_HI $D_HI Q12_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 JKFF(1) DPWR DGND
+     $D_HI RESETBAR Q12_O $D_HI $D_HI Q13_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U15 JKFF(1) DPWR DGND
+     $D_HI RESETBAR CP $D_HI $D_HI Q0_O $D_NC
+     D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U16DLY PINDLY(12,0,2) DPWR DGND
+     Q0_O Q3_O Q4_O Q5_O Q6_O Q7_O Q8_O Q9_O Q10_O Q11_O Q12_O Q13_O
+     MR CP
+     Q0 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13
+     IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  BOOLEAN:
+     CLOCK = {CHANGED_HL(CP,0)}
+     CLEAR = {CHANGED_LH(MR,0)}
+
+  PINDLY:
+     Q0 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,18ns,36ns),
+         CLOCK & TRN_HL, DELAY(-1,18ns,36ns),
+         DELAY(-1,23ns,46ns))}
+
+     Q3 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,42ns,81ns),
+         CLOCK & TRN_HL, DELAY(-1,42ns,81ns),
+         DELAY(-1,43ns,82ns))}
+
+     Q4 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,50ns,96ns),
+         CLOCK & TRN_HL, DELAY(-1,50ns,96ns),
+         DELAY(-1,51ns,97ns))}
+
+     Q5 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,58ns,111ns),
+         CLOCK & TRN_HL, DELAY(-1,58ns,111ns),
+         DELAY(-1,59ns,112ns))}
+
+     Q6 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,66ns,126ns),
+         CLOCK & TRN_HL, DELAY(-1,66ns,126ns),
+         DELAY(-1,67ns,127ns))}
+
+     Q7 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,74ns,141ns),
+         CLOCK & TRN_HL, DELAY(-1,74ns,141ns),
+         DELAY(-1,75ns,142ns))}
+
+     Q8 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,82ns,156ns),
+         CLOCK & TRN_HL, DELAY(-1,82ns,156ns),
+         DELAY(-1,83ns,157ns))}
+
+     Q9 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,90ns,171ns),
+         CLOCK & TRN_HL, DELAY(-1,90ns,171ns),
+         DELAY(-1,91ns,172ns))}
+
+     Q10 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,98ns,186ns),
+         CLOCK & TRN_HL, DELAY(-1,98ns,186ns),
+         DELAY(-1,99ns,187ns))}
+
+     Q11 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,106ns,201ns),
+         CLOCK & TRN_HL, DELAY(-1,106ns,201ns),
+         DELAY(-1,107ns,202ns))}
+
+     Q12 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,114ns,216ns),
+         CLOCK & TRN_HL, DELAY(-1,114ns,216ns),
+         DELAY(-1,115ns,217ns))}
+
+     Q13 = {
+       CASE(
+         CLEAR & TRN_HL, DELAY(-1,22ns,45ns),
+         CLOCK & TRN_LH, DELAY(-1,122ns,231ns),
+         CLOCK & TRN_HL, DELAY(-1,122ns,231ns),
+         DELAY(-1,123ns,232ns))}

U17CON CONSTRAINT(2) DPWR DGND
+     CP MR
+     IO_HCT IO_LEVEL={IO_LEVEL}
+
+  WIDTH:
+     NODE=MR
+     MIN_HI=25ns
+
+  WIDTH:
+     NODE=CP
+     MIN_HI=25ns
+     MIN_LO=25ns
+
+  SETUP_HOLD:
+     CLOCK HL=CP
+     DATA(1)=MR
+     SETUPTIME_LO=13ns

.ENDS 74HCT4020
*
*
*---------------------------------------------------74HC4024-------------

* The 74HC4024 Asynchronous 7-Bit Binary Counter
* TI High Speed CMOS Logic Data Book, 1989, pages 2-635 to 2-638
* jat 8/9/95

.SUBCKT 74HC4024
+ CLK CLR QA QB QC QD QE QF QG
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,2) DPWR DGND
+ CLR CLK
+ CLOCKA CLRBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CLOCKA = {CLK & (~CLR)}
+  CLRBAR = {~CLR}

U2 JKFF(1) DPWR DGND 
+ $D_HI CLRBAR CLOCKA 
+ $D_HI $D_HI Q_A $D_NC 
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ $D_HI CLRBAR Q_A
+ $D_HI $D_HI Q_B $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ $D_HI CLRBAR Q_B
+ $D_HI $D_HI Q_C $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
 
U5 JKFF(1) DPWR DGND
+ $D_HI CLRBAR Q_C
+ $D_HI $D_HI Q_D $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ $D_HI CLRBAR Q_D
+ $D_HI $D_HI Q_E $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ $D_HI CLRBAR Q_E
+ $D_HI $D_HI Q_F $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ $D_HI CLRBAR Q_F
+ $D_HI $D_HI Q_G $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 PINDLY(7,0,2) DPWR DGND
+ Q_A Q_B Q_C Q_D Q_E Q_F Q_G
+ CLR CLOCKA
+ QA QB QC QD QE QF QG
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_LH(CLR,0)}
+          ACLK = {CHANGED_HL(CLOCKA,0)}
+ PINDLY:
+          QA = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,16NS,24NS),
+               DELAY(-1,18NS,27NS))}
+          QB = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,24NS,39NS),
+               DELAY(-1,25NS,40NS))}
+          QC = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,32NS,54NS),
+               DELAY(-1,33NS,55NS))}
+          QD = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,40NS,69NS),
+               DELAY(-1,41NS,70NS))}
+          QE = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,48NS,84NS),
+               DELAY(-1,49NS,85NS))}
+          QF = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,56NS,99NS),
+               DELAY(-1,57NS,100NS))}
+          QG = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,17NS,26NS),
+               ACLK & (TRN_LH | TRN_HL), DELAY(-1,64NS,114NS),
+               DELAY(-1,65NS,115NS))}

U10 CONSTRAINT(2) DPWR DGND
+ CLK CLR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = CLK
+             DATA(1) = CLR
+             SETUPTIME_LO = 20NS
+ WIDTH:
+             NODE = CLK
+             MIN_HI = 23NS
+             MIN_LO = 23NS
+ WIDTH:
+             NODE = CLR
+             MIN_HI = 20NS
+ FREQ:
+             NODE = CLK
+             MAXFREQ = 22MEG

.ENDS 74HC4024

*---------------------------------------------------74HCT4024-------------

* 7-Stage Binary Ripple Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 825 to 829
* jat 9/17/96

.SUBCKT 74HCT4024
+ CPBAR MR Q0 Q1 Q2 Q3 Q4 Q5 Q6
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U0 BUF DPWR DGND
+ CPBAR CPBARST
+ D0_GATE IO_HCT_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U1 LOGICEXP(1,1) DPWR DGND
+ MR MRBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  MRBAR = {~MR}

U2 JKFF(1) DPWR DGND 
+ $D_HI MRBAR CPBARST
+ $D_HI $D_HI Q0O Q0BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND 
+ $D_HI MRBAR Q0O
+ $D_HI $D_HI Q1O Q1BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND 
+ $D_HI MRBAR Q1O
+ $D_HI $D_HI Q2O Q2BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND 
+ $D_HI MRBAR Q2O
+ $D_HI $D_HI Q3O Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND 
+ $D_HI MRBAR Q3O
+ $D_HI $D_HI Q4O Q4BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND 
+ $D_HI MRBAR Q4O
+ $D_HI $D_HI Q5O Q5BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND 
+ $D_HI MRBAR Q5O
+ $D_HI $D_HI Q6O Q6BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 PINDLY(7,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O Q6O
+ MR CPBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_LH(MR,0)}
+          CLK = {CHANGED_HL(CPBAR,0)}
+ PINDLY:
+          Q0 = {
+            CASE(
+               CLEAR & TRN_HL, DELAY(-1,21NS,40NS),
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,17NS,35NS),
+               DELAY(-1,22NS,41NS))}
+          Q1 = {
+            CASE(
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,26NS,51NS),
+               DELAY(-1,27NS,52NS))}
+          Q2 = {
+            CASE(
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,35NS,67NS),
+               DELAY(-1,36NS,68NS))}
+          Q3 = {
+            CASE(
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,44NS,83NS),
+               DELAY(-1,45NS,84NS))}
+          Q4 = {
+            CASE(
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,53NS,99NS),
+               DELAY(-1,54NS,100NS))}
+          Q5 = {
+            CASE(
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,62NS,115NS),
+               DELAY(-1,63NS,116NS))}
+          Q6 = {
+            CASE(
+               CLK & (TRN_LH | TRN_HL), DELAY(-1,71NS,131NS),
+               DELAY(-1,72NS,132NS))}

U10 CONSTRAINT(2) DPWR DGND
+ CPBAR MR
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ WIDTH:
+             NODE = CPBAR
+             MIN_HI = 9NS
+             MIN_LO = 9NS
+ WIDTH:
+             NODE = MR
+             MIN_HI = 6NS
+ FREQ:
+             NODE = CPBAR
+             MAXFREQ = 64MEG

.ENDS 74HCT4024

*---------------------------------------------------------74AC4040-------

* The 74AC4040 12 Stage Binary Ripple Counter
* Motorola FACT Data, 1993, pages 5-395 to 5-398 with logic from the 74HC4040
* jat 8/10/95

.SUBCKT 74AC4040
+ RESET CLK Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(1,1) DPWR DGND
+ RESET
+ RESETBAR
+ D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        RESETBAR = {~RESET}

U2 JKFF(1) DPWR DGND
+ $D_HI RESETBAR CLK
+ $D_HI $D_HI Q_1 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_1
+ $D_HI $D_HI Q_2 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_2
+ $D_HI $D_HI Q_3 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_3
+ $D_HI $D_HI Q_4 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_4
+ $D_HI $D_HI Q_5 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_5
+ $D_HI $D_HI Q_6 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_6
+ $D_HI $D_HI Q_7 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_7
+ $D_HI $D_HI Q_8 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_8
+ $D_HI $D_HI Q_9 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_9
+ $D_HI $D_HI Q_10 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_10
+ $D_HI $D_HI Q_11 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_11
+ $D_HI $D_HI Q_12 $D_NC
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 PINDLY(12,0,2) DPWR DGND
+ Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7 Q_8 Q_9 Q_10 Q_11 Q_12
+ RESET CLK
+ Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12
+ IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_LH(RESET,0)}
+          ACLK = {CHANGED_HL(CLK,0)}
+ PINDLY:
+          Q1 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,8NS),
+              DELAY(4NS,-1,11NS))}
+          Q2 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,11.5NS),
+              DELAY(4NS,-1,12.5NS))}
+          Q3 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,15NS),
+              DELAY(4NS,-1,16NS))}
+          Q4 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,18.5NS),
+              DELAY(4NS,-1,19.5NS))}
+          Q5 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,22NS),
+              DELAY(4NS,-1,23NS))}
+          Q6 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,25.5NS),
+              DELAY(4NS,-1,26.5NS))}
+          Q7 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,29NS),
+              DELAY(4NS,-1,30NS))}
+          Q8 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,32.5NS),
+              DELAY(4NS,-1,33.5NS))}
+          Q9 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,36NS),
+              DELAY(4NS,-1,37NS))}
+          Q10 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,39.5NS),
+              DELAY(4NS,-1,40.5NS))}
+          Q11 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,43NS),
+              DELAY(4NS,-1,44NS))}
+          Q12 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(3NS,-1,10NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(2NS,-1,46.5NS),
+              DELAY(4NS,-1,47.5NS))}

U15 CONSTRAINT(2) DPWR DGND
+ CLK RESET
+ IO_AC IO_LEVEL={IO_LEVEL}
+ WIDTH:
+             NODE = CLK
+             MIN_HI = 3.5NS
+             MIN_LO = 3.5NS
+ WIDTH:
+             NODE = RESET
+             MIN_HI = 3.5NS
+ FREQ:
+             NODE = CLK
+             MAXFREQ = 120MEG

.ENDS 74AC4040

*---------------------------------------------------------74HC4040-------

* The 74HC4040 Asynchronous 12 Bit Binary Counter
* TI High Speed CMOS Logic Data Book, 1989, pages 2-639 to 2-642
* jat 8/10/95

.SUBCKT 74HC4040
+ CLR CLK QA QB QC QD QE QF QG QH QI QJ QK QL
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(1,1) DPWR DGND
+ CLR
+ RESETBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        RESETBAR = {~CLR}

U2 JKFF(1) DPWR DGND
+ $D_HI RESETBAR CLK
+ $D_HI $D_HI Q_A $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_A
+ $D_HI $D_HI Q_B $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_B
+ $D_HI $D_HI Q_C $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_C
+ $D_HI $D_HI Q_D $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_D
+ $D_HI $D_HI Q_E $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_E
+ $D_HI $D_HI Q_F $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_F
+ $D_HI $D_HI Q_G $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_G
+ $D_HI $D_HI Q_H $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_H
+ $D_HI $D_HI Q_I $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_I
+ $D_HI $D_HI Q_J $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_J
+ $D_HI $D_HI Q_K $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_K
+ $D_HI $D_HI Q_L $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 PINDLY(12,0,2) DPWR DGND
+ Q_A Q_B Q_C Q_D Q_E Q_F Q_G Q_H Q_I Q_J Q_K Q_L
+ CLR CLK
+ QA QB QC QD QE QF QG QH QI QJ QK QL
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_LH(CLR,0)}
+          ACLK = {CHANGED_HL(CLK,0)}
+ PINDLY:
+          QA = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,16NS,30NS),
+              DELAY(-1,17NS,31NS))}
+          QB = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,24NS,45NS),
+              DELAY(-1,25NS,46NS))}
+          QC = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,32NS,60NS),
+              DELAY(-1,33NS,61NS))}
+          QD = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,40NS,75NS),
+              DELAY(-1,41NS,76NS))}
+          QE = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,48NS,90NS),
+              DELAY(-1,49NS,91NS))}
+          QF = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,56NS,105NS),
+              DELAY(-1,57NS,106NS))}
+          QG = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,64NS,120NS),
+              DELAY(-1,65NS,121NS))}
+          QH = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,72NS,135NS),
+              DELAY(-1,73NS,136NS))}
+          QI = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,80NS,150NS),
+              DELAY(-1,81NS,151NS))}
+          QJ = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,88NS,165NS),
+              DELAY(-1,89NS,166NS))}
+          QK = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,96NS,180NS),
+              DELAY(-1,97NS,181NS))}
+          QL = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,17NS,28NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,104NS,195NS),
+              DELAY(-1,105NS,196NS))}

U15 CONSTRAINT(2) DPWR DGND
+ CLK CLR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = CLK
+             DATA(1) = CLR
+             SETUPTIME_LO = 15NS
+ WIDTH:
+             NODE = CLK
+             MIN_HI = 23NS
+             MIN_LO = 23NS
+ WIDTH:
+             NODE = CLR
+             MIN_HI = 18NS
+ FREQ:
+             NODE = CLK
+             MAXFREQ = 22MEG

.ENDS 74HC4040

*---------------------------------------------------------74HCT4040-------

* The 74HCT4040 12 Bit Binary Ripple Counter
* Philips High Speed CMOS Logic Data Handbook, 1994, pages 831 to 835
* jat 8/10/95

.SUBCKT 74HCT4040
+ MR CPBAR Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(1,1) DPWR DGND
+ MR
+ RESETBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        RESETBAR = {~MR}

U2 JKFF(1) DPWR DGND
+ $D_HI RESETBAR CPBAR
+ $D_HI $D_HI Q_0 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_0
+ $D_HI $D_HI Q_1 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_1
+ $D_HI $D_HI Q_2 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_2
+ $D_HI $D_HI Q_3 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_3
+ $D_HI $D_HI Q_4 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_4
+ $D_HI $D_HI Q_5 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_5
+ $D_HI $D_HI Q_6 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_6
+ $D_HI $D_HI Q_7 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_7
+ $D_HI $D_HI Q_8 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_8
+ $D_HI $D_HI Q_9 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U12 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_9
+ $D_HI $D_HI Q_10 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U13 JKFF(1) DPWR DGND
+ $D_HI RESETBAR Q_10
+ $D_HI $D_HI Q_11 $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U14 PINDLY(12,0,2) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7 Q_8 Q_9 Q_10 Q_11
+ MR CPBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          CLEAR = {CHANGED_LH(MR,0)}
+          ACLK = {CHANGED_HL(CPBAR,0)}
+ PINDLY:
+          Q0 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,19NS,40NS),
+              DELAY(-1,24NS,46NS))}
+          Q1 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,29NS,60NS),
+              DELAY(-1,30NS,61NS))}
+          Q2 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,39NS,80NS),
+              DELAY(-1,40NS,81NS))}
+          Q3 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,49NS,100NS),
+              DELAY(-1,50NS,101NS))}
+          Q4 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,59NS,120NS),
+              DELAY(-1,60NS,121NS))}
+          Q5 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,69NS,140NS),
+              DELAY(-1,70NS,141NS))}
+          Q6 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,79NS,160NS),
+              DELAY(-1,80NS,161NS))}
+          Q7 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,89NS,180NS),
+              DELAY(-1,90NS,181NS))}
+          Q8 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,99NS,200NS),
+              DELAY(-1,100NS,201NS))}
+          Q9 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,109NS,220NS),
+              DELAY(-1,110NS,221NS))}
+          Q10 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,119NS,240NS),
+              DELAY(-1,120NS,241NS))}
+          Q11 = {
+            CASE(
+              CLEAR & TRN_HL, DELAY(-1,23NS,45NS),
+              ACLK & (TRN_LH | TRN_HL), DELAY(-1,129NS,260NS),
+              DELAY(-1,130NS,261NS))}

U15 CONSTRAINT(2) DPWR DGND
+ CPBAR MR
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = CPBAR
+             DATA(1) = MR
+             SETUPTIME_LO = 13NS
+ WIDTH:
+             NODE = CPBAR
+             MIN_HI = 20NS
+             MIN_LO = 20NS
+ WIDTH:
+             NODE = MR
+             MIN_HI = 20NS
+ FREQ:
+             NODE = CPBAR
+             MAXFREQ = 24MEG

.ENDS 74HCT4040

*-----------------------------------------------------------74HC4060------

* Asynchronous 14-Stage Binary Counter and Oscillator
* TI High-Speed CMOS Logic Data Book, 1989, pages 2-643 to 2-646
* jat 12/29/95

.SUBCKT 74HC4060 CLR CKI QD QE QF QG QH QI QJ QL QM QN CKOBAR CKO
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,4) DPWR DGND
+ CLR CKI
+ CLKA CKOO CKOBARO CLRBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLRBAR = {~CLR}
+   CLKA = {~(CLRBAR & CKI)}
+   CKOO = {CKI & CLRBAR}
+   CKOBARO = {~CKOO}

U2 BUF DPWR DGND
+ CLKA CLKAST
+ D0_GATE IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UA JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLKAST
+ $D_HI $D_HI QAO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UB JKFF(1) DPWR DGND
+ $D_HI CLRBAR QAO
+ $D_HI $D_HI QBO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UC JKFF(1) DPWR DGND
+ $D_HI CLRBAR QBO
+ $D_HI $D_HI QCO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UD JKFF(1) DPWR DGND
+ $D_HI CLRBAR QCO
+ $D_HI $D_HI QDO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UE JKFF(1) DPWR DGND
+ $D_HI CLRBAR QDO
+ $D_HI $D_HI QEO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UF JKFF(1) DPWR DGND
+ $D_HI CLRBAR QEO
+ $D_HI $D_HI QFO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UG JKFF(1) DPWR DGND
+ $D_HI CLRBAR QFO
+ $D_HI $D_HI QGO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UH JKFF(1) DPWR DGND
+ $D_HI CLRBAR QGO
+ $D_HI $D_HI QHO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UI JKFF(1) DPWR DGND
+ $D_HI CLRBAR QHO
+ $D_HI $D_HI QIO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UJ JKFF(1) DPWR DGND
+ $D_HI CLRBAR QIO
+ $D_HI $D_HI QJO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UK JKFF(1) DPWR DGND
+ $D_HI CLRBAR QJO
+ $D_HI $D_HI QKO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UL JKFF(1) DPWR DGND
+ $D_HI CLRBAR QKO
+ $D_HI $D_HI QLO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UM JKFF(1) DPWR DGND
+ $D_HI CLRBAR QLO
+ $D_HI $D_HI QMO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UN JKFF(1) DPWR DGND
+ $D_HI CLRBAR QMO
+ $D_HI $D_HI QNO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(12,0,11) DPWR DGND
+ QDO QEO QFO QGO QHO QIO QJO QLO QMO QNO CKOO CKOBARO
+ CLR QCO QDO QEO QFO QGO QHO QIO QKO QLO QMO
+ QD QE QF QG QH QI QJ QL QM QN CKO CKOBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_LH(CLR,0)}
+ PINDLY:
+    QD = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QCO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QE = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QDO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QF = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QEO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QG = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QFO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QH = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QGO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QI = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QHO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QJ = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QIO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QL = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QKO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QM = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QLO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QN = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QMO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    CKO CKOBAR = {
+      CASE(
+         DELAY(-1,15.5NS,25.5NS))}

U4 CONSTRAINT(2) DPWR DGND
+ CKI CLR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CKI
+   MAXFREQ = 28MEG
+ WIDTH:
+   NODE = CKI
+   MIN_LO = 18NS
+   MIN_HI = 18NS
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 18NS
+ SETUP_HOLD:
+   CLOCK HL = CKI
+   DATA(1) = CLR
+   SETUPTIME_LO = 32NS

.ENDS 74HC4060

*-----------------------------------------------------------74HC4061------

* Asynchronous 14-Stage Binary Counter and Oscillator
* TI High-Speed CMOS Logic Data Book, 1989, pages 2-647 to 2-650
* jat 12/29/95

.SUBCKT 74HC4061 CLR CKI QD QE QF QG QH QI QJ QL QM QN CKOBAR CKO
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,2) DPWR DGND
+ CLR CKI
+ CKOBARO CLRBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLRBAR = {~CLR}
+   CKOBARO = {~CKI}

U2 BUF DPWR DGND
+ CKOBARO CLKAST
+ D0_GATE IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UA JKFF(1) DPWR DGND
+ $D_HI CLRBAR CLKAST
+ $D_HI $D_HI QAO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UB JKFF(1) DPWR DGND
+ $D_HI CLRBAR QAO
+ $D_HI $D_HI QBO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UC JKFF(1) DPWR DGND
+ $D_HI CLRBAR QBO
+ $D_HI $D_HI QCO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UD JKFF(1) DPWR DGND
+ $D_HI CLRBAR QCO
+ $D_HI $D_HI QDO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UE JKFF(1) DPWR DGND
+ $D_HI CLRBAR QDO
+ $D_HI $D_HI QEO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UF JKFF(1) DPWR DGND
+ $D_HI CLRBAR QEO
+ $D_HI $D_HI QFO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UG JKFF(1) DPWR DGND
+ $D_HI CLRBAR QFO
+ $D_HI $D_HI QGO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UH JKFF(1) DPWR DGND
+ $D_HI CLRBAR QGO
+ $D_HI $D_HI QHO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UI JKFF(1) DPWR DGND
+ $D_HI CLRBAR QHO
+ $D_HI $D_HI QIO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UJ JKFF(1) DPWR DGND
+ $D_HI CLRBAR QIO
+ $D_HI $D_HI QJO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UK JKFF(1) DPWR DGND
+ $D_HI CLRBAR QJO
+ $D_HI $D_HI QKO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UL JKFF(1) DPWR DGND
+ $D_HI CLRBAR QKO
+ $D_HI $D_HI QLO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UM JKFF(1) DPWR DGND
+ $D_HI CLRBAR QLO
+ $D_HI $D_HI QMO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

UN JKFF(1) DPWR DGND
+ $D_HI CLRBAR QMO
+ $D_HI $D_HI QNO $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(12,0,11) DPWR DGND
+ QDO QEO QFO QGO QHO QIO QJO QLO QMO QNO CKI CKOBARO
+ CLR QCO QDO QEO QFO QGO QHO QIO QKO QLO QMO
+ QD QE QF QG QH QI QJ QL QM QN CKO CKOBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_LH(CLR,0)}
+ PINDLY:
+    QD = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QCO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QE = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QDO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QF = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QEO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QG = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QFO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QH = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QGO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QI = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QHO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QJ = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QIO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QL = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QKO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QM = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QLO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    QN = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,18NS,28NS),
+        CHANGED_HL(QMO,0) & (TRN_LH | TRN_HL), DELAY(-1,14.5NS,24.5NS),
+        DELAY(-1,15.5NS,25.5NS))}
+    CKO CKOBAR = {
+      CASE(
+         DELAY(-1,15.5NS,25.5NS))}

U4 CONSTRAINT(2) DPWR DGND
+ CKI CLR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CKI
+   MAXFREQ = 28MEG
+ WIDTH:
+   NODE = CKI
+   MIN_LO = 18NS
+   MIN_HI = 18NS
+ WIDTH:
+   NODE = CLR
+   MIN_HI = 18NS
+ SETUP_HOLD:
+   CLOCK HL = CKI
+   DATA(1) = CLR
+   SETUPTIME_LO = 32NS

.ENDS 74HC4061

*-----------------------------------------------------------74HC4075------

* The 74HC4075 3 Input OR Gate
* TI High Speed CMOS Logic Data Book, 1989, pages 2-659 to 2-661
* jat 8/10/95

.SUBCKT 74HC4075
+ 1A 1B 1C 1Y
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 OR(3) DPWR DGND
+ 1A 1B 1C
+ 1Y
+ DLYOR IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLYOR UGATE(TPLHTY=11NS TPHLTY=11NS TPLHMX=20NS TPHLMX=20NS)

.ENDS 74HC4075

*-----------------------------------------------------------74HCT4075------

* Triple 3 Input OR Gate
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 961 to 963
* jat 9/17/96

.SUBCKT 74HCT4075
+ 1A 1B 1C 1Y
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 OR(3) DPWR DGND
+ 1A 1B 1C
+ 1Y
+ DLY_HCT4075 IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT4075 UGATE(TPLHTY=12NS TPHLTY=12NS TPLHMX=24NS TPHLMX=24NS)

.ENDS 74HCT4075

*----------------------------------------------------------74HC4078-----

* 8 Input OR/NOR Gate
* Motorola High-Speed CMOS Data, 1993, pages 5-508 to 5-511
* jat 9/12/96

.SUBCKT 74HC4078
+ A B C D E F G H Y X
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 NOR(8) DPWR DGND
+ A B C D E F G H
+ Y
+ DLY_HC4078Y IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 OR(8) DPWR DGND
+ A B C D E F G H
+ X
+ DLY_HC4078X IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC4078X UGATE(TPLHMX=28NS TPHLMX=28NS)

.MODEL DLY_HC4078Y UGATE(TPLHMX=26NS TPHLMX=26NS)

.ENDS 74HC4078

*----------------------------------------------------------74HC4078A-----

* The 74HC4078A 8 Input OR/NOR Gate
* TI High Speed CMOS Logic Data Book, 1989, pages 2-663 to 2-665
* jat 8/10/95

.SUBCKT 74HC4078A
+ A B C D E F G H W Y
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(8,2) DPWR DGND
+ A B C D E F G H
+ Y W
+ DLY IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        Y = {A | B | C | D | E | F | G | H}
+        W = {~(A | B | C | D | E | F | G | H)}

.MODEL DLY UGATE(TPLHTY=12NS TPHLTY=12NS TPLHMX=26NS TPHLMX=26NS)

.ENDS 74HC4078A

*------------------------------------------------------------74HC4094-------

* 8-Stage Shift and Store Bus Register
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 965 to 970
* jat 9/17/96

.SUBCKT 74HC4094 CP D STR OE QS1 QS2 QP0 QP1 QP2 QP3 QP4 QP5 QP6 QP7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U0 LOGICEXP(1,1) DPWR DGND
+ CP CPBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CPBAR = {~CP}

U1 DFF(8) DPWR DGND
+ $D_HI $D_HI CP
+ D Q0 Q1 Q2 Q3 Q4 Q5 Q6
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(1) DPWR DGND
+ $D_HI $D_HI CPBAR
+ Q7 QS2O $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(8) DPWR DGND
+ $D_HI $D_HI STR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ QP0O QP1O QP2O QP3O QP4O QP5O QP6O QP7O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(10,1,2) DPWR DGND
+ Q7 QS2O QP0O QP1O QP2O QP3O QP4O QP5O QP6O QP7O
+ OE
+ CP STR
+ QS1 QS2 QP0 QP1 QP2 QP3 QP4 QP5 QP6 QP7
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SHIFTEDGE = {CHANGED_LH(CP,0)}
+   SHIFTEDGEDOWN = {CHANGED_HL(CP,0)}
+   STOREEDGE = {CHANGED_LH(STR,0)}
+ TRISTATE:
+   ENABLE HI = OE
+   QP0 QP1 QP2 QP3 QP4 QP5 QP6 QP7 = {
+     CASE(
+      TRN_Z$, DELAY(-1,20NS,35NS),
+      TRN_$Z, DELAY(-1,15NS,25NS),
+      STOREEDGE & (TRN_LH | TRN_HL), DELAY(-1,21NS,36NS),
+      SHIFTEDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,39NS),
+      DELAY(-1,24NS,40NS))}
+ PINDLY:
+   QS1 = {
+    CASE(
+      SHIFTEDGE & (TRN_LH | TRN_HL), DELAY(-1,18NS,30NS),
+      DELAY(-1,19NS,31NS))}
+   QS2 = {
+    CASE(
+      SHIFTEDGEDOWN & (TRN_LH | TRN_HL), DELAY(-1,16NS,27NS),
+      DELAY(-1,17NS,28NS))}

U5 CONSTRAINT(3) DPWR DGND
+ CP STR D
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 87MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 5NS
+   MIN_LO = 5NS
+ WIDTH:
+   NODE = STR
+   MIN_HI = 5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = D
+   SETUPTIME = 5NS
+ SETUP_HOLD:
+   CLOCK HL = STR
+   DATA(1) = CP
+   SETUPTIME_LO = 10NS
+   SETUPTIME_HI = 10NS

.ENDS 74HC4094

*------------------------------------------------------------74HCT4094-------

* 8-Stage Shift and Store Bus Register
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 965 to 970
* jat 9/17/96

.SUBCKT 74HCT4094 CP D STR OE QS1 QS2 QP0 QP1 QP2 QP3 QP4 QP5 QP6 QP7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U0 LOGICEXP(1,1) DPWR DGND
+ CP CPBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CPBAR = {~CP}

U1 DFF(8) DPWR DGND
+ $D_HI $D_HI CP
+ D Q0 Q1 Q2 Q3 Q4 Q5 Q6
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(1) DPWR DGND
+ $D_HI $D_HI CPBAR
+ Q7 QS2O $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(8) DPWR DGND
+ $D_HI $D_HI STR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ QP0O QP1O QP2O QP3O QP4O QP5O QP6O QP7O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_GFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(10,1,2) DPWR DGND
+ Q7 QS2O QP0O QP1O QP2O QP3O QP4O QP5O QP6O QP7O
+ OE
+ CP STR
+ QS1 QS2 QP0 QP1 QP2 QP3 QP4 QP5 QP6 QP7
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SHIFTEDGE = {CHANGED_LH(CP,0)}
+   SHIFTEDGEDOWN = {CHANGED_HL(CP,0)}
+   STOREEDGE = {CHANGED_LH(STR,0)}
+ TRISTATE:
+   ENABLE HI = OE
+   QP0 QP1 QP2 QP3 QP4 QP5 QP6 QP7 = {
+     CASE(
+      TRN_Z$, DELAY(-1,20NS,35NS),
+      TRN_$Z, DELAY(-1,21NS,35NS),
+      STOREEDGE & (TRN_LH | TRN_HL), DELAY(-1,22NS,39NS),
+      SHIFTEDGE & (TRN_LH | TRN_HL), DELAY(-1,25NS,43NS),
+      DELAY(-1,26NS,44NS))}
+ PINDLY:
+   QS1 = {
+    CASE(
+      SHIFTEDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,39NS),
+      DELAY(-1,24NS,40NS))}
+   QS2 = {
+    CASE(
+      SHIFTEDGEDOWN & (TRN_LH | TRN_HL), DELAY(-1,21NS,36NS),
+      DELAY(-1,22NS,37NS))}

U5 CONSTRAINT(3) DPWR DGND
+ CP STR D
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 80MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 7NS
+   MIN_LO = 7NS
+ WIDTH:
+   NODE = STR
+   MIN_HI = 5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = D
+   SETUPTIME = 4NS
+ SETUP_HOLD:
+   CLOCK HL = STR
+   DATA(1) = CP
+   SETUPTIME_LO = 9NS
+   SETUPTIME_HI = 9NS

.ENDS 74HCT4094

*-----------------------------------------------------------74HC4510------

* BCD Up/Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1027 to 1035
* jat 9/17/96

.SUBCKT 74HC4510 CP UP/DNBAR CEBAR MR PL D0 D1 D2 D3 Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,13) DPWR DGND
+ CEBAR PL UP/DNBAR D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR MR
+ DATA0 DATA1 DATA2 DATA3 TCBARO SET0 CLR0 SET1 CLR1 SET2 CLR2 SET3 CLR3
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~CEBAR}
+  X1 = {~(Q0BAR & CE)}
+  X2 = {~(Q2BAR & Q3BAR)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q0BAR & CE)}
+  X7 = {~(Q0O & CE)}
+  DATA0 = {(~PL & ~CE & Q0O) | (CE & ~PL & Q0BAR)}
+  DATA1 = {(X1 & ~PL & Q1O & ~UP/DNBAR) | (Q1BAR & X2 & ~UP/DNBAR & ~PL & Q0BAR & CE)
+      | (~PL & UP/DNBAR & CE & ((Q3BAR & Q1BAR & Q0O) | (Q3O & Q1O) | (Q1O & Q0BAR)))}
+  DATA2 = {(X4 & ~PL & UP/DNBAR & Q2O) | (UP/DNBAR & ~PL & Q2BAR & Q1O & Q0O & CE) |
+        (~UP/DNBAR & CE & ~PL & ((Q2O & Q0O) | (Q3O & Q2BAR & Q0BAR) |
+        (Q3BAR & Q2O & Q1O)))}
+  DATA3 = {(~UP/DNBAR & ~PL & CE & ((Q3O & Q0O) | (Q3O & Q2BAR & Q1O) | (Q0BAR & Q1BAR & Q2BAR & Q3BAR))) |
+        (Q3O & X7 & ~PL & UP/DNBAR) |
+        (Q3BAR & UP/DNBAR & CE & ~PL & Q0O & Q1O & Q2O)}
+  TCBARO = {~((~UP/DNBAR & ~CEBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (UP/DNBAR & ~CEBAR & Q0O & Q3O))}
+  SET0 = {MR | ~(PL & D0)}
+  CLR0 = {~MR & ~(PL & ~D0)}
+  SET1 = {MR | ~(PL & D1)}
+  CLR1 = {~MR & ~(PL & ~D1)}
+  SET2 = {MR | ~(PL & D2)}
+  CLR2 = {~MR & ~(PL & ~D2)}
+  SET3 = {MR | ~(PL & D3)}
+  CLR3 = {~MR & ~(PL & ~D3)}

U2 DFF(1) DPWR DGND
+ SET0 CLR0 CP
+ DATA0 Q0O Q0BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ SET1 CLR1 CP
+ DATA1 Q1O Q1BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+ SET2 CLR2 CP
+ DATA2 Q2O Q2BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+ SET3 CLR3 CP
+ DATA3 Q3O Q3BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,4) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP MR PL CEBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  COUNT = {CHANGED_HL(CEBAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+  LOAD = {CHANGED_LH(PL,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,23NS,42NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,28NS,50NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,25NS,44NS),
+      DELAY(-1,29NS,51NS))}
+  TCBAR = {
+    CASE(
+      CLEAR & TRN_LH, DELAY(-1,25NS,47NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,33NS,60NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,13NS,25NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,27NS,52NS),
+      DELAY(-1,34NS,61NS))}

U7 CONSTRAINT(9) DPWR DGND
+ CP CEBAR PL MR D0 D1 D2 D3 UP/DNBAR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 52MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = CEBAR
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = PL
+  MIN_HI = 8NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MR
+  SETUPTIME_LO = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PL
+  SETUPTIME_LO = 5NS
+ SETUP_HOLD:
+  CLOCK LH = PL
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = CEBAR
+  SETUPTIME = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = UP/DNBAR
+  SETUPTIME = 11NS

.ENDS 74HC4510

*-----------------------------------------------------------74HCT4510------

* BCD Up/Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1027 to 1035
* jat 9/17/96

.SUBCKT 74HCT4510 CP UP/DNBAR CEBAR MR PL D0 D1 D2 D3 Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,13) DPWR DGND
+ CEBAR PL UP/DNBAR D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR MR
+ DATA0 DATA1 DATA2 DATA3 TCBARO SET0 CLR0 SET1 CLR1 SET2 CLR2 SET3 CLR3
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~CEBAR}
+  X1 = {~(Q0BAR & CE)}
+  X2 = {~(Q2BAR & Q3BAR)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q0BAR & CE)}
+  X7 = {~(Q0O & CE)}
+  DATA0 = {(~PL & ~CE & Q0O) | (CE & ~PL & Q0BAR)}
+  DATA1 = {(X1 & ~PL & Q1O & ~UP/DNBAR) | (Q1BAR & X2 & ~UP/DNBAR & ~PL & Q0BAR & CE)
+      | (~PL & UP/DNBAR & CE & ((Q3BAR & Q1BAR & Q0O) | (Q3O & Q1O) | (Q1O & Q0BAR)))}
+  DATA2 = {(X4 & ~PL & UP/DNBAR & Q2O) | (UP/DNBAR & ~PL & Q2BAR & Q1O & Q0O & CE) |
+        (~UP/DNBAR & CE & ~PL & ((Q2O & Q0O) | (Q3O & Q2BAR & Q0BAR) |
+        (Q3BAR & Q2O & Q1O)))}
+  DATA3 = {(~UP/DNBAR & ~PL & CE & ((Q3O & Q0O) | (Q3O & Q2BAR & Q1O) | (Q0BAR & Q1BAR & Q2BAR & Q3BAR))) |
+        (Q3O & X7 & ~PL & UP/DNBAR) |
+        (Q3BAR & UP/DNBAR & CE & ~PL & Q0O & Q1O & Q2O)}
+  TCBARO = {~((~UP/DNBAR & ~CEBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (UP/DNBAR & ~CEBAR & Q0O & Q3O))}
+  SET0 = {MR | ~(PL & D0)}
+  CLR0 = {~MR & ~(PL & ~D0)}
+  SET1 = {MR | ~(PL & D1)}
+  CLR1 = {~MR & ~(PL & ~D1)}
+  SET2 = {MR | ~(PL & D2)}
+  CLR2 = {~MR & ~(PL & ~D2)}
+  SET3 = {MR | ~(PL & D3)}
+  CLR3 = {~MR & ~(PL & ~D3)}

U2 DFF(1) DPWR DGND
+ SET0 CLR0 CP
+ DATA0 Q0O Q0BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ SET1 CLR1 CP
+ DATA1 Q1O Q1BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+ SET2 CLR2 CP
+ DATA2 Q2O Q2BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+ SET3 CLR3 CP
+ DATA3 Q3O Q3BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,4) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP MR PL CEBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  COUNT = {CHANGED_HL(CEBAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+  LOAD = {CHANGED_LH(PL,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,25NS,42NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,28NS,53NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,27NS,50NS),
+      DELAY(-1,29NS,54NS))}
+  TCBAR = {
+    CASE(
+      CLEAR & TRN_LH, DELAY(-1,31NS,50NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,35NS,68NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,17NS,31NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,29NS,58NS),
+      DELAY(-1,36NS,69NS))}

U7 CONSTRAINT(9) DPWR DGND
+ CP CEBAR PL MR D0 D1 D2 D3 UP/DNBAR
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 53MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = CEBAR
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = PL
+  MIN_HI = 6NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MR
+  SETUPTIME_LO = 13NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PL
+  SETUPTIME_LO = 10NS
+ SETUP_HOLD:
+  CLOCK LH = PL
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = CEBAR
+  SETUPTIME = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = UP/DNBAR
+  SETUPTIME = 12NS

.ENDS 74HCT4510

*-----------------------------------------------------------74HC4511------

* BCD to 7-Segment Latch/Decoder/Driver
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1037 to 1043
* jat 9/17/96

.SUBCKT 74HC4511 D1 D2 D3 D4 LTBAR BIBAR LEBAR QA QB QC QD QE QF QG
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,8) DPWR DGND
+ LEBAR BIBAR LTBAR Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ LE QAO QBO QCO QDO QEO QFO QGO
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  LE = {~LEBAR}
+  NAND1 = {~(Q4BAR & Q3BAR & Q2BAR & Q1BAR)}
+  NAND2 = {~(Q3 & Q2 & Q1)}
+  NAND3 = {~(Q3BAR & Q2)}
+  NAND4 = {~(Q1 & Q2BAR & Q3BAR & Q4BAR)}
+  NAND5 = {(Q2BAR & Q3BAR)}
+  NOR = {~(~BIBAR | (~(NAND5 | Q4BAR)))}
+  NAND6 = {~(Q1 & Q2BAR & Q3BAR)}
+  NAND7 = {~(Q1BAR & Q2 & Q3BAR)}
+  NAND8 = {~(Q1BAR & Q2BAR & Q3)}
+  NAND9 = {~(Q1 & Q2BAR & Q3)}
+  NAND10 = {~(Q1BAR & Q2 & Q3)}
+  QAO = {~(LTBAR & (~(NOR & NAND4 & NAND8 & NAND10)))}
+  QBO = {~(LTBAR & (~(NOR & NAND9 & NAND10)))}
+  QCO = {~(LTBAR & (~(NOR & NAND7)))}
+  QDO = {~(LTBAR & (~(NOR & NAND2 & NAND8 & NAND6)))}
+  QEO = {~(LTBAR & (~(NOR & Q1BAR & NAND8)))}
+  QFO = {~(LTBAR & (~(NOR & NAND2 & NAND3 & NAND4)))}
+  QGO = {~(LTBAR & (~(NOR & NAND2 & NAND1 & NAND4)))}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+ D1 D2 D3 D4
+ Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,7) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO
+ D4 D1 D2 D3 LEBAR BIBAR LTBAR
+ QA QB QC QD QE QF QG
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED_HL(LEBAR,0)}
+   BLANK = {CHANGED(BIBAR,0)}
+   LAMP = {CHANGED(LTBAR,0)}
+   DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D4,0)}
+ PINDLY:
+  QA QB QC QD QE QF QG = {
+    CASE(
+      LAMP & (TRN_LH | TRN_HL), DELAY(-1,15NS,30NS),
+      BLANK & (TRN_LH | TRN_HL), DELAY(-1,22NS,44NS),
+      LATCH & (TRN_LH | TRN_HL), DELAY(-1,27NS,54NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,28NS,60NS),
+      DELAY(-1,29NS,61NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LEBAR D1 D2 D3 D4
+ IO_HC IO_LEVEL={IO_LEVEL}
+ WIDTH:
+  NODE  = LEBAR
+  MIN_LO = 4NS
+ SETUP_HOLD:
+  CLOCK LH = LEBAR
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 5NS

.ENDS 74HC4511

*-----------------------------------------------------------74HCT4511------

* BCD to 7-Segment Latch/Decoder/Driver
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1037 to 1043
* jat 9/18/96

.SUBCKT 74HCT4511 D1 D2 D3 D4 LTBAR BIBAR LEBAR QA QB QC QD QE QF QG
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,8) DPWR DGND
+ LEBAR BIBAR LTBAR Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ LE QAO QBO QCO QDO QEO QFO QGO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  LE = {~LEBAR}
+  NAND1 = {~(Q4BAR & Q3BAR & Q2BAR & Q1BAR)}
+  NAND2 = {~(Q3 & Q2 & Q1)}
+  NAND3 = {~(Q3BAR & Q2)}
+  NAND4 = {~(Q1 & Q2BAR & Q3BAR & Q4BAR)}
+  NAND5 = {(Q2BAR & Q3BAR)}
+  NOR = {~(~BIBAR | (~(NAND5 | Q4BAR)))}
+  NAND6 = {~(Q1 & Q2BAR & Q3BAR)}
+  NAND7 = {~(Q1BAR & Q2 & Q3BAR)}
+  NAND8 = {~(Q1BAR & Q2BAR & Q3)}
+  NAND9 = {~(Q1 & Q2BAR & Q3)}
+  NAND10 = {~(Q1BAR & Q2 & Q3)}
+  QAO = {~(LTBAR & (~(NOR & NAND4 & NAND8 & NAND10)))}
+  QBO = {~(LTBAR & (~(NOR & NAND9 & NAND10)))}
+  QCO = {~(LTBAR & (~(NOR & NAND7)))}
+  QDO = {~(LTBAR & (~(NOR & NAND2 & NAND8 & NAND6)))}
+  QEO = {~(LTBAR & (~(NOR & Q1BAR & NAND8)))}
+  QFO = {~(LTBAR & (~(NOR & NAND2 & NAND3 & NAND4)))}
+  QGO = {~(LTBAR & (~(NOR & NAND2 & NAND1 & NAND4)))}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+ D1 D2 D3 D4
+ Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_GFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,7) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO
+ D4 D1 D2 D3 LEBAR BIBAR LTBAR
+ QA QB QC QD QE QF QG
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED_HL(LEBAR,0)}
+   BLANK = {CHANGED(BIBAR,0)}
+   LAMP = {CHANGED(LTBAR,0)}
+   DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D4,0)}
+ PINDLY:
+  QA QB QC QD QE QF QG = {
+    CASE(
+      LAMP & (TRN_LH | TRN_HL), DELAY(-1,16NS,30NS),
+      BLANK & (TRN_LH | TRN_HL), DELAY(-1,23NS,44NS),
+      LATCH & (TRN_LH | TRN_HL), DELAY(-1,27NS,54NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,28NS,60NS),
+      DELAY(-1,29NS,61NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LEBAR D1 D2 D3 D4
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ WIDTH:
+  NODE  = LEBAR
+  MIN_LO = 5NS
+ SETUP_HOLD:
+  CLOCK LH = LEBAR
+  DATA(4) = D1 D2 D3 D4
+  SETUPTIME = 5NS

.ENDS 74HCT4511

*--------------------------------------------------------74HC4514------

* The 74HC4514 4 Line to 16 Line Decoder/Demultiplexer with Address Latches
* TI High Speed CMOS Logic Data Book, 1989, pages 2-667 to 2-671
* with logic diagram from Motorola High Speed CMOS Data Book, 1993, page 5-544
* jat 8/10/95

.SUBCKT 74HC4514
+ A B C D LE GBAR Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,16) DPWR DGND
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR GBAR
+ Y_0 Y_1 Y_2 Y_3 Y_4 Y_5 Y_6 Y_7 Y_8 Y_9 Y_10 Y_11 Y_12 Y_13 Y_14 Y_15
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+       G = {~GBAR}
+       NOR0 = {~(QA | QB)}
+       NOR1 = {~(QABAR | QB)}
+       NOR2 = {~(QA | QBBAR)}
+       NOR3 = {~(QABAR | QBBAR)}
+       NOR4 = {~(QC | QD)}
+       NOR5 = {~(QCBAR | QD)}
+       NOR6 = {~(QC | QDBAR)}
+       NOR7 = {~(QCBAR | QDBAR)}
+       Y_0 = {NOR4 & NOR0 & G}
+       Y_1 = {NOR4 & NOR1 & G}
+       Y_2 = {NOR4 & NOR2 & G}
+       Y_3 = {NOR4 & NOR3 & G}
+       Y_4 = {NOR5 & NOR0 & G}
+       Y_5 = {NOR5 & NOR1 & G}
+       Y_6 = {NOR5 & NOR2 & G}
+       Y_7 = {NOR5 & NOR3 & G}
+       Y_8 = {NOR6 & NOR0 & G}
+       Y_9 = {NOR6 & NOR1 & G}
+       Y_10 = {NOR6 & NOR2 & G}
+       Y_11 = {NOR6 & NOR3 & G}
+       Y_12 = {NOR7 & NOR0 & G}
+       Y_13 = {NOR7 & NOR1 & G}
+       Y_14 = {NOR7 & NOR2 & G}
+       Y_15 = {NOR7 & NOR3 & G}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+ A B C D
+ QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,0,6) DPWR DGND
+ Y_0 Y_1 Y_2 Y_3 Y_4 Y_5 Y_6 Y_7 Y_8 Y_9 Y_10 Y_11 Y_12 Y_13 Y_14 Y_15
+ A B C D LE GBAR
+ Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     SELECT = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0)}
+     LATCH = {CHANGED_LH(LE,0)}
+     ENABLE = {CHANGED(GBAR,0)}
+ PINDLY:
+     Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 Y11 Y12 Y13 Y14 Y15 = {
+       CASE(
+          ENABLE & (TRN_LH | TRN_HL), DELAY(-1,18NS,35NS),
+          LATCH & (TRN_LH | TRN_HL), DELAY(-1,23NS,46NS),
+          SELECT & (TRN_LH | TRN_HL), DELAY(-1,23NS,46NS),
+          DELAY(-1,24NS,47NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LE A B C D
+ IO_HC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = LE
+             DATA(4) = A B C D
+             SETUPTIME = 25NS
+             HOLDTIME = 5NS
+ WIDTH:
+        NODE = LE
+        MIN_HI = 20NS

.ENDS 74HC4514

*--------------------------------------------------------74HCT4514------

* The 74HCT4514 4 to 16 Line Decoder/Demultiplexer with Input Latches
* Philips High Speed CMOS Logic Data Book, 1994, pages 1045 to 1051
* with logic diagram from Motorola High Speed CMOS Data Book, 1993, page 5-544
* jat 8/10/95

.SUBCKT 74HCT4514
+ A0 A1 A2 A3 LE EBAR Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,16) DPWR DGND
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR EBAR
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7 Q_8 Q_9 Q_10 Q_11 Q_12 Q_13 Q_14 Q_15
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+       E = {~EBAR}
+       NOR0 = {~(QA | QB)}
+       NOR1 = {~(QABAR | QB)}
+       NOR2 = {~(QA | QBBAR)}
+       NOR3 = {~(QABAR | QBBAR)}
+       NOR4 = {~(QC | QD)}
+       NOR5 = {~(QCBAR | QD)}
+       NOR6 = {~(QC | QDBAR)}
+       NOR7 = {~(QCBAR | QDBAR)}
+       Q_0 = {NOR4 & NOR0 & E}
+       Q_1 = {NOR4 & NOR1 & E}
+       Q_2 = {NOR4 & NOR2 & E}
+       Q_3 = {NOR4 & NOR3 & E}
+       Q_4 = {NOR5 & NOR0 & E}
+       Q_5 = {NOR5 & NOR1 & E}
+       Q_6 = {NOR5 & NOR2 & E}
+       Q_7 = {NOR5 & NOR3 & E}
+       Q_8 = {NOR6 & NOR0 & E}
+       Q_9 = {NOR6 & NOR1 & E}
+       Q_10 = {NOR6 & NOR2 & E}
+       Q_11 = {NOR6 & NOR3 & E}
+       Q_12 = {NOR7 & NOR0 & E}
+       Q_13 = {NOR7 & NOR1 & E}
+       Q_14 = {NOR7 & NOR2 & E}
+       Q_15 = {NOR7 & NOR3 & E}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+ A0 A1 A2 A3
+ QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,0,6) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7 Q_8 Q_9 Q_10 Q_11 Q_12 Q_13 Q_14 Q_15
+ A0 A1 A2 A3 LE EBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     SELECT = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0)}
+     LATCH = {CHANGED_LH(LE,0)}
+     ENABLE = {CHANGED(EBAR,0)}
+ PINDLY:
+     Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 Q9 Q10 Q11 Q12 Q13 Q14 Q15 = {
+       CASE(
+          ENABLE & (TRN_LH | TRN_HL), DELAY(-1,17NS,40NS),
+          LATCH & (TRN_LH | TRN_HL), DELAY(-1,29NS,50NS),
+          SELECT & (TRN_LH | TRN_HL), DELAY(-1,30NS,55NS),
+          DELAY(-1,31NS,56NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LE A0 A1 A2 A3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = LE
+             DATA(4) = A0 A1 A2 A3
+             SETUPTIME = 23NS
+             HOLDTIME = 3NS
+ WIDTH:
+        NODE = LE
+        MIN_HI = 20NS

.ENDS 74HCT4514

*------------------------------------------------------------74HC4515----

* 74HC4515 4 to 16 Line Decoder/Demultiplexer with Input Latches, Inverting
* Philips High Speed CMOS Logic Data Book, 1994, pages 1053 to 1058
* jat 8/10/95

.SUBCKT 74HC4515
+ A0 A1 A2 A3 LE EBAR Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR Q8BAR
+ Q9BAR Q10BAR Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,16) DPWR DGND
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR EBAR
+ Q_0BAR Q_1BAR Q_2BAR Q_3BAR Q_4BAR Q_5BAR Q_6BAR Q_7BAR Q_8BAR Q_9BAR
+ Q_10BAR Q_11BAR Q_12BAR Q_13BAR Q_14BAR Q_15BAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+       E = {~EBAR}
+       NOR0 = {~(QA | QB)}
+       NOR1 = {~(QABAR | QB)}
+       NOR2 = {~(QA | QBBAR)}
+       NOR3 = {~(QABAR | QBBAR)}
+       NOR4 = {~(QC | QD)}
+       NOR5 = {~(QCBAR | QD)}
+       NOR6 = {~(QC | QDBAR)}
+       NOR7 = {~(QCBAR | QDBAR)}
+       Q_0BAR = {~(NOR4 & NOR0 & E)}
+       Q_1BAR = {~(NOR4 & NOR1 & E)}
+       Q_2BAR = {~(NOR4 & NOR2 & E)}
+       Q_3BAR = {~(NOR4 & NOR3 & E)}
+       Q_4BAR = {~(NOR5 & NOR0 & E)}
+       Q_5BAR = {~(NOR5 & NOR1 & E)}
+       Q_6BAR = {~(NOR5 & NOR2 & E)}
+       Q_7BAR = {~(NOR5 & NOR3 & E)}
+       Q_8BAR = {~(NOR6 & NOR0 & E)}
+       Q_9BAR = {~(NOR6 & NOR1 & E)}
+       Q_10BAR = {~(NOR6 & NOR2 & E)}
+       Q_11BAR = {~(NOR6 & NOR3 & E)}
+       Q_12BAR = {~(NOR7 & NOR0 & E)}
+       Q_13BAR = {~(NOR7 & NOR1 & E)}
+       Q_14BAR = {~(NOR7 & NOR2 & E)}
+       Q_15BAR = {~(NOR7 & NOR3 & E)}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+ A0 A1 A2 A3
+ QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,0,6) DPWR DGND
+ Q_0BAR Q_1BAR Q_2BAR Q_3BAR Q_4BAR Q_5BAR Q_6BAR Q_7BAR Q_8BAR Q_9BAR
+ Q_10BAR Q_11BAR Q_12BAR Q_13BAR Q_14BAR Q_15BAR
+ A0 A1 A2 A3 LE EBAR
+ Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR Q8BAR Q9BAR Q10BAR Q11BAR
+ Q12BAR Q13BAR Q14BAR Q15BAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     SELECT = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0)}
+     LATCH = {CHANGED_LH(LE,0)}
+     ENABLE = {CHANGED(EBAR,0)}
+ PINDLY:
+     Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR Q8BAR Q9BAR Q10BAR
+     Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR = {
+       CASE(
+          ENABLE & (TRN_LH | TRN_HL), DELAY(-1,18NS,35NS),
+          LATCH & (TRN_LH | TRN_HL), DELAY(-1,24NS,45NS),
+          SELECT & (TRN_LH | TRN_HL), DELAY(-1,29NS,50NS),
+          DELAY(-1,30NS,51NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LE A0 A1 A2 A3
+ IO_HC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = LE
+             DATA(4) = A0 A1 A2 A3
+             SETUPTIME = 23NS
+ WIDTH:
+        NODE = LE
+        MIN_HI = 19NS

.ENDS 74HC4515

*------------------------------------------------------------74HCT4515----

* 74HCT4515 4 to 16 Line Decoder/Demultiplexer with Input Latches, Inverting
* Philips High Speed CMOS Logic Data Book, 1994, pages 1053 to 1058
* jat 8/10/95

.SUBCKT 74HCT4515
+ A0 A1 A2 A3 LE EBAR Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR Q8BAR
+ Q9BAR Q10BAR Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,16) DPWR DGND
+ QA QB QC QD QABAR QBBAR QCBAR QDBAR EBAR
+ Q_0BAR Q_1BAR Q_2BAR Q_3BAR Q_4BAR Q_5BAR Q_6BAR Q_7BAR Q_8BAR Q_9BAR
+ Q_10BAR Q_11BAR Q_12BAR Q_13BAR Q_14BAR Q_15BAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+       E = {~EBAR}
+       NOR0 = {~(QA | QB)}
+       NOR1 = {~(QABAR | QB)}
+       NOR2 = {~(QA | QBBAR)}
+       NOR3 = {~(QABAR | QBBAR)}
+       NOR4 = {~(QC | QD)}
+       NOR5 = {~(QCBAR | QD)}
+       NOR6 = {~(QC | QDBAR)}
+       NOR7 = {~(QCBAR | QDBAR)}
+       Q_0BAR = {~(NOR4 & NOR0 & E)}
+       Q_1BAR = {~(NOR4 & NOR1 & E)}
+       Q_2BAR = {~(NOR4 & NOR2 & E)}
+       Q_3BAR = {~(NOR4 & NOR3 & E)}
+       Q_4BAR = {~(NOR5 & NOR0 & E)}
+       Q_5BAR = {~(NOR5 & NOR1 & E)}
+       Q_6BAR = {~(NOR5 & NOR2 & E)}
+       Q_7BAR = {~(NOR5 & NOR3 & E)}
+       Q_8BAR = {~(NOR6 & NOR0 & E)}
+       Q_9BAR = {~(NOR6 & NOR1 & E)}
+       Q_10BAR = {~(NOR6 & NOR2 & E)}
+       Q_11BAR = {~(NOR6 & NOR3 & E)}
+       Q_12BAR = {~(NOR7 & NOR0 & E)}
+       Q_13BAR = {~(NOR7 & NOR1 & E)}
+       Q_14BAR = {~(NOR7 & NOR2 & E)}
+       Q_15BAR = {~(NOR7 & NOR3 & E)}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LE
+ A0 A1 A2 A3
+ QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ D0_GFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(16,0,6) DPWR DGND
+ Q_0BAR Q_1BAR Q_2BAR Q_3BAR Q_4BAR Q_5BAR Q_6BAR Q_7BAR Q_8BAR Q_9BAR
+ Q_10BAR Q_11BAR Q_12BAR Q_13BAR Q_14BAR Q_15BAR
+ A0 A1 A2 A3 LE EBAR
+ Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR Q8BAR Q9BAR Q10BAR Q11BAR
+ Q12BAR Q13BAR Q14BAR Q15BAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+     SELECT = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0)}
+     LATCH = {CHANGED_LH(LE,0)}
+     ENABLE = {CHANGED(EBAR,0)}
+ PINDLY:
+     Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR Q8BAR Q9BAR Q10BAR
+     Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR = {
+       CASE(
+          ENABLE & (TRN_LH | TRN_HL), DELAY(-1,18NS,40NS),
+          LATCH & (TRN_LH | TRN_HL), DELAY(-1,29NS,50NS),
+          SELECT & (TRN_LH | TRN_HL), DELAY(-1,30NS,55NS),
+          DELAY(-1,31NS,56NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LE A0 A1 A2 A3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK HL = LE
+             DATA(4) = A0 A1 A2 A3
+             SETUPTIME = 23NS
+             HOLDTIME = 3NS
+ WIDTH:
+        NODE = LE
+        MIN_HI = 20NS

.ENDS 74HCT4515

*-----------------------------------------------------------74HC4516------

* Binary Up/Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1059 to 1067
* jat 9/18/96

.SUBCKT 74HC4516 CP UP/DNBAR CEBAR MR PL D0 D1 D2 D3 Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,13) DPWR DGND
+ CEBAR PL UP/DNBAR D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR MR
+ DATA0 DATA1 DATA2 DATA3 TCBARO SET0 CLR0 SET1 CLR1 SET2 CLR2 SET3 CLR3
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  DATA0 = {(~PL & CEBAR & Q0O) | (~CEBAR & ~PL & Q0BAR)}
+  DATA1 = {(~PL & CEBAR & Q1O) | (~PL & ~CEBAR & UP/DNBAR & (Q1O ^ Q0O)) |
+           (~PL & ~CEBAR & ~UP/DNBAR & (~(Q1O ^ Q0O)))}
+  DATA2 = {(~PL & CEBAR & Q2O) | (~PL & ~CEBAR & UP/DNBAR & ((Q2O & Q0BAR) | (Q2O & Q1BAR) | (Q2BAR & Q1O & Q0O))) |
+           (~PL & ~CEBAR & ~UP/DNBAR & ((Q2O & Q1O) | (Q2O & Q0O) | (Q2BAR & Q1BAR & Q0BAR)))}
+  DATA3 = {(~PL & CEBAR & Q3O) | (~PL & ~CEBAR & UP/DNBAR & ((Q3O & Q2BAR) | (Q3O & Q1BAR) | 
+				(Q3O & Q1O & Q0BAR) | (Q3BAR & Q2O & Q1O & Q0O))) |
+           (~PL & ~CEBAR & ~UP/DNBAR & ((Q3O & (Q2O | Q1O | Q0O)) | (Q3BAR & Q2BAR & Q1BAR & Q0BAR)))}
+  TCBARO = {~((~UP/DNBAR & ~CEBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (UP/DNBAR & ~CEBAR & Q0O & Q1O & Q2O & Q3O))}
+  SET0 = {MR | ~(PL & D0)}
+  CLR0 = {~MR & ~(PL & ~D0)}
+  SET1 = {MR | ~(PL & D1)}
+  CLR1 = {~MR & ~(PL & ~D1)}
+  SET2 = {MR | ~(PL & D2)}
+  CLR2 = {~MR & ~(PL & ~D2)}
+  SET3 = {MR | ~(PL & D3)}
+  CLR3 = {~MR & ~(PL & ~D3)}

U2 DFF(1) DPWR DGND
+ SET0 CLR0 CP
+ DATA0 Q0O Q0BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ SET1 CLR1 CP
+ DATA1 Q1O Q1BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+ SET2 CLR2 CP
+ DATA2 Q2O Q2BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+ SET3 CLR3 CP
+ DATA3 Q3O Q3BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,4) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP MR PL CEBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  COUNT = {CHANGED_HL(CEBAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+  LOAD = {CHANGED_LH(PL,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,25NS,42NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,30NS,50NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,26NS,44NS),
+      DELAY(-1,31NS,51NS))}
+  TCBAR = {
+    CASE(
+      CLEAR & TRN_LH, DELAY(-1,25NS,47NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,33NS,60NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,13NS,25NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,27NS,52NS),
+      DELAY(-1,34NS,61NS))}

U7 CONSTRAINT(9) DPWR DGND
+ CP CEBAR PL MR D0 D1 D2 D3 UP/DNBAR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 49MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = CEBAR
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = PL
+  MIN_HI = 10NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MR
+  SETUPTIME_LO = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PL
+  SETUPTIME_LO = 9NS
+ SETUP_HOLD:
+  CLOCK LH = PL
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = CEBAR
+  SETUPTIME = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = UP/DNBAR
+  SETUPTIME = 11NS

.ENDS 74HC4516

*-----------------------------------------------------------74HCT4516------

* Binary Up/Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1059 to 1067
* jat 9/18/96

.SUBCKT 74HCT4516 CP UP/DNBAR CEBAR MR PL D0 D1 D2 D3 Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,13) DPWR DGND
+ CEBAR PL UP/DNBAR D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR MR
+ DATA0 DATA1 DATA2 DATA3 TCBARO SET0 CLR0 SET1 CLR1 SET2 CLR2 SET3 CLR3
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  DATA0 = {(~PL & CEBAR & Q0O) | (~CEBAR & ~PL & Q0BAR)}
+  DATA1 = {(~PL & CEBAR & Q1O) | (~PL & ~CEBAR & UP/DNBAR & (Q1O ^ Q0O)) |
+           (~PL & ~CEBAR & ~UP/DNBAR & (~(Q1O ^ Q0O)))}
+  DATA2 = {(~PL & CEBAR & Q2O) | (~PL & ~CEBAR & UP/DNBAR & ((Q2O & Q0BAR) | (Q2O & Q1BAR) | (Q2BAR & Q1O & Q0O))) |
+           (~PL & ~CEBAR & ~UP/DNBAR & ((Q2O & Q1O) | (Q2O & Q0O) | (Q2BAR & Q1BAR & Q0BAR)))}
+  DATA3 = {(~PL & CEBAR & Q3O) | (~PL & ~CEBAR & UP/DNBAR & ((Q3O & Q2BAR) | (Q3O & Q1BAR) | 
+				(Q3O & Q1O & Q0BAR) | (Q3BAR & Q2O & Q1O & Q0O))) |
+           (~PL & ~CEBAR & ~UP/DNBAR & ((Q3O & (Q2O | Q1O | Q0O)) | (Q3BAR & Q2BAR & Q1BAR & Q0BAR)))}
+  TCBARO = {~((~UP/DNBAR & ~CEBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (UP/DNBAR & ~CEBAR & Q0O & Q1O & Q2O & Q3O))}
+  SET0 = {MR | ~(PL & D0)}
+  CLR0 = {~MR & ~(PL & ~D0)}
+  SET1 = {MR | ~(PL & D1)}
+  CLR1 = {~MR & ~(PL & ~D1)}
+  SET2 = {MR | ~(PL & D2)}
+  CLR2 = {~MR & ~(PL & ~D2)}
+  SET3 = {MR | ~(PL & D3)}
+  CLR3 = {~MR & ~(PL & ~D3)}

U2 DFF(1) DPWR DGND
+ SET0 CLR0 CP
+ DATA0 Q0O Q0BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ SET1 CLR1 CP
+ DATA1 Q1O Q1BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+ SET2 CLR2 CP
+ DATA2 Q2O Q2BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+ SET3 CLR3 CP
+ DATA3 Q3O Q3BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(5,0,4) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP MR PL CEBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  COUNT = {CHANGED_HL(CEBAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+  LOAD = {CHANGED_LH(PL,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,24NS,42NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,32NS,53NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,28NS,50NS),
+      DELAY(-1,29NS,51NS))}
+  TCBAR = {
+    CASE(
+      CLEAR & TRN_LH, DELAY(-1,31NS,50NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,34NS,68NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,18NS,31NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,29NS,58NS),
+      DELAY(-1,32NS,51NS))}

U7 CONSTRAINT(9) DPWR DGND
+ CP CEBAR PL MR D0 D1 D2 D3 UP/DNBAR
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 52MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = CEBAR
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = PL
+  MIN_HI = 8NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MR
+  SETUPTIME_LO = 14NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PL
+  SETUPTIME_LO = 10NS
+ SETUP_HOLD:
+  CLOCK LH = PL
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 9NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = CEBAR
+  SETUPTIME = 9NS
+  HOLDTIME = 9NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = UP/DNBAR
+  SETUPTIME = 11NS

.ENDS 74HCT4516

*-----------------------------------------------------------74HC4518------

* Dual 4-Bit Synchronous BCD Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1069 to 1073
* jat 9/18/96

.SUBCKT 74HC4518 CP0 CP1BAR MR Q0 Q1 Q2 Q3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,6) DPWR DGND
+ CP0 CP1BAR MR Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 CLOCK MRBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CP0 | ~CP1BAR}
+   MRBAR = {~MR}
+   D0 = {Q0BAR}
+   D1 = {Q3BAR & (Q1O ^ Q0O)}
+   D2 = {(Q3BAR & Q2O & (Q1BAR | Q0BAR)) | (Q3BAR & Q2BAR & Q1O & Q0O)}
+   D3 = {(Q3BAR & Q2O & Q1O & Q0O) | (Q3O & Q2BAR & Q1BAR & Q0BAR)}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CLOCK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ CP0 CP1BAR MR
+ Q0 Q1 Q2 Q3
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE0 = {CHANGED_LH(CP0,0)}
+  EDGE1 = {CHANGED_HL(CP1BAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,16NS,30NS),
+      EDGE0 & (TRN_LH | TRN_HL), DELAY(-1,24NS,42NS),
+      EDGE1 & (TRN_LH | TRN_HL), DELAY(-1,24NS,42NS),
+      DELAY(-1,25NS,43NS))}

U4 CONSTRAINT(3) DPWR DGND
+ CP0 CP1BAR MR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP0
+  MAXFREQ = 55MEG
+ FREQ:
+  NODE = CP1BAR
+  MAXFREQ = 55MEG
+ WIDTH:
+  NODE  = CP0
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = CP1BAR
+  MIN_LO = 9NS
+  MIN_HI = 9NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 14NS
+ SETUP_HOLD:
+  CLOCK LH = CP0
+  DATA(1) = CP1BAR
+  SETUPTIME_HI = 8NS
+ SETUP_HOLD:
+  CLOCK HL = CP1BAR
+  DATA(1) = CP0
+  SETUPTIME_LO = 8NS

.ENDS 74HC4518

*-----------------------------------------------------------74HCT4518------

* Dual 4-Bit Synchronous BCD Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1069 to 1073
* jat 9/18/96

.SUBCKT 74HCT4518 CP0 CP1BAR MR Q0 Q1 Q2 Q3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,6) DPWR DGND
+ CP0 CP1BAR MR Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 CLOCK MRBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CP0 | ~CP1BAR}
+   MRBAR = {~MR}
+   D0 = {Q0BAR}
+   D1 = {Q3BAR & (Q1O ^ Q0O)}
+   D2 = {(Q3BAR & Q2O & (Q1BAR | Q0BAR)) | (Q3BAR & Q2BAR & Q1O & Q0O)}
+   D3 = {(Q3BAR & Q2O & Q1O & Q0O) | (Q3O & Q2BAR & Q1BAR & Q0BAR)}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CLOCK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ CP0 CP1BAR MR
+ Q0 Q1 Q2 Q3
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE0 = {CHANGED_LH(CP0,0)}
+  EDGE1 = {CHANGED_HL(CP1BAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,17NS,35NS),
+      EDGE0 & (TRN_LH | TRN_HL), DELAY(-1,28NS,53NS),
+      EDGE1 & (TRN_LH | TRN_HL), DELAY(-1,28NS,53NS),
+      DELAY(-1,29NS,54NS))}

U4 CONSTRAINT(3) DPWR DGND
+ CP0 CP1BAR MR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP0
+  MAXFREQ = 50MEG
+ FREQ:
+  NODE = CP1BAR
+  MAXFREQ = 50MEG
+ WIDTH:
+  NODE  = CP0
+  MIN_LO = 11NS
+  MIN_HI = 11NS
+ WIDTH:
+  NODE  = CP1BAR
+  MIN_LO = 11NS
+  MIN_HI = 11NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 11NS
+ SETUP_HOLD:
+  CLOCK LH = CP0
+  DATA(1) = CP1BAR
+  SETUPTIME_HI = 5NS
+ SETUP_HOLD:
+  CLOCK HL = CP1BAR
+  DATA(1) = CP0
+  SETUPTIME_LO = 5NS

.ENDS 74HCT4518

*-----------------------------------------------------------74HC4520------

* Dual 4-Bit Synchronous Binary Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1075 to 1079
* jat 9/18/96

.SUBCKT 74HC4520 CP0 CP1BAR MR Q0 Q1 Q2 Q3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,6) DPWR DGND
+ CP0 CP1BAR MR Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 CLOCK MRBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CP0 | ~CP1BAR}
+   MRBAR = {~MR}
+   D0 = {Q0BAR}
+   D1 = {Q1O ^ Q0O}
+   D2 = {(Q2O & (Q0BAR| Q1BAR)) | (Q2BAR & Q1O & Q0O)}
+   D3 = {(Q3O & Q2BAR) | (Q3O & (Q1BAR | Q0BAR)) | (Q3BAR & Q2O & Q1O & Q0O)}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CLOCK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ CP0 CP1BAR MR
+ Q0 Q1 Q2 Q3
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE0 = {CHANGED_LH(CP0,0)}
+  EDGE1 = {CHANGED_HL(CP1BAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,16NS,30NS),
+      EDGE0 & (TRN_LH | TRN_HL), DELAY(-1,28NS,48NS),
+      EDGE1 & (TRN_LH | TRN_HL), DELAY(-1,28NS,48NS),
+      DELAY(-1,29NS,49NS))}

U4 CONSTRAINT(3) DPWR DGND
+ CP0 CP1BAR MR
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP0
+  MAXFREQ = 58MEG
+ FREQ:
+  NODE = CP1BAR
+  MAXFREQ = 58MEG
+ WIDTH:
+  NODE  = CP0
+  MIN_LO = 8NS
+  MIN_HI = 8NS
+ WIDTH:
+  NODE  = CP1BAR
+  MIN_LO = 8NS
+  MIN_HI = 8NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 14NS
+ SETUP_HOLD:
+  CLOCK LH = CP0
+  DATA(1) = CP1BAR
+  SETUPTIME_HI = 5NS
+ SETUP_HOLD:
+  CLOCK HL = CP1BAR
+  DATA(1) = CP0
+  SETUPTIME_LO = 5NS

.ENDS 74HC4520

*-----------------------------------------------------------74HCT4520------

* Dual 4-Bit Synchronous Binary Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1075 to 1079
* jat 9/18/96

.SUBCKT 74HCT4520 CP0 CP1BAR MR Q0 Q1 Q2 Q3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,6) DPWR DGND
+ CP0 CP1BAR MR Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 CLOCK MRBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLOCK = {CP0 | ~CP1BAR}
+   MRBAR = {~MR}
+   D0 = {Q0BAR}
+   D1 = {Q1O ^ Q0O}
+   D2 = {(Q2O & (Q0BAR| Q1BAR)) | (Q2BAR & Q1O & Q0O)}
+   D3 = {(Q3O & Q2BAR) | (Q3O & (Q1BAR | Q0BAR)) | (Q3BAR & Q2O & Q1O & Q0O)}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CLOCK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ CP0 CP1BAR MR
+ Q0 Q1 Q2 Q3
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE0 = {CHANGED_LH(CP0,0)}
+  EDGE1 = {CHANGED_HL(CP1BAR,0)}
+  CLEAR = {CHANGED_LH(MR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,16NS,35NS),
+      EDGE0 & (TRN_LH | TRN_HL), DELAY(-1,28NS,53NS),
+      EDGE1 & (TRN_LH | TRN_HL), DELAY(-1,25NS,53NS),
+      DELAY(-1,29NS,54NS))}

U4 CONSTRAINT(3) DPWR DGND
+ CP0 CP1BAR MR
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP0
+  MAXFREQ = 58MEG
+ FREQ:
+  NODE = CP1BAR
+  MAXFREQ = 58MEG
+ WIDTH:
+  NODE  = CP0
+  MIN_LO = 10NS
+  MIN_HI = 10NS
+ WIDTH:
+  NODE  = CP1BAR
+  MIN_LO = 10NS
+  MIN_HI = 10NS
+ WIDTH:
+  NODE  = MR
+  MIN_HI = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CP0
+  DATA(1) = CP1BAR
+  SETUPTIME_HI = 6NS
+ SETUP_HOLD:
+  CLOCK HL = CP1BAR
+  DATA(1) = CP0
+  SETUPTIME_LO = 6NS

.ENDS 74HCT4520

*-----------------------------------------------------------74HC4543------

* BCD to 7-Segment Latch/Decoder/Driver for LCDs
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1091 to 1099
* jat 9/18/96

.SUBCKT 74HC4543 D1 D2 D3 D0 PH LD BI QA QB QC QD QE QF QG
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,7) DPWR DGND
+ BI PH Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ QAO QBO QCO QDO QEO QFO QGO
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  NAND1 = {~(Q4BAR & Q3BAR & Q2BAR & Q1BAR)}
+  NAND2 = {~(Q3 & Q2 & Q1)}
+  NAND3 = {~(Q3BAR & Q2)}
+  NAND4 = {~(Q1 & Q2BAR & Q3BAR & Q4BAR)}
+  NAND5 = {(Q2BAR & Q3BAR)}
+  NOR = {~(BI | (~(NAND5 | Q4BAR)))}
+  NAND6 = {~(Q1 & Q2BAR & Q3BAR)}
+  NAND7 = {~(Q1BAR & Q2 & Q3BAR)}
+  NAND8 = {~(Q1BAR & Q2BAR & Q3)}
+  NAND9 = {~(Q1 & Q2BAR & Q3)}
+  NAND10 = {~(Q1BAR & Q2 & Q3)}
+  QAXO = {(NOR & NAND4 & NAND8 & NAND10)}
+  QBXO = {(NOR & NAND9 & NAND10)}
+  QCXO = {(NOR & NAND7)}
+  QDXO = {(NOR & NAND2 & NAND8 & NAND6)}
+  QEXO = {(NOR & Q1BAR & NAND8)}
+  QFXO = {(NOR & NAND2 & NAND3 & NAND4)}
+  QGXO = {(NOR & NAND2 & NAND1 & NAND4)}
+  QAO = {PH ^ QAXO}
+  QBO = {PH ^ QBXO}
+  QCO = {PH ^ QCXO}
+  QDO = {PH ^ QDXO}
+  QEO = {PH ^ QEXO}
+  QFO = {PH ^ QFXO}
+  QGO = {PH ^ QGXO}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LD
+ D0 D1 D2 D3
+ Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,7) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO
+ D0 D1 D2 D3 LD BI PH
+ QA QB QC QD QE QF QG
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED_LH(LD,0)}
+   BLANK = {CHANGED(BI,0)}
+   PHASE = {CHANGED(PH,0)}
+   DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D0,0)}
+ PINDLY:
+  QA QB QC QD QE QF QG = {
+    CASE(
+      BLANK & (TRN_LH | TRN_HL), DELAY(-1,24NS,53NS),
+      PHASE & (TRN_LH | TRN_HL), DELAY(-1,20NS,40NS),
+      LATCH & (TRN_LH | TRN_HL), DELAY(-1,37NS,74NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,33NS,68NS),
+      DELAY(-1,38NS,75NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LD D1 D2 D3 D0
+ IO_HC IO_LEVEL={IO_LEVEL}
+ WIDTH:
+  NODE  = LD
+  MIN_LO = 4NS
+ SETUP_HOLD:
+  CLOCK HL = LD
+  DATA(4) = D1 D2 D3 D0
+  SETUPTIME = 3NS
+  HOLDTIME = 1NS

.ENDS 74HC4543

*-----------------------------------------------------------74HCT4543------

* BCD to 7-Segment Latch/Decoder/Driver for LCDs
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1091 to 1099
* jat 9/18/96

.SUBCKT 74HCT4543 D1 D2 D3 D0 PH LD BI QA QB QC QD QE QF QG
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,7) DPWR DGND
+ BI PH Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ QAO QBO QCO QDO QEO QFO QGO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  NAND1 = {~(Q4BAR & Q3BAR & Q2BAR & Q1BAR)}
+  NAND2 = {~(Q3 & Q2 & Q1)}
+  NAND3 = {~(Q3BAR & Q2)}
+  NAND4 = {~(Q1 & Q2BAR & Q3BAR & Q4BAR)}
+  NAND5 = {(Q2BAR & Q3BAR)}
+  NOR = {~(BI | (~(NAND5 | Q4BAR)))}
+  NAND6 = {~(Q1 & Q2BAR & Q3BAR)}
+  NAND7 = {~(Q1BAR & Q2 & Q3BAR)}
+  NAND8 = {~(Q1BAR & Q2BAR & Q3)}
+  NAND9 = {~(Q1 & Q2BAR & Q3)}
+  NAND10 = {~(Q1BAR & Q2 & Q3)}
+  QAXO = {(NOR & NAND4 & NAND8 & NAND10)}
+  QBXO = {(NOR & NAND9 & NAND10)}
+  QCXO = {(NOR & NAND7)}
+  QDXO = {(NOR & NAND2 & NAND8 & NAND6)}
+  QEXO = {(NOR & Q1BAR & NAND8)}
+  QFXO = {(NOR & NAND2 & NAND3 & NAND4)}
+  QGXO = {(NOR & NAND2 & NAND1 & NAND4)}
+  QAO = {PH ^ QAXO}
+  QBO = {PH ^ QBXO}
+  QCO = {PH ^ QCXO}
+  QDO = {PH ^ QDXO}
+  QEO = {PH ^ QEXO}
+  QFO = {PH ^ QFXO}
+  QGO = {PH ^ QGXO}

U2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI LD
+ D0 D1 D2 D3
+ Q1 Q2 Q3 Q4 Q1BAR Q2BAR Q3BAR Q4BAR
+ D0_GFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(7,0,7) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO
+ D0 D1 D2 D3 LD BI PH
+ QA QB QC QD QE QF QG
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LATCH = {CHANGED_LH(LD,0)}
+   BLANK = {CHANGED(BI,0)}
+   PHASE = {CHANGED(PH,0)}
+   DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D0,0)}
+ PINDLY:
+  QA QB QC QD QE QF QG = {
+    CASE(
+      BLANK & (TRN_LH | TRN_HL), DELAY(-1,32NS,66NS),
+      PHASE & (TRN_LH | TRN_HL), DELAY(-1,24NS,66NS),
+      LATCH & (TRN_LH | TRN_HL), DELAY(-1,36NS,68NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,38NS,80NS),
+      DELAY(-1,39NS,81NS))}

U4 CONSTRAINT(5) DPWR DGND
+ LD D1 D2 D3 D0
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ WIDTH:
+  NODE  = LD
+  MIN_LO = 4NS
+  MIN_HI = 4NS
+ SETUP_HOLD:
+  CLOCK HL = LD
+  DATA(4) = D1 D2 D3 D0
+  SETUPTIME = 4NS
+  HOLDTIME = 2NS

.ENDS 74HCT4543

*-----------------------------------------------------------74HC4724-----

* The 74HC4724 8 Bit Addressable Latches
* TI High Speed CMOS Data Book, 1989, pages 2-673 to 2-676
* Note that the reset signals to the 8 latches had to be redesigned in order
* for the third function, 8 Line Demultiplexer (CLR=1,GBAR=0).  The new
* reset signals for each of the 8 latches are in the logic section.
* jat 8/11/95

.SUBCKT 74HC4724
+ GBAR CLR D S0 S1 S2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,16) DPWR DGND
+ CLR S0 S1 S2 GBAR
+ GATE0 GATE1 GATE2 GATE3 GATE4 GATE5 GATE6 GATE7
+ RESET0 RESET1 RESET2 RESET3 RESET4 RESET5 RESET6 RESET7
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+       S0BAR = {~S0}
+       S1BAR = {~S1}
+       S2BAR = {~S2}
+       NAND0 = {~(S0BAR & S1BAR & S2BAR)}
+       NAND1 = {~(S0    & S1BAR & S2BAR)}
+       NAND2 = {~(S0BAR & S1    & S2BAR)}
+       NAND3 = {~(S0    & S1    & S2BAR)}
+       NAND4 = {~(S0BAR & S1BAR & S2)}
+       NAND5 = {~(S0    & S1BAR & S2)}
+       NAND6 = {~(S0BAR & S1    & S2)}
+       NAND7 = {~(S0    & S1    & S2)}
+       GATE0 = {~(NAND0 | GBAR)}
+       GATE1 = {~(NAND1 | GBAR)}
+       GATE2 = {~(NAND2 | GBAR)}
+       GATE3 = {~(NAND3 | GBAR)}
+       GATE4 = {~(NAND4 | GBAR)}
+       GATE5 = {~(NAND5 | GBAR)}
+       GATE6 = {~(NAND6 | GBAR)}
+       GATE7 = {~(NAND7 | GBAR)}
+       RESET0 = {~((NAND0 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET1 = {~((NAND1 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET2 = {~((NAND2 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET3 = {~((NAND3 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET4 = {~((NAND4 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET5 = {~((NAND5 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET6 = {~((NAND6 & CLR & (~GBAR)) | (CLR & GBAR))}
+       RESET7 = {~((NAND7 & CLR & (~GBAR)) | (CLR & GBAR))}

U2 DLTCH(1) DPWR DGND
+ $D_HI RESET0 GATE0
+ D Q0O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DLTCH(1) DPWR DGND
+ $D_HI RESET1 GATE1
+ D Q1O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DLTCH(1) DPWR DGND
+ $D_HI RESET2 GATE2
+ D Q2O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DLTCH(1) DPWR DGND
+ $D_HI RESET3 GATE3
+ D Q3O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DLTCH(1) DPWR DGND
+ $D_HI RESET4 GATE4
+ D Q4O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DLTCH(1) DPWR DGND
+ $D_HI RESET5 GATE5
+ D Q5O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DLTCH(1) DPWR DGND
+ $D_HI RESET6 GATE6
+ D Q6O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DLTCH(1) DPWR DGND
+ $D_HI RESET7 GATE7
+ D Q7O $D_NC
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(8,0,6) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O Q6O Q7O
+ CLR D S0 S1 S2 GBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+      CLEAR = {CHANGED_LH(CLR,0)}
+      DATA = {CHANGED(D,0)}
+      ADDRESS = {CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0)}
+      ENABLE = {CHANGED(GBAR,0)}
+ PINDLY:
+   Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 = {
+     CASE(
+       ENABLE & (TRN_LH | TRN_HL), DELAY(-1,20NS,34NS),
+       CLEAR & TRN_HL, DELAY(-1,18NS,30NS),
+       ADDRESS & (TRN_LH | TRN_HL), DELAY(-1,21NS,40NS),
+       DATA & (TRN_LH | TRN_HL), DELAY(-1,17NS,26NS),
+       DELAY(-1,22NS,41NS))}

U11 CONSTRAINT(6) DPWR DGND
+ CLR GBAR D S0 S1 S2
+ IO_HC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = GBAR
+             DATA(4) = D S0 S1 S2
+             SETUPTIME = 19NS
+             HOLDTIME = 5NS
+ WIDTH:
+        NODE = CLR
+        MIN_HI = 20NS
+ WIDTH:
+        NODE = GBAR
+        MIN_LO = 20NS

.ENDS 74HC4724

*------------------------------------------------------------74F5074----

* Synchronizing dual D-Type Flip-Flop/Clock Driver
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 955 to 962
* jat 7/31/96

.SUBCKT 74F5074 D CP SDBAR RDBAR Q QBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(1) DPWR DGND
+ SDBAR RDBAR CP
+ D QO QBARO
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(2,0,3) DPWR DGND
+ QO QBARO
+ CP SDBAR RDBAR
+ Q QBAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(SDBAR,0)}
+   RESET = {CHANGED_HL(RDBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+   Q QBAR = {
+     CASE(
+       (RESET | SET) & TRN_LH, DELAY(3NS,4.5NS,7.5NS),
+       (RESET | SET) & TRN_HL, DELAY(3NS,5NS,7.5NS),
+       EDGE & (TRN_LH | TRN_HL), DELAY(2NS,3.9NS,6NS),
+       DELAY(4NS,6NS,8.5NS))}

U3 CONSTRAINT(4) DPWR DGND
+ CP SDBAR RDBAR D
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 120MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 3NS
+   MIN_LO = 4NS
+ WIDTH:
+   NODE = SDBAR
+   MIN_LO = 3NS
+ WIDTH:
+   NODE = RDBAR
+   MIN_LO = 3NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = D
+   SETUPTIME = 1.5NS
+   HOLDTIME = 1NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = SDBAR
+   SETUPTIME_HI = 3NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = RDBAR
+   SETUPTIME_HI = 3NS

.ENDS 74F5074

*------------------------------------------------------------74ALS5245-----

* Octal Tri-State Transceiver
* National Advanced Bipolar Logic Databook, 1995, pages 9-208 to 9-212
* jat 8/21/96

.SUBCKT 74ALS5245 A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ GBAR DIR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

UBUF BUFA(16) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1ST A2ST A3ST A4ST A5ST A6ST A7ST A8ST B1ST B2ST B3ST B4ST B5ST B6ST B7ST
+ B8ST
+ D0_GATE IO_ALS000_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U1 LOGICEXP(2,2) DPWR DGND
+ GBAR DIR
+ AB BA
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   AB = {~GBAR & DIR}
+   BA = {~GBAR & ~DIR}

U2 PINDLY(16,2,0) DPWR DGND
+ A1ST A2ST A3ST A4ST A5ST A6ST A7ST A8ST B1ST B2ST B3ST B4ST B5ST B6ST B7ST
+ B8ST
+ AB BA
+ B1 B2 B3 B4 B5 B6 B7 B8 A1 A2 A3 A4 A5 A6 A7 A8
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = BA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,20NS),
+       TRN_ZL, DELAY(5NS,-1,20NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(4NS,-1,15NS),
+       TRN_LH, DELAY(3NS,-1,10NS),
+       TRN_HL, DELAY(3NS,-1,10NS),
+       DELAY(6NS,-1,21NS))}
+ TRISTATE:
+ ENABLE HI = AB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+     CASE(
+       TRN_ZH, DELAY(5NS,-1,20NS),
+       TRN_ZL, DELAY(5NS,-1,20NS),
+       TRN_HZ, DELAY(2NS,-1,10NS),
+       TRN_LZ, DELAY(4NS,-1,15NS),
+       TRN_LH, DELAY(3NS,-1,10NS),
+       TRN_HL, DELAY(3NS,-1,10NS),
+       DELAY(6NS,-1,21NS))}

.ENDS 74ALS5245

*------------------------------------------------------------74ALS5245-1-----

* Octal Tri-State Transceiver
* National Advanced Bipolar Logic Databook, 1995, pages 9-208 to 9-212
* jat 8/21/96

.SUBCKT 74ALS5245-1 A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ GBAR DIR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

UBUF BUFA(16) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 B1 B2 B3 B4 B5 B6 B7 B8
+ A1ST A2ST A3ST A4ST A5ST A6ST A7ST A8ST B1ST B2ST B3ST B4ST B5ST B6ST B7ST
+ B8ST
+ D0_GATE IO_ALS000_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U1 LOGICEXP(2,2) DPWR DGND
+ GBAR DIR
+ AB BA
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   AB = {~GBAR & DIR}
+   BA = {~GBAR & ~DIR}

U2 PINDLY(16,2,0) DPWR DGND
+ A1ST A2ST A3ST A4ST A5ST A6ST A7ST A8ST B1ST B2ST B3ST B4ST B5ST B6ST B7ST
+ B8ST
+ AB BA
+ B1 B2 B3 B4 B5 B6 B7 B8 A1 A2 A3 A4 A5 A6 A7 A8
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = BA
+   A1 A2 A3 A4 A5 A6 A7 A8 = {
+     CASE(
+       TRN_ZH, DELAY(4NS,-1,20NS),
+       TRN_ZL, DELAY(5NS,-1,20NS),
+       TRN_HZ, DELAY(1NS,-1,10NS),
+       TRN_LZ, DELAY(3NS,-1,15NS),
+       TRN_LH, DELAY(2NS,-1,10NS),
+       TRN_HL, DELAY(3NS,-1,10NS),
+       DELAY(6NS,-1,21NS))}
+ TRISTATE:
+ ENABLE HI = AB
+   B1 B2 B3 B4 B5 B6 B7 B8 = {
+     CASE(
+       TRN_ZH, DELAY(4NS,-1,20NS),
+       TRN_ZL, DELAY(5NS,-1,20NS),
+       TRN_HZ, DELAY(1NS,-1,10NS),
+       TRN_LZ, DELAY(3NS,-1,15NS),
+       TRN_LH, DELAY(2NS,-1,10NS),
+       TRN_HL, DELAY(3NS,-1,10NS),
+       DELAY(6NS,-1,21NS))}

.ENDS 74ALS5245-1

*------------------------------------------------------------74HC7001----

* Quadruple Postive-AND Gates with Schmitt-Trigger Inputs
* TI High-Speed CMOS Logic Data Book, 1989, pages 2-677 to 2-679
* jat 12/29/95

.SUBCKT 74HC7001 1A 1B 1Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 AND(2) DPWR DGND
+ 1A 1B 1Y
+ DLYHC7001 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLYHC7001 UGATE(TPLHTY=18NS TPLHMX=26NS TPHLTY=18NS TPHLMX=26NS)

.ENDS 74HC7001

*------------------------------------------------------------74HC7002----

* Quadruple Postive-NOR Gates with Schmitt-Trigger Inputs
* TI High-Speed CMOS Logic Data Book, 1989, pages 2-681 to 2-683
* jat 12/29/95

.SUBCKT 74HC7002 1A 1B 1Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 NOR(2) DPWR DGND
+ 1A 1B 1Y
+ DLYHC7002 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLYHC7002 UGATE(TPLHTY=18NS TPLHMX=26NS TPHLTY=18NS TPHLMX=26NS)

.ENDS 74HC7002

*------------------------------------------------------------74HC7014----

* Hex non-inverting precision Schmitt Trigger
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1137 to 1140
* jat 9/18/96

.SUBCKT 74HC7014 1A 1Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUF DPWR DGND
+ 1A 1Y
+ DLY_HC7014 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC7014 UGATE(TPLHTY=23NS TPLHMX=52NS TPHLTY=38NS TPHLMX=115NS)

.ENDS 74HC7014

*------------------------------------------------------------74HC7032----

* Quadruple Postive-OR Gates with Schmitt-Trigger Inputs
* TI High-Speed CMOS Logic Data Book, 1989, pages 2-685 to 2-687
* jat 12/29/95

.SUBCKT 74HC7032 1A 1B 1Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 OR(2) DPWR DGND
+ 1A 1B 1Y
+ DLYHC7032 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLYHC7032 UGATE(TPLHTY=18NS TPLHMX=26NS TPHLTY=18NS TPHLMX=26NS)

.ENDS 74HC7032

*------------------------------------------------------------74HC7074----

* The 74HC7074 6 Section Multifunction Circuits(NAND,INVERT,NOR,Flip-Flop)
* TI High Speed CMOS Data Book, 1989, pages 2-689 to 2-694
* jat 8/11/95

.SUBCKT 74HC7074
+ 1A 1Y 2A 2Y 3A 3B 3Y 4CLK 4PREBAR 4CLRBAR 4D 4Q 4QBAR 
+ 5CLK 5PREBAR 5CLRBAR 5D 5Q 5QBAR 6A 6B 6Y
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,4) DPWR DGND
+ 1A 2A 3A 3B 6A 6B
+ 1_Y 2_Y 3_Y 6_Y
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        1_Y = {~1A}
+        2_Y = {~2A}
+        3_Y = {~(3A & 3B)}
+        6_Y = {~(6A | 6B)}

U2 DFF(1) DPWR DGND
+ 4PREBAR 4CLRBAR 4CLK
+ 4D 4_Q 4_QBAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ 5PREBAR 5CLRBAR 5CLK
+ 5D 5_Q 5_QBAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(8,0,12) DPWR DGND
+ 1_Y 2_Y 3_Y 4_Q 4_QBAR 5_Q 5_QBAR 6_Y
+ 1A 2A 3A 3B 6A 6B 4CLK 4PREBAR 4CLRBAR 5CLK 5PREBAR 5CLRBAR
+ 1Y 2Y 3Y 4Q 4QBAR 5Q 5QBAR 6Y
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    INV1 = {CHANGED(1A,0)}
+    INV2 = {CHANGED(2A,0)}
+    NAND = {CHANGED(3A,0) | CHANGED(3B,0)}
+    NOR = {CHANGED(6A,0) | CHANGED(6B,0)}
+    4EDGE = {CHANGED_LH(4CLK,0)}
+    4CONTROL = {CHANGED_HL(4PREBAR,0) | CHANGED_HL(4CLRBAR,0)}
+    5EDGE = {CHANGED_LH(5CLK,0)}
+    5CONTROL = {CHANGED_HL(5PREBAR,0) | CHANGED_HL(5CLRBAR,0)}
+ PINDLY:
+      1Y = {
+       CASE(
+         INV1 & (TRN_LH | TRN_HL), DELAY(-1,9NS,18NS),
+         DELAY(-1,10NS,19NS))}
+      2Y = {
+       CASE(
+         INV2 & (TRN_LH | TRN_HL), DELAY(-1,9NS,18NS),
+         DELAY(-1,10NS,19NS))}
+      3Y = {
+       CASE(
+         NAND & (TRN_LH | TRN_HL), DELAY(-1,9NS,18NS),
+         DELAY(-1,10NS,19NS))}
+      6Y = {
+       CASE(
+         NOR & (TRN_LH | TRN_HL), DELAY(-1,9NS,18NS),
+         DELAY(-1,10NS,19NS))}
+      4Q 4QBAR = {
+        CASE(
+         4CONTROL & (TRN_LH | TRN_HL), DELAY(-1,15NS,46NS),
+         4EDGE & (TRN_LH | TRN_HL), DELAY(-1,15NS,35NS),
+         DELAY(-1,16NS,47NS))}
+      5Q 5QBAR = {
+        CASE(
+         5CONTROL & (TRN_LH | TRN_HL), DELAY(-1,15NS,46NS),
+         5EDGE & (TRN_LH | TRN_HL), DELAY(-1,15NS,35NS),
+         DELAY(-1,16NS,47NS))}

U5 CONSTRAINT(8) DPWR DGND
+ 4CLK 4PREBAR 4CLRBAR 4D 5CLK 5PREBAR 5CLRBAR 5D
+ IO_HC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = 4CLK
+             DATA(1) = 4D
+             SETUPTIME = 25NS
+             HOLDTIME = 5NS
+ SETUP_HOLD:
+             CLOCK LH = 4CLK
+             DATA(2) = 4PREBAR 4CLRBAR
+             SETUPTIME_HI = 6NS
+ SETUP_HOLD:
+             CLOCK LH = 5CLK
+             DATA(1) = 5D
+             SETUPTIME = 25NS
+             HOLDTIME = 5NS
+ SETUP_HOLD:
+             CLOCK LH = 5CLK
+             DATA(2) = 5PREBAR 5CLRBAR
+             SETUPTIME_HI = 6NS
+ WIDTH:
+        NODE = 4CLK
+        MIN_HI = 23NS
+        MIN_LO = 23NS
+ WIDTH:
+        NODE = 4CLRBAR
+        MIN_LO = 25NS
+ WIDTH:
+        NODE = 4PREBAR
+        MIN_LO = 25NS
+ WIDTH:
+        NODE = 5CLK
+        MIN_HI = 23NS
+        MIN_LO = 23NS
+ WIDTH:
+        NODE = 5CLRBAR
+        MIN_LO = 25NS
+ WIDTH:
+        NODE = 5PREBAR
+        MIN_LO = 25NS

.ENDS 74HC7074

*----------------------------------------------------------74HC7080-----

* 16-Bit Even/Odd Parity Generator/Checker
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1189 to 1193
* jat 9/18/96

.SUBCKT 74HC7080
+ XBAR E/OBAR I0 I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 I14 I15
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 NXORA(8) DPWR DGND
+ I0 I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 I14 I15
+ A B C D E F G H
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 NXORA(4) DPWR DGND
+ A C B D E G F H
+ I J K L
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 NXORA(2) DPWR DGND
+ I J K L
+ M N
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 NXOR DPWR DGND
+ M N
+ O
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 INV DPWR DGND
+ XBAR X
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 XOR DPWR DGND
+ O X
+ E/OBARO
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 PINDLY(1,0,17) DPWR DGND
+ E/OBARO
+ XBAR I0 I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 I14 I15
+ E/OBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  XX = {CHANGED(XBAR,0)}
+  DATA = {CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+          CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) |
+          CHANGED(I8,0) | CHANGED(I9,0) | CHANGED(I10,0) | CHANGED(I11,0) |
+          CHANGED(I12,0) | CHANGED(I13,0) | CHANGED(I14,0) | CHANGED(I15,0)}
+ PINDLY:
+  E/OBAR = {
+    CASE(
+      XX & (TRN_LH | TRN_HL), DELAY(-1,15NS,30NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,33NS,56NS),
+      DELAY(-1,34NS,57NS))}

.ENDS 74HC7080

*----------------------------------------------------------74HCT7080-----

* 16-Bit Even/Odd Parity Generator/Checker
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1189 to 1193
* jat 9/18/96

.SUBCKT 74HCT7080
+ XBAR E/OBAR I0 I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 I14 I15
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 NXORA(8) DPWR DGND
+ I0 I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 I14 I15
+ A B C D E F G H
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 NXORA(4) DPWR DGND
+ A C B D E G F H
+ I J K L
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 NXORA(2) DPWR DGND
+ I J K L
+ M N
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 NXOR DPWR DGND
+ M N
+ O
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 INV DPWR DGND
+ XBAR X
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 XOR DPWR DGND
+ O X
+ E/OBARO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 PINDLY(1,0,17) DPWR DGND
+ E/OBARO
+ XBAR I0 I1 I2 I3 I4 I5 I6 I7 I8 I9 I10 I11 I12 I13 I14 I15
+ E/OBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  XX = {CHANGED(XBAR,0)}
+  DATA = {CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+          CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) |
+          CHANGED(I8,0) | CHANGED(I9,0) | CHANGED(I10,0) | CHANGED(I11,0) |
+          CHANGED(I12,0) | CHANGED(I13,0) | CHANGED(I14,0) | CHANGED(I15,0)}
+ PINDLY:
+  E/OBAR = {
+    CASE(
+      XX & (TRN_LH | TRN_HL), DELAY(-1,18NS,32NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,37NS,63NS),
+      DELAY(-1,38NS,64NS))}

.ENDS 74HCT7080

*------------------------------------------------------------74HC7245-----

* Octal Bus Schmitt-Trigger Transceiver; Tri-State
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1205 to 1208
* jat 9/18/96

.SUBCKT 74HC7245 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 OEBAR DIR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUFA(16) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ A0B A1B A2B A3B A4B A5B A6B A7B B0B B1B B2B B3B B4B B5B B6B B7B
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 LOGICEXP(2,2) DPWR DGND
+ DIR OEBAR
+ AB BA
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   AB = {~OEBAR & DIR}
+   BA = {~OEBAR & ~DIR}

U3 PINDLY(16,2,0) DPWR DGND
+ A0B A1B A2B A3B A4B A5B A6B A7B B0B B1B B2B B3B B4B B5B B6B B7B
+ AB BA
+ B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = AB
+   B0 B1 B2 B3 B4 B5 B6 B7 = {
+     CASE(
+       TRN_Z$, DELAY(-1,17NS,32NS),
+       TRN_$Z, DELAY(-1,19NS,32NS),
+       (TRN_LH | TRN_HL), DELAY(-1,12NS,20NS),
+       DELAY(-1,20NS,33NS))}
+ TRISTATE:
+ ENABLE HI = BA
+   A0 A1 A2 A3 A4 A5 A6 A7 = {
+     CASE(
+       TRN_Z$, DELAY(-1,17NS,32NS),
+       TRN_$Z, DELAY(-1,19NS,32NS),
+       (TRN_LH | TRN_HL), DELAY(-1,12NS,20NS),
+       DELAY(-1,20NS,33NS))}

.ENDS 74HC7245

*------------------------------------------------------------74HCT7245-----

* Octal Bus Schmitt-Trigger Transceiver; Tri-State
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1205 to 1208
* jat 9/18/96

.SUBCKT 74HCT7245 A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 OEBAR DIR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUFA(16) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ A0B A1B A2B A3B A4B A5B A6B A7B B0B B1B B2B B3B B4B B5B B6B B7B
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 LOGICEXP(2,2) DPWR DGND
+ DIR OEBAR
+ AB BA
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   AB = {~OEBAR & DIR}
+   BA = {~OEBAR & ~DIR}

U3 PINDLY(16,2,0) DPWR DGND
+ A0B A1B A2B A3B A4B A5B A6B A7B B0B B1B B2B B3B B4B B5B B6B B7B
+ AB BA
+ B0 B1 B2 B3 B4 B5 B6 B7 A0 A1 A2 A3 A4 A5 A6 A7
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = AB
+   B0 B1 B2 B3 B4 B5 B6 B7 = {
+     CASE(
+       TRN_Z$, DELAY(-1,19NS,32NS),
+       TRN_$Z, DELAY(-1,19NS,32NS),
+       (TRN_LH | TRN_HL), DELAY(-1,17NS,30NS),
+       DELAY(-1,20NS,33NS))}
+ TRISTATE:
+ ENABLE HI = BA
+   A0 A1 A2 A3 A4 A5 A6 A7 = {
+     CASE(
+       TRN_Z$, DELAY(-1,19NS,32NS),
+       TRN_$Z, DELAY(-1,19NS,32NS),
+       (TRN_LH | TRN_HL), DELAY(-1,17NS,30NS),
+       DELAY(-1,20NS,33NS))}

.ENDS 74HCT7245

*----------------------------------------------------------74HC7266-----

* The 74HC7266 2 Input Exclusive NOR Gates
* TI High Speed CMOS Logic Data Book, 1989, pages 2-695 to 2-697
* jat 8/11/95

.SUBCKT 74HC7266
+ 1A 1B 1Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1Y
+ DLYXNOR IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        1Y = {~(1A ^ 1B)}

.MODEL DLYXNOR UGATE(TPLHTY=12NS TPHLTY=12NS TPLHMX=20NS TPHLMX=20NS)

.ENDS 74HC7266

*------------------------------------------------------------74HC7540----

* Octal Schmitt Trigger Buffer/Line Driver; Tri-State; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1269 to 1273
* jat 9/18/96

.SUBCKT 74HC7540 A1 A2 A3 A4 A5 A6 A7 A8 Y1BAR Y2BAR Y3BAR Y4BAR
+ Y5BAR Y6BAR Y7BAR Y8BAR OE1BAR OE2BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ OE2BAR OE1BAR
+ EN
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   EN = {~(OE1BAR | OE2BAR)}

U2 INV3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8
+ EN
+ Y1BAR Y2BAR Y3BAR Y4BAR Y5BAR Y6BAR Y7BAR Y8BAR
+ DLY_HC7540 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC7540 UTGATE(TPZHTY=15NS TPZHMX=30NS TPZLTY=15NS TPZLMX=30NS
+                        TPHZTY=19NS TPHZMX=30NS TPLZTY=19NS TPLZMX=30NS
+                        TPLHTY=14NS TPLHMX=24NS TPHLTY=14NS TPHLMX=24NS)

.ENDS 74HC7540

*------------------------------------------------------------74HCT7540----

* Octal Schmitt Trigger Buffer/Line Driver; Tri-State; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1269 to 1273
* jat 9/18/96

.SUBCKT 74HCT7540 A1 A2 A3 A4 A5 A6 A7 A8 Y1BAR Y2BAR Y3BAR Y4BAR
+ Y5BAR Y6BAR Y7BAR Y8BAR OE1BAR OE2BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ OE2BAR OE1BAR
+ EN
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   EN = {~(OE1BAR | OE2BAR)}

U2 INV3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8
+ EN
+ Y1BAR Y2BAR Y3BAR Y4BAR Y5BAR Y6BAR Y7BAR Y8BAR
+ DLY_HCT7540 IO_HCT_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT7540 UTGATE(TPZHTY=19NS TPZHMX=32NS TPZLTY=19NS TPZLMX=32NS
+                        TPHZTY=20NS TPHZMX=32NS TPLZTY=20NS TPLZMX=32NS
+                        TPLHTY=19NS TPLHMX=32NS TPHLTY=19NS TPHLMX=32NS)

.ENDS 74HCT7540

*------------------------------------------------------------74HC7541----

* Octal Schmitt Trigger Buffer/Line Driver; Tri-State
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1275 to 1279
* jat 9/18/96

.SUBCKT 74HC7541 A1 A2 A3 A4 A5 A6 A7 A8 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 OE1BAR OE2BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ OE2BAR OE1BAR
+ EN
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   EN = {~(OE1BAR | OE2BAR)}

U2 BUF3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8
+ EN
+ Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+ DLY_HC7541 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC7541 UTGATE(TPZHTY=16NS TPZHMX=32NS TPZLTY=16NS TPZLMX=32NS
+                        TPHZTY=21NS TPHZMX=32NS TPLZTY=21NS TPLZMX=32NS
+                        TPLHTY=14NS TPLHMX=24NS TPHLTY=14NS TPHLMX=24NS)

.ENDS 74HC7541

*------------------------------------------------------------74HCT7541----

* Octal Schmitt Trigger Buffer/Line Driver; Tri-State
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1275 to 1279
* jat 9/18/96

.SUBCKT 74HCT7541 A1 A2 A3 A4 A5 A6 A7 A8 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 OE1BAR OE2BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ OE2BAR OE1BAR
+ EN
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   EN = {~(OE1BAR | OE2BAR)}

U2 BUF3A(8) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8
+ EN
+ Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+ DLY_HCT7541 IO_HCT_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT7541 UTGATE(TPZHTY=18NS TPZHMX=32NS TPZLTY=18NS TPZLMX=32NS
+                        TPHZTY=20NS TPHZMX=32NS TPLZTY=20NS TPLZMX=32NS
+                        TPLHTY=19NS TPLHMX=32NS TPHLTY=19NS TPHLMX=32NS)

.ENDS 74HCT7541

*------------------------------------------------------------74HC7597----

* 8-Bit Shift Register with Input Latches
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1281 to 1289
* jat 9/18/96

.SUBCKT 74HC7597 D0 D1 D2 D3 D4 D5 D6 D7 LEBAR MRBAR DS PLBAR SHCP Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,17) DPWR DGND
+ LEBAR MRBAR PLBAR D0 D1 D2 D3 D4 D5 D6 D7
+ LE SET0 SET1 SET2 SET3 SET4 SET5 SET6 SET7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5
+ CLR6 CLR7
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LE = {~LEBAR}
+   SET0 = {~MRBAR | (PLBAR | ~D0)}
+   CLR0 = {MRBAR & (PLBAR | D0)}
+   SET1 = {~MRBAR | (PLBAR | ~D1)}
+   CLR1 = {MRBAR & (PLBAR | D1)}
+   SET2 = {~MRBAR | (PLBAR | ~D2)}
+   CLR2 = {MRBAR & (PLBAR | D2)}
+   SET3 = {~MRBAR | (PLBAR | ~D3)}
+   CLR3 = {MRBAR & (PLBAR | D3)}
+   SET4 = {~MRBAR | (PLBAR | ~D4)}
+   CLR4 = {MRBAR & (PLBAR | D4)}
+   SET5 = {~MRBAR | (PLBAR | ~D5)}
+   CLR5 = {MRBAR & (PLBAR | D5)}
+   SET6 = {~MRBAR | (PLBAR | ~D6)}
+   CLR6 = {MRBAR & (PLBAR | D6)}
+   SET7 = {~MRBAR | (PLBAR | ~D7)}
+   CLR7 = {MRBAR & (PLBAR | D7)}

U2 DLTCH(8) DPWR DGND
+ $D_HI $D_HI LE
+ D0 D1 D2 D3 D4 D5 D6 D7
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+ D0_GFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ SET0 CLR0 SHCP
+ DS Q0SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+ SET1 CLR1 SHCP
+ Q0SH Q1SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+ SET2 CLR2 SHCP
+ Q1SH Q2SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DFF(1) DPWR DGND
+ SET3 CLR3 SHCP
+ Q2SH Q3SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DFF(1) DPWR DGND
+ SET4 CLR4 SHCP
+ Q3SH Q4SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DFF(1) DPWR DGND
+ SET5 CLR5 SHCP
+ Q4SH Q5SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DFF(1) DPWR DGND
+ SET6 CLR6 SHCP
+ Q5SH Q6SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 DFF(1) DPWR DGND
+ SET7 CLR7 SHCP
+ Q6SH Q7SH $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 PINDLY(1,0,5) DPWR DGND
+ Q7SH
+ SHCP MRBAR LEBAR PLBAR D7
+ Q
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  CLEAR = {CHANGED_HL(MRBAR,0)}
+  LOAD = {CHANGED_HL(PLBAR,0)}
+  LATCH = {CHANGED_HL(LEBAR,0)}
+  DATA = {CHANGED(D7,0)}
+  EDGE = {CHANGED_LH(SHCP,0)}
+ PINDLY:
+   Q = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,19NS,35NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,23NS,38NS),
+      LATCH & (TRN_LH | TRN_HL), DELAY(-1,26NS,50NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,23NS,38NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,18NS,35NS),
+      DELAY(-1,27NS,51NS))}

U12 CONSTRAINT(13) DPWR DGND
+ SHCP LEBAR MRBAR PLBAR D0 D1 D2 D3 D4 D5 D6 D7 DS
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  SHCP
+  MAXFREQ = 90MEG
+ WIDTH:
+  NODE = SHCP
+  MIN_HI = 4NS
+  MIN_LO = 4NS
+ WIDTH:
+  NODE = LEBAR
+  MIN_LO = 4NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 6NS
+ WIDTH:
+  NODE = PLBAR
+  MIN_LO = 6NS
+ SETUP_HOLD:
+  CLOCK HL = PLBAR
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 8NS
+ SETUP_HOLD:
+  CLOCK LH = LEBAR
+  DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+  SETUPTIME = 2NS
+ SETUP_HOLD:
+  CLOCK LH = SHCP
+  DATA(1) = DS
+  SETUPTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = SHCP
+  DATA(1) = PLBAR
+  SETUPTIME = 3NS

.ENDS 74HC7597

*------------------------------------------------------------74HCT7597----

* 8-Bit Shift Register with Input Latches
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1281 to 1289
* jat 9/18/96

.SUBCKT 74HCT7597 D0 D1 D2 D3 D4 D5 D6 D7 LEBAR MRBAR DS PLBAR SHCP Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,17) DPWR DGND
+ LEBAR MRBAR PLBAR D0 D1 D2 D3 D4 D5 D6 D7
+ LE SET0 SET1 SET2 SET3 SET4 SET5 SET6 SET7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5
+ CLR6 CLR7
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   LE = {~LEBAR}
+   SET0 = {~MRBAR | (PLBAR | ~D0)}
+   CLR0 = {MRBAR & (PLBAR | D0)}
+   SET1 = {~MRBAR | (PLBAR | ~D1)}
+   CLR1 = {MRBAR & (PLBAR | D1)}
+   SET2 = {~MRBAR | (PLBAR | ~D2)}
+   CLR2 = {MRBAR & (PLBAR | D2)}
+   SET3 = {~MRBAR | (PLBAR | ~D3)}
+   CLR3 = {MRBAR & (PLBAR | D3)}
+   SET4 = {~MRBAR | (PLBAR | ~D4)}
+   CLR4 = {MRBAR & (PLBAR | D4)}
+   SET5 = {~MRBAR | (PLBAR | ~D5)}
+   CLR5 = {MRBAR & (PLBAR | D5)}
+   SET6 = {~MRBAR | (PLBAR | ~D6)}
+   CLR6 = {MRBAR & (PLBAR | D6)}
+   SET7 = {~MRBAR | (PLBAR | ~D7)}
+   CLR7 = {MRBAR & (PLBAR | D7)}

U2 DLTCH(8) DPWR DGND
+ $D_HI $D_HI LE
+ D0 D1 D2 D3 D4 D5 D6 D7
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+ D0_GFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+ SET0 CLR0 SHCP
+ DS Q0SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+ SET1 CLR1 SHCP
+ Q0SH Q1SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+ SET2 CLR2 SHCP
+ Q1SH Q2SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 DFF(1) DPWR DGND
+ SET3 CLR3 SHCP
+ Q2SH Q3SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 DFF(1) DPWR DGND
+ SET4 CLR4 SHCP
+ Q3SH Q4SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 DFF(1) DPWR DGND
+ SET5 CLR5 SHCP
+ Q4SH Q5SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 DFF(1) DPWR DGND
+ SET6 CLR6 SHCP
+ Q5SH Q6SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 DFF(1) DPWR DGND
+ SET7 CLR7 SHCP
+ Q6SH Q7SH $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U11 PINDLY(1,0,5) DPWR DGND
+ Q7SH
+ SHCP MRBAR LEBAR PLBAR D7
+ Q
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  CLEAR = {CHANGED_HL(MRBAR,0)}
+  LOAD = {CHANGED_HL(PLBAR,0)}
+  LATCH = {CHANGED_HL(LEBAR,0)}
+  DATA = {CHANGED(D7,0)}
+  EDGE = {CHANGED_LH(SHCP,0)}
+ PINDLY:
+   Q = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,25NS,42NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,27NS,46NS),
+      LATCH & (TRN_LH | TRN_HL), DELAY(-1,31NS,53NS),
+      DATA & (TRN_LH | TRN_HL), DELAY(-1,28NS,49NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,20NS,35NS),
+      DELAY(-1,32NS,54NS))}

U12 CONSTRAINT(13) DPWR DGND
+ SHCP LEBAR MRBAR PLBAR D0 D1 D2 D3 D4 D5 D6 D7 DS
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  SHCP
+  MAXFREQ = 72MEG
+ WIDTH:
+  NODE = SHCP
+  MIN_HI = 6NS
+  MIN_LO = 6NS
+ WIDTH:
+  NODE = LEBAR
+  MIN_LO = 7NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 11NS
+ WIDTH:
+  NODE = PLBAR
+  MIN_LO = 9NS
+ SETUP_HOLD:
+  CLOCK HL = PLBAR
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 9NS
+ SETUP_HOLD:
+  CLOCK LH = LEBAR
+  DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+  SETUPTIME = 5NS
+ SETUP_HOLD:
+  CLOCK LH = SHCP
+  DATA(1) = DS
+  SETUPTIME = 5NS
+ SETUP_HOLD:
+  CLOCK LH = SHCP
+  DATA(1) = PLBAR
+  SETUPTIME = 3NS

.ENDS 74HCT7597

*------------------------------------------------------------74HC7731----

* Quad 64-bit static shift register
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1291 to 1297
* jat 9/19/96

.SUBCKT 74HC7731 DA DB CPA CPB RECAB QA QB
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,2) DPWR DGND
+ DA RECAB QA64 DB QB64
+ DATAA DATAB
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  DATAA= {(DA & ~RECAB) | (QA64 & RECAB)}
+  DATAB= {(DB & ~RECAB) | (QB64 & RECAB)}

U2 DFF(64) DPWR DGND
+ $D_HI $D_HI CPA
+ DATAA QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 QA9 QA10 QA11 QA12 QA13 QA14 QA15 QA16
+ QA17 QA18 QA19 QA20 QA21 QA22 QA23 QA24 QA25 QA26 QA27 QA28 QA29 QA30 QA31 QA32
+ QA33 QA34 QA35 QA36 QA37 QA38 QA39 QA40 QA41 QA42 QA43 QA44 QA45 QA46 QA47 QA48
+ QA49 QA50 QA51 QA52 QA53 QA54 QA55 QA56 QA57 QA58 QA59 QA60 QA61 QA62 QA63
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 QA9 QA10 QA11 QA12 QA13 QA14 QA15 QA16
+ QA17 QA18 QA19 QA20 QA21 QA22 QA23 QA24 QA25 QA26 QA27 QA28 QA29 QA30 QA31 QA32
+ QA33 QA34 QA35 QA36 QA37 QA38 QA39 QA40 QA41 QA42 QA43 QA44 QA45 QA46 QA47 QA48
+ QA49 QA50 QA51 QA52 QA53 QA54 QA55 QA56 QA57 QA58 QA59 QA60 QA61 QA62 QA63 QA64
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(64) DPWR DGND
+ $D_HI $D_HI CPB
+ DATAB QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 QB9 QB10 QB11 QB12 QB13 QB14 QB15 QB16
+ QB17 QB18 QB19 QB20 QB21 QB22 QB23 QB24 QB25 QB26 QB27 QB28 QB29 QB30 QB31 QB32
+ QB33 QB34 QB35 QB36 QB37 QB38 QB39 QB40 QB41 QB42 QB43 QB44 QB45 QB46 QB47 QB48
+ QB49 QB50 QB51 QB52 QB53 QB54 QB55 QB56 QB57 QB58 QB59 QB60 QB61 QB62 QB63
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 QB9 QB10 QB11 QB12 QB13 QB14 QB15 QB16
+ QB17 QB18 QB19 QB20 QB21 QB22 QB23 QB24 QB25 QB26 QB27 QB28 QB29 QB30 QB31 QB32
+ QB33 QB34 QB35 QB36 QB37 QB38 QB39 QB40 QB41 QB42 QB43 QB44 QB45 QB46 QB47 QB48
+ QB49 QB50 QB51 QB52 QB53 QB54 QB55 QB56 QB57 QB58 QB59 QB60 QB61 QB62 QB63 QB64
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(2,0,0) DPWR DGND
+ QA64 QB64
+ QA QB
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA QB = {
+    CASE(
+      (TRN_LH | TRN_HL), DELAY(-1,18NS,31NS),
+      DELAY(-1,19NS,32NS))}

U5 CONSTRAINT(5) DPWR DGND
+ CPA CPB DA DB RECAB
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  CPA
+  MAXFREQ = 78MEG
+ FREQ:
+  NODE =  CPB
+  MAXFREQ = 78MEG
+ WIDTH:
+  NODE = CPA
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ WIDTH:
+  NODE = CPB
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CPA
+  DATA(1) = DA
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CPB
+  DATA(1) = DB
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CPA
+  DATA(1) = RECAB
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CPB
+  DATA(1) = RECAB
+  SETUPTIME = 8NS

.ENDS 74HC7731

*------------------------------------------------------------74HCT7731----

* Quad 64-bit static shift register
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1291 to 1297
* jat 9/19/96

.SUBCKT 74HCT7731 DA DB CPA CPB RECAB QA QB
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,2) DPWR DGND
+ DA RECAB QA64 DB QB64
+ DATAA DATAB
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  DATAA= {(DA & ~RECAB) | (QA64 & RECAB)}
+  DATAB= {(DB & ~RECAB) | (QB64 & RECAB)}

U2 DFF(64) DPWR DGND
+ $D_HI $D_HI CPA
+ DATAA QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 QA9 QA10 QA11 QA12 QA13 QA14 QA15 QA16
+ QA17 QA18 QA19 QA20 QA21 QA22 QA23 QA24 QA25 QA26 QA27 QA28 QA29 QA30 QA31 QA32
+ QA33 QA34 QA35 QA36 QA37 QA38 QA39 QA40 QA41 QA42 QA43 QA44 QA45 QA46 QA47 QA48
+ QA49 QA50 QA51 QA52 QA53 QA54 QA55 QA56 QA57 QA58 QA59 QA60 QA61 QA62 QA63
+ QA1 QA2 QA3 QA4 QA5 QA6 QA7 QA8 QA9 QA10 QA11 QA12 QA13 QA14 QA15 QA16
+ QA17 QA18 QA19 QA20 QA21 QA22 QA23 QA24 QA25 QA26 QA27 QA28 QA29 QA30 QA31 QA32
+ QA33 QA34 QA35 QA36 QA37 QA38 QA39 QA40 QA41 QA42 QA43 QA44 QA45 QA46 QA47 QA48
+ QA49 QA50 QA51 QA52 QA53 QA54 QA55 QA56 QA57 QA58 QA59 QA60 QA61 QA62 QA63 QA64
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(64) DPWR DGND
+ $D_HI $D_HI CPB
+ DATAB QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 QB9 QB10 QB11 QB12 QB13 QB14 QB15 QB16
+ QB17 QB18 QB19 QB20 QB21 QB22 QB23 QB24 QB25 QB26 QB27 QB28 QB29 QB30 QB31 QB32
+ QB33 QB34 QB35 QB36 QB37 QB38 QB39 QB40 QB41 QB42 QB43 QB44 QB45 QB46 QB47 QB48
+ QB49 QB50 QB51 QB52 QB53 QB54 QB55 QB56 QB57 QB58 QB59 QB60 QB61 QB62 QB63
+ QB1 QB2 QB3 QB4 QB5 QB6 QB7 QB8 QB9 QB10 QB11 QB12 QB13 QB14 QB15 QB16
+ QB17 QB18 QB19 QB20 QB21 QB22 QB23 QB24 QB25 QB26 QB27 QB28 QB29 QB30 QB31 QB32
+ QB33 QB34 QB35 QB36 QB37 QB38 QB39 QB40 QB41 QB42 QB43 QB44 QB45 QB46 QB47 QB48
+ QB49 QB50 QB51 QB52 QB53 QB54 QB55 QB56 QB57 QB58 QB59 QB60 QB61 QB62 QB63 QB64
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(2,0,0) DPWR DGND
+ QA64 QB64
+ QA QB
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+   QA QB = {
+    CASE(
+      (TRN_LH | TRN_HL), DELAY(-1,24NS,42NS),
+      DELAY(-1,25NS,43NS))}

U5 CONSTRAINT(5) DPWR DGND
+ CPA CPB DA DB RECAB
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  CPA
+  MAXFREQ = 80MEG
+ FREQ:
+  NODE =  CPB
+  MAXFREQ = 80MEG
+ WIDTH:
+  NODE = CPA
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ WIDTH:
+  NODE = CPB
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CPA
+  DATA(1) = DA
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CPB
+  DATA(1) = DB
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CPA
+  DATA(1) = RECAB
+  SETUPTIME = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CPB
+  DATA(1) = RECAB
+  SETUPTIME = 6NS

.ENDS 74HCT7731

*-------------------------------------------------------74AC7623----------

* Octal Bus Transceiver, Tri-State (B Side), Open Drain (A Side), Non-Inverting
* Harris AnswerFax, file # 1969
* jat 9/3/96

.SUBCKT 74AC7623
+ OEBABAR OEAB A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,8) DPWR DGND
+ B0 B1 B2 B3 B4 B5 B6 B7 OEBABAR
+ B0O B1O B2O B3O B4O B5O B6O B7O
+ D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  B0O = {OEBABAR | B0}
+  B1O = {OEBABAR | B1}
+  B2O = {OEBABAR | B2}
+  B3O = {OEBABAR | B3}
+  B4O = {OEBABAR | B4}
+  B5O = {OEBABAR | B5}
+  B6O = {OEBABAR | B6}
+  B7O = {OEBABAR | B7}
 
U2 PINDLY(8,1,0) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7
+ OEAB
+ B0 B1 B2 B3 B4 B5 B6 B7
+ IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE HI = OEAB
+    B0 B1 B2 B3 B4 B5 B6 B7 = {
+       CASE(
+          TRN_Z$, DELAY(3.5NS,-1,12.2NS),
+          TRN_$Z, DELAY(3.5NS,-1,12.2NS),
+          TRN_LH, DELAY(2.8NS,-1,9.9NS),
+          TRN_HL, DELAY(2.8NS,-1,9.9NS),
+          DELAY(4.5NS,-1,13.2NS))}

U3 PINDLY(8,0,1) DPWR DGND
+ B0O B1O B2O B3O B4O B5O B6O B7O
+ OEBABAR
+ A0 A1 A2 A3 A4 A5 A6 A7
+ IO_AC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENABS = {CHANGED(OEBABAR,0)}
+ PINDLY:
+    A0 A1 A2 A3 A4 A5 A6 A7 = {
+       CASE(
+          ENABS & (TRN_LH | TRN_HL), DELAY(3.5NS,-1,12.2NS),
+          TRN_LH, DELAY(3.5NS,-1,12.2NS),
+          TRN_HL, DELAY(2.5NS,-1,8.7NS),
+          DELAY(4.5NS,-1,13.2NS))}

.ENDS 74AC7623

*-------------------------------------------------------74ACT7623----------

* Octal Bus Transceiver, Tri-State (B Side), Open Drain (A Side), Non-Inverting
* Harris AnswerFax, file # 1969
* jat 9/3/96

.SUBCKT 74ACT7623
+ OEBABAR OEAB A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,8) DPWR DGND
+ B0 B1 B2 B3 B4 B5 B6 B7 OEBABAR
+ B0O B1O B2O B3O B4O B5O B6O B7O
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  B0O = {OEBABAR | B0}
+  B1O = {OEBABAR | B1}
+  B2O = {OEBABAR | B2}
+  B3O = {OEBABAR | B3}
+  B4O = {OEBABAR | B4}
+  B5O = {OEBABAR | B5}
+  B6O = {OEBABAR | B6}
+  B7O = {OEBABAR | B7}
 
U2 PINDLY(8,1,0) DPWR DGND
+ A0 A1 A2 A3 A4 A5 A6 A7
+ OEAB
+ B0 B1 B2 B3 B4 B5 B6 B7
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE HI = OEAB
+    B0 B1 B2 B3 B4 B5 B6 B7 = {
+       CASE(
+          TRN_Z$, DELAY(3.8NS,-1,13.4NS),
+          TRN_$Z, DELAY(3.8NS,-1,13.4NS),
+          TRN_LH, DELAY(2.8NS,-1,9.9NS),
+          TRN_HL, DELAY(2.8NS,-1,9.9NS),
+          DELAY(4.8NS,-1,14.4NS))}

U3 PINDLY(8,0,1) DPWR DGND
+ B0O B1O B2O B3O B4O B5O B6O B7O
+ OEBABAR
+ A0 A1 A2 A3 A4 A5 A6 A7
+ IO_ACT_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENABS = {CHANGED(OEBABAR,0)}
+ PINDLY:
+    A0 A1 A2 A3 A4 A5 A6 A7 = {
+       CASE(
+          ENABS & (TRN_LH | TRN_HL), DELAY(3.8NS,-1,13.4NS),
+          TRN_LH, DELAY(3.8NS,-1,13.4NS),
+          TRN_HL, DELAY(2.8NS,-1,9.9NS),
+          DELAY(4.8NS,-1,14.4NS))}

.ENDS 74ACT7623

*----------------------------------------------------------74ALS8003---

* The 74ALS8003 2 Input Positive NAND Gate
* TI ALS/AS Logic Data Book, 1986, pages 2-929 to 2-930
* jat 8/11/95

.SUBCKT 74ALS8003
+ 1A 1B 1Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ 1A 1B 1Y
+ DLYNAND IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        1Y = {~(1A & 1B)}

.MODEL DLYNAND UGATE(TPLHMN=3NS TPHLMN=2NS TPLHMX=11NS TPHLMX=8NS)

.ENDS 74ALS8003

*------------------------------------------------------------74HC9014----

* Nine Wide Schmitt Trigger Buffer/Line Driver; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1299 to 1303
* jat 9/19/96

.SUBCKT 74HC9014 A0 Y0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INV DPWR DGND
+ A0 Y0BAR
+ DLY_HC9014 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC9014 UGATE(TPLHTY=12NS TPLHMX=21NS TPHLTY=12NS TPHLMX=21NS)

.ENDS 74HC9014

*------------------------------------------------------------74HCT9014----

* Nine Wide Schmitt Trigger Buffer/Line Driver; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1299 to 1303
* jat 9/19/96

.SUBCKT 74HCT9014 A0 Y0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INV DPWR DGND
+ A0 Y0BAR
+ DLY_HCT9014 IO_HCT_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT9014 UGATE(TPLHTY=19NS TPLHMX=32NS TPHLTY=19NS TPHLMX=32NS)

.ENDS 74HCT9014

*------------------------------------------------------------74HC9015----

* Nine Wide Schmitt Trigger Buffer/Line Driver
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1305 to 1309
* jat 9/19/96

.SUBCKT 74HC9015 A0 Y0
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUF DPWR DGND
+ A0 Y0
+ DLY_HC9015 IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC9015 UGATE(TPLHTY=12NS TPLHMX=21NS TPHLTY=12NS TPHLMX=21NS)

.ENDS 74HC9015

*------------------------------------------------------------74HCT9015----

* Nine Wide Schmitt Trigger Buffer/Line Driver
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1305 to 1309
* jat 9/19/96

.SUBCKT 74HCT9015 A0 Y0
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUF DPWR DGND
+ A0 Y0
+ DLY_HCT9015 IO_HCT_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT9015 UGATE(TPLHTY=18NS TPLHMX=32NS TPHLTY=18NS TPHLMX=32NS)

.ENDS 74HCT9015

*------------------------------------------------------------74HC9114----

* Nine Wide Schmitt Trigger Buffer/Line Driver; Open Drain Outputs; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1347 to 1351
* jat 9/19/96

.SUBCKT 74HC9114 A0 Y0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INV DPWR DGND
+ A0 Y0BARO
+ D0_GATE IO_HC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(1,0,0) DPWR DGND
+ Y0BARO Y0BAR
+ IO_HC_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ PINDLY:
+  Y0BAR = {
+   CASE(
+    (TRN_LH | TRN_HL), DELAY(-1,13NS,22NS),
+    DELAY(-1,14NS,23NS))}

.ENDS 74HC9114

*------------------------------------------------------------74HCT9114----

* Nine Wide Schmitt Trigger Buffer/Line Driver; Open Drain Outputs; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1347 to 1351
* jat 9/19/96

.SUBCKT 74HCT9114 A0 Y0BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INV DPWR DGND
+ A0 Y0BAR
+ DLY_HCT9114 IO_HCT_OC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT9114 UGATE(TPLHTY=17NS TPLHMX=31NS TPHLTY=17NS TPHLMX=31NS)

.ENDS 74HCT9114

*------------------------------------------------------------74HC9115----

* Nine Wide Schmitt Trigger Buffer/Line Driver; Open Drain Outputs
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1353 to 1357
* jat 9/19/96

.SUBCKT 74HC9115 A0 Y0
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUF DPWR DGND
+ A0 Y0
+ DLY_HC9115 IO_HC_OC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HC9115 UGATE(TPLHTY=13NS TPLHMX=22NS TPHLTY=13NS TPHLMX=22NS)

.ENDS 74HC9115

*------------------------------------------------------------74HCT9115----

* Nine Wide Schmitt Trigger Buffer/Line Driver; Open Drain Outputs
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1353 to 1357
* jat 9/19/96

.SUBCKT 74HCT9115 A0 Y0
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 BUF DPWR DGND
+ A0 Y0
+ DLY_HCT9115 IO_HCT_OC_ST MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_HCT9115 UGATE(TPLHTY=18NS TPLHMX=31NS TPHLTY=18NS TPHLMX=31NS)

.ENDS 74HCT9115

*----------------------------------------------------------74ALS29806----

* Comparator and 2-to-4 Bit Decoder
* TI ALS/AS Logic Data Book, 1986, pages 2-931 to 2-937
* jat 3/28/96

.SUBCKT 74ALS29806
+ GBAR P0 P1 P2 P3 P4 P5 Q0 Q1 Q2 Q3 Q4 Q5 CBAR S0 S1 PEQQBAR ACKBAR
+ Y0 Y1 Y2 Y3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,6) DPWR DGND
+ GBAR P0 P1 P2 P3 P4 P5 Q0 Q1 Q2 Q3 Q4 Q5 CBAR S0 S1
+ PEQQBARO ACKBARO Y0O Y1O Y2O Y3O
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   X0 = {~(~P0 ^ ~Q0)}
+   X1 = {~(~P1 ^ ~Q1)}
+   X2 = {~(~P2 ^ ~Q2)}
+   X3 = {~(~P3 ^ ~Q3)}
+   X4 = {~(~P4 ^ ~Q4)}
+   X5 = {~(~P5 ^ ~Q5)}
+   PEQQBARO = {~(~GBAR & X0 & X1 & X2 & X3 & X4 & X5)}
+   ACKBARO = {~(~PEQQBARO & ~CBAR)}
+   Y0O = {~(~PEQQBARO & ~S0 & ~S1)}
+   Y1O = {~(~PEQQBARO & S0 & ~S1)}
+   Y2O = {~(~PEQQBARO & ~S0 & S1)}
+   Y3O = {~(~PEQQBARO & S0 & S1)}

U2 PINDLY(6,0,16) DPWR DGND
+ PEQQBARO ACKBARO Y0O Y1O Y2O Y3O
+ GBAR CBAR P0 P1 P2 P3 P4 P5 Q0 Q1 Q2 Q3 Q4 Q5 S0 S1
+ PEQQBAR ACKBARSTD Y0 Y1 Y2 Y3
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) |
+            CHANGED(P5,0) | CHANGED(P5,0) | CHANGED(Q0,0) | CHANGED(Q1,0) |
+            CHANGED(Q2,0) | CHANGED(Q3,0) | CHANGED(Q4,0) | CHANGED(Q5,0)}
+    G = {CHANGED(GBAR,0)}
+    SELECT = {CHANGED(S0,0) | CHANGED(S1,0)}
+    C = {CHANGED(CBAR,0)}
+ PINDLY:
+    PEQQBAR = {
+      CASE(
+        G & TRN_LH, DELAY(-1,9NS,12NS),
+        G & TRN_HL, DELAY(-1,7NS,10NS),
+        DATA & TRN_LH, DELAY(-1,8NS,11NS),
+        DATA & TRN_HL, DELAY(-1,7NS,10NS),
+        DELAY(-1,10NS,13NS))}
+    Y0 Y1 Y2 Y3 = {
+      CASE(
+        G & TRN_LH, DELAY(-1,8NS,11NS),
+        G & TRN_HL, DELAY(-1,10NS,13NS),
+        SELECT & TRN_LH, DELAY(-1,6NS,10NS),
+        SELECT & TRN_HL, DELAY(-1,8NS,11NS),
+        DATA & TRN_LH, DELAY(-1,9NS,11NS),
+        DATA & TRN_HL, DELAY(-1,9NS,12NS),
+        DELAY(-1,11NS,14NS))}
+    ACKBARSTD = {
+      CASE(
+        G & TRN_LH, DELAY(-1,10NS,14NS),
+        G & TRN_HL, DELAY(-1,10NS,14NS),
+        C & TRN_LH, DELAY(-1,8NS,11NS),
+        C & TRN_HL, DELAY(-1,7NS,11NS),
+        DATA & TRN_LH, DELAY(-1,11NS,14NS),
+        DATA & TRN_HL, DELAY(-1,10NS,13NS),
+        DELAY(-1,12NS,15NS))}

U3 BUF DPWR DGND
+ ACKBARSTD ACKBAR
+ D0_GATE IO_ALS000_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS 74ALS29806

*----------------------------------------------------------74ALS29809----

* Comparator and 2-to-4 Bit Decoder
* TI ALS/AS Logic Data Book, 1986, pages 2-931 to 2-937
* jat 3/28/96

.SUBCKT 74ALS29809
+ GBAR P0 P1 P2 P3 P4 P5 P6 P7 P8 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 CBAR PEQQBAR ACKBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(20,2) DPWR DGND
+ GBAR P0 P1 P2 P3 P4 P5 P6 P7 P8 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8 CBAR
+ PEQQBARO ACKBARO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   X0 = {~(~P0 ^ ~Q0)}
+   X1 = {~(~P1 ^ ~Q1)}
+   X2 = {~(~P2 ^ ~Q2)}
+   X3 = {~(~P3 ^ ~Q3)}
+   X4 = {~(~P4 ^ ~Q4)}
+   X5 = {~(~P5 ^ ~Q5)}
+   X6 = {~(~P6 ^ ~Q6)}
+   X7 = {~(~P7 ^ ~Q7)}
+   X8 = {~(~P8 ^ ~Q8)}
+   PEQQBARO = {~(~GBAR & X0 & X1 & X2 & X3 & X4 & X5 & X6 & X7 & X8)}
+   ACKBARO = {~(~PEQQBARO & ~CBAR)}

U2 PINDLY(2,0,20) DPWR DGND
+ PEQQBARO ACKBARO
+ GBAR CBAR P0 P1 P2 P3 P4 P5 P6 P7 P8 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 Q8
+ PEQQBAR ACKBARSTD
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) |
+            CHANGED(P5,0) | CHANGED(P5,0) | CHANGED(Q0,0) | CHANGED(Q1,0) |
+            CHANGED(Q2,0) | CHANGED(Q3,0) | CHANGED(Q4,0) | CHANGED(Q5,0) |
+            CHANGED(P6,0) | CHANGED(P7,0) | CHANGED(P8,0) | CHANGED(Q6,0) |
+            CHANGED(Q7,0) | CHANGED(Q8,0)}
+    G = {CHANGED(GBAR,0)}
+    C = {CHANGED(CBAR,0)}
+ PINDLY:
+    PEQQBAR = {
+      CASE(
+        G & TRN_LH, DELAY(-1,9NS,12NS),
+        G & TRN_HL, DELAY(-1,7NS,10NS),
+        DATA & TRN_LH, DELAY(-1,8NS,11NS),
+        DATA & TRN_HL, DELAY(-1,7NS,10NS),
+        DELAY(-1,10NS,13NS))}
+    ACKBARSTD = {
+      CASE(
+        G & TRN_LH, DELAY(-1,10NS,14NS),
+        G & TRN_HL, DELAY(-1,10NS,14NS),
+        C & TRN_LH, DELAY(-1,8NS,11NS),
+        C & TRN_HL, DELAY(-1,7NS,11NS),
+        DATA & TRN_LH, DELAY(-1,11NS,14NS),
+        DATA & TRN_HL, DELAY(-1,10NS,13NS),
+        DELAY(-1,12NS,15NS))}

U3 BUF DPWR DGND
+ ACKBARSTD ACKBAR
+ D0_GATE IO_ALS000_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.ENDS 74ALS29809

*----------------------------------------------------------74ALS29821---

* The 74ALS29821 10 Bit Bus Interface Flip-Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-939 to 2-944
* jat 8/11/95

.SUBCKT 74ALS29821
+ OCBAR CLK 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(10) DPWR DGND
+ $D_HI $D_HI CLK
+ 1D 2D 3D 4D 5D 6D 7D 8D 9D 10D
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q 10_Q
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(10,1,1) DPWR DGND
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q 10_Q
+ OCBAR
+ CLK
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+    ENABLE LO = OCBAR
+       1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q = {
+          CASE(
+            TRN_HZ, DELAY(-1,5NS,-1),
+            TRN_LZ, DELAY(-1,6NS,-1),
+            TRN_ZH, DELAY(-1,12NS,-1),
+            TRN_ZL, DELAY(-1,11NS,-1),
+            EDGE & TRN_LH, DELAY(-1,6NS,-1),
+            EDGE & TRN_HL, DELAY(-1,7NS,-1),
+            DELAY(-1,13NS,-1))}

.ENDS 74ALS29821

*----------------------------------------------------------74ALS29822---

* The 74ALS29822 10 Bit Bus Interface Flip-Flops with 3-State Outputs (Invert)
* TI ALS/AS Logic Data Book, 1986, pages 2-939 to 2-944
* jat 8/11/95

.SUBCKT 74ALS29822
+ OCBAR CLK 1DBAR 2DBAR 3DBAR 4DBAR 5DBAR 6DBAR 7DBAR 8DBAR 9DBAR 10DBAR
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(10) DPWR DGND
+ 1DBAR 2DBAR 3DBAR 4DBAR 5DBAR 6DBAR 7DBAR 8DBAR 9DBAR 10DBAR
+ 1DBARIN 2DBARIN 3DBARIN 4DBARIN 5DBARIN 6DBARIN 7DBARIN 8DBARIN 9DBARIN
+ 10DBARIN
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(10) DPWR DGND
+ $D_HI $D_HI CLK
+ 1DBARIN 2DBARIN 3DBARIN 4DBARIN 5DBARIN 6DBARIN 7DBARIN 8DBARIN 9DBARIN
+ 10DBARIN
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q 10_Q
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(10,1,1) DPWR DGND
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q 10_Q
+ OCBAR
+ CLK
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED_LH(CLK,0)}
+ TRISTATE:
+    ENABLE LO = OCBAR
+       1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q 10Q = {
+          CASE(
+            TRN_HZ, DELAY(-1,5NS,-1),
+            TRN_LZ, DELAY(-1,6NS,-1),
+            TRN_ZH, DELAY(-1,12NS,-1),
+            TRN_ZL, DELAY(-1,11NS,-1),
+            EDGE & TRN_LH, DELAY(-1,6NS,-1),
+            EDGE & TRN_HL, DELAY(-1,7NS,-1),
+            DELAY(-1,13NS,-1))}

.ENDS 74ALS29822

*-------------------------------------------------------------74ALS29823---

* The 74ALS29823 9 Bit Bus Interface Flip-Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-949 to 2-955
* jat 8/11/95

.SUBCKT 74ALS29823
+ OCBAR CLK CLRBAR CLKENBAR 1D 2D 3D 4D 5D 6D 7D 8D 9D 1Q 2Q 3Q 4Q 5Q 6Q
+ 7Q 8Q 9Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(2,1) DPWR DGND
+ CLK CLKENBAR
+ CLOCK
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        CLOCK = {(~CLKENBAR) & CLK}

U2 DFF(9) DPWR DGND
+ $D_HI CLRBAR CLOCK
+ 1D 2D 3D 4D 5D 6D 7D 8D 9D
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(9,1,2) DPWR DGND
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q
+ OCBAR
+ CLK CLRBAR
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED_LH(CLK,0)}
+    CLEAR = {CHANGED_HL(CLRBAR,0)}
+ TRISTATE:
+    ENABLE LO = OCBAR
+       1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q = {
+          CASE(
+            TRN_HZ, DELAY(-1,5NS,-1),
+            TRN_LZ, DELAY(-1,5.5NS,-1),
+            TRN_ZH, DELAY(-1,12NS,-1),
+            TRN_ZL, DELAY(-1,11NS,-1),
+            CLEAR & TRN_HL, DELAY(-1,13NS,-1),
+            EDGE & TRN_LH, DELAY(-1,5.5NS,-1),
+            EDGE & TRN_HL, DELAY(-1,6.5NS,-1),
+            DELAY(-1,14NS,-1))}

.ENDS 74ALS29823

*-------------------------------------------------------------74ALS29824---

* The 74ALS29824 9 Bit Bus Interface Flip-Flops with 3-State Outputs (Invert)
* TI ALS/AS Logic Data Book, 1986, pages 2-949 to 2-955
* jat 8/11/95

.SUBCKT 74ALS29824
+ OCBAR CLK CLRBAR CLKENBAR 1DBAR 2DBAR 3DBAR 4DBAR 5DBAR 6DBAR 7DBAR 8DBAR
+ 9DBAR 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(9) DPWR DGND
+ 1DBAR 2DBAR 3DBAR 4DBAR 5DBAR 6DBAR 7DBAR 8DBAR 9DBAR
+ 1_DBAR 2_DBAR 3_DBAR 4_DBAR 5_DBAR 6_DBAR 7_DBAR 8_DBAR 9_DBAR
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 LOGICEXP(2,1) DPWR DGND
+ CLK CLKENBAR
+ CLOCK
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        CLOCK = {(~CLKENBAR) & CLK}

U3 DFF(9) DPWR DGND
+ $D_HI CLRBAR CLOCK
+ 1_DBAR 2_DBAR 3_DBAR 4_DBAR 5_DBAR 6_DBAR 7_DBAR 8_DBAR 9_DBAR
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(9,1,2) DPWR DGND
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q 9_Q
+ OCBAR
+ CLK CLRBAR
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED_LH(CLK,0)}
+    CLEAR = {CHANGED_HL(CLRBAR,0)}
+ TRISTATE:
+    ENABLE LO = OCBAR
+       1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q 9Q = {
+          CASE(
+            TRN_HZ, DELAY(-1,5NS,-1),
+            TRN_LZ, DELAY(-1,5.5NS,-1),
+            TRN_ZH, DELAY(-1,12NS,-1),
+            TRN_ZL, DELAY(-1,11NS,-1),
+            CLEAR & TRN_HL, DELAY(-1,13NS,-1),
+            EDGE & TRN_LH, DELAY(-1,5.5NS,-1),
+            EDGE & TRN_HL, DELAY(-1,6.5NS,-1),
+            DELAY(-1,14NS,-1))}

.ENDS 74ALS29824

*-------------------------------------------------------------74ALS29825---

* The 74ALS29825 8 Bit Bus Interface Flip-Flops with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-961 to 2-966
* jat 8/11/95

.SUBCKT 74ALS29825
+ OC1BAR OC2BAR OC3BAR CLK CLRBAR CLKENBAR 1D 2D 3D 4D 5D 6D 7D 8D
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,2) DPWR DGND
+ CLK CLKENBAR OC1BAR OC2BAR OC3BAR
+ CLOCK GO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        CLOCK = {(~CLKENBAR) & CLK}
+        GO = {~(OC1BAR | OC2BAR | OC3BAR)}

U2 DFF(8) DPWR DGND
+ $D_HI CLRBAR CLOCK
+ 1D 2D 3D 4D 5D 6D 7D 8D
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,1,2) DPWR DGND
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q
+ GO
+ CLK CLRBAR
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED_LH(CLK,0)}
+    CLEAR = {CHANGED_HL(CLRBAR,0)}
+ TRISTATE:
+    ENABLE HI = GO
+       1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q = {
+          CASE(
+            TRN_HZ, DELAY(-1,5NS,-1),
+            TRN_LZ, DELAY(-1,6NS,-1),
+            TRN_ZH, DELAY(-1,12NS,-1),
+            TRN_ZL, DELAY(-1,11NS,-1),
+            CLEAR & TRN_HL, DELAY(-1,13NS,-1),
+            EDGE & TRN_LH, DELAY(-1,6NS,-1),
+            EDGE & TRN_HL, DELAY(-1,7NS,-1),
+            DELAY(-1,14NS,-1))}

.ENDS 74ALS29825

*-------------------------------------------------------------74ALS29826---

* The 74ALS29826 8 Bit Bus Interface Flip-Flops with 3-State Outputs (Invert)
* TI ALS/AS Logic Data Book, 1986, pages 2-961 to 2-966
* jat 8/11/95

.SUBCKT 74ALS29826
+ OC1BAR OC2BAR OC3BAR CLK CLRBAR CLKENBAR 1DBAR 2DBAR 3DBAR 4DBAR 5DBAR
+ 6DBAR 7DBAR 8DBAR 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(8) DPWR DGND
+ 1DBAR 2DBAR 3DBAR 4DBAR 5DBAR 6DBAR 7DBAR 8DBAR
+ 1_DBAR 2_DBAR 3_DBAR 4_DBAR 5_DBAR 6_DBAR 7_DBAR 8_DBAR
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 LOGICEXP(5,2) DPWR DGND
+ CLK CLKENBAR OC1BAR OC2BAR OC3BAR
+ CLOCK GO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        CLOCK = {(~CLKENBAR) & CLK}
+        GO = {~(OC1BAR | OC2BAR | OC3BAR)}

U3 DFF(8) DPWR DGND
+ $D_HI CLRBAR CLOCK
+ 1_DBAR 2_DBAR 3_DBAR 4_DBAR 5_DBAR 6_DBAR 7_DBAR 8_DBAR
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(8,1,2) DPWR DGND
+ 1_Q 2_Q 3_Q 4_Q 5_Q 6_Q 7_Q 8_Q
+ GO
+ CLK CLRBAR
+ 1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED_LH(CLK,0)}
+    CLEAR = {CHANGED_HL(CLRBAR,0)}
+ TRISTATE:
+    ENABLE HI = GO
+       1Q 2Q 3Q 4Q 5Q 6Q 7Q 8Q = {
+          CASE(
+            TRN_HZ, DELAY(-1,5NS,-1),
+            TRN_LZ, DELAY(-1,6NS,-1),
+            TRN_ZH, DELAY(-1,12NS,-1),
+            TRN_ZL, DELAY(-1,11NS,-1),
+            CLEAR & TRN_HL, DELAY(-1,13NS,-1),
+            EDGE & TRN_LH, DELAY(-1,6NS,-1),
+            EDGE & TRN_HL, DELAY(-1,7NS,-1),
+            DELAY(-1,14NS,-1))}

.ENDS 74ALS29826

*-----------------------------------------------------------74ALS29827---

* The 74ALS29827 10 Bit Buffers and Bus Drivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-971 to 2-975
* jat 8/11/95

.SUBCKT 74ALS29827
+ G1BAR G2BAR A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 NOR(2) DPWR DGND
+ G1BAR G2BAR
+ GO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(10,1,0) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10
+ GO
+ Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+      ENABLE HI = GO
+      Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 = {
+        CASE(
+          TRN_HZ, DELAY(-1,10NS,16NS),
+          TRN_LZ, DELAY(-1,4NS,9NS),
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5N,12NS),
+          TRN_LH, DELAY(-1,3.5NS,6NS),
+          TRN_HL, DELAY(-1,6.5NS,8NS),
+          DELAY(-1,11NS,17NS))}

.ENDS 74ALS29827

*-----------------------------------------------------------74ALS29828---

* The 74ALS29828 10 Bit Buffers and Bus Drivers with 3-State Outputs (Invert)
* TI ALS/AS Logic Data Book, 1986, pages 2-971 to 2-975
* jat 8/11/95

.SUBCKT 74ALS29828
+ G1BAR G2BAR A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 NOR(2) DPWR DGND
+ G1BAR G2BAR
+ GO
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 INVA(10) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10
+ A1BAR A2BAR A3BAR A4BAR A5BAR A6BAR A7BAR A8BAR A9BAR A10BAR
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(10,1,0) DPWR DGND
+ A1BAR A2BAR A3BAR A4BAR A5BAR A6BAR A7BAR A8BAR A9BAR A10BAR
+ GO
+ Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+      ENABLE HI = GO
+      Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9 Y10 = {
+        CASE(
+          TRN_HZ, DELAY(-1,10NS,16NS),
+          TRN_LZ, DELAY(-1,4NS,9NS),
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5N,12NS),
+          TRN_LH, DELAY(-1,4NS,5.2NS),
+          TRN_HL, DELAY(-1,3NS,5.9NS),
+          DELAY(-1,11NS,17NS))}

.ENDS 74ALS29828

*-------------------------------------------------------74ALS29861-----

* 10-Bit Bus Transceivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-989 to 2-994
* jat 3/28/96

.SUBCKT 74ALS29861
+ GBABAR GABBAR A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 PINDLY(20,2,0) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10
+ GABBAR GBABAR
+ B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE LO = GBABAR
+    A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,3.5NS,8NS),
+          TRN_LZ, DELAY(-1,3.5NS,8NS),
+          TRN_LH, DELAY(-1,4.8NS,6NS),
+          TRN_HL, DELAY(-1,5.2NS,6.2NS),
+          DELAY(-1,10.5NS,13NS))}
+ TRISTATE:
+    ENABLE LO = GABBAR
+    B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,3.5NS,8NS),
+          TRN_LZ, DELAY(-1,3.5NS,8NS),
+          TRN_LH, DELAY(-1,4.8NS,6NS),
+          TRN_HL, DELAY(-1,5.2NS,6.2NS),
+          DELAY(-1,10.5NS,13NS))}

.ENDS 74ALS29861

*-------------------------------------------------------74ALS29862-----

* 10-Bit Bus Transceivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-989 to 2-994
* jat 3/28/96

.SUBCKT 74ALS29862
+ GBABAR GABBAR A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(20) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10
+ B1O B2O B3O B4O B5O B6O B7O B8O B9O B10O A1O A2O A3O A4O A5O A6O A7O A8O A9O A10O
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL} 

U2 PINDLY(20,2,0) DPWR DGND
+ A1O A2O A3O A4O A5O A6O A7O A8O A9O A10O B1O B2O B3O B4O B5O B6O B7O B8O B9O B10O
+ GABBAR GBABAR
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE LO = GBABAR
+    A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,3.5NS,8NS),
+          TRN_LZ, DELAY(-1,3.5NS,8NS),
+          TRN_LH, DELAY(-1,4NS,5.2NS),
+          TRN_HL, DELAY(-1,3NS,5.9NS),
+          DELAY(-1,10.5NS,13NS))}
+ TRISTATE:
+    ENABLE LO = GABBAR
+    B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,3.5NS,8NS),
+          TRN_LZ, DELAY(-1,3.5NS,8NS),
+          TRN_LH, DELAY(-1,4NS,5.2NS),
+          TRN_HL, DELAY(-1,3NS,5.9NS),
+          DELAY(-1,10.5NS,13NS))}

.ENDS 74ALS29862

*-------------------------------------------------------74ALS29863-----

* 9-Bit Bus Transceivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-995 to 2-999
* jat 3/28/96

.SUBCKT 74ALS29863
+ GBA1BAR GBA2BAR GAB1BAR GAB2BAR A1 A2 A3 A4 A5 A6 A7 A8 A9 B1 B2 B3 B4 B5 B6 B7 B8 B9
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(4,2) DPWR DGND
+ GBA1BAR GBA2BAR GAB1BAR GAB2BAR
+ ENABAB ENABBA
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABAB = {~GAB1BAR & ~GAB2BAR}
+   ENABBA = {~GBA1BAR & ~GBA2BAR}

U2 PINDLY(18,2,0) DPWR DGND
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 B1 B2 B3 B4 B5 B6 B7 B8 B9
+ ENABAB ENABBA
+ B1 B2 B3 B4 B5 B6 B7 B8 B9 A1 A2 A3 A4 A5 A6 A7 A8 A9
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE HI = ENABBA
+    A1 A2 A3 A4 A5 A6 A7 A8 A9 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,4.5NS,8NS),
+          TRN_LZ, DELAY(-1,4.5NS,8NS),
+          TRN_LH, DELAY(-1,3.5NS,6NS),
+          TRN_HL, DELAY(-1,6.5NS,8NS),
+          DELAY(-1,10.5NS,13NS))}
+ TRISTATE:
+    ENABLE HI = ENABAB
+    B1 B2 B3 B4 B5 B6 B7 B8 B9 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,4.5NS,8NS),
+          TRN_LZ, DELAY(-1,4.5NS,8NS),
+          TRN_LH, DELAY(-1,3.5NS,6NS),
+          TRN_HL, DELAY(-1,6.5NS,8NS),
+          DELAY(-1,10.5NS,13NS))}

.ENDS 74ALS29863

*-------------------------------------------------------74ALS29864-----

* 9-Bit Bus Transceivers with 3-State Outputs
* TI ALS/AS Logic Data Book, 1986, pages 2-995 to 2-999
* jat 3/28/96

.SUBCKT 74ALS29864
+ GBA1BAR GBA2BAR GAB1BAR GAB2BAR A1 A2 A3 A4 A5 A6 A7 A8 A9 B1 B2 B3 B4 B5 B6 B7 B8 B9
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(22,20) DPWR DGND
+ GBA1BAR GBA2BAR GAB1BAR GAB2BAR A1 A2 A3 A4 A5 A6 A7 A8 A9
+ B1 B2 B3 B4 B5 B6 B7 B8 B9
+ ENABAB ENABBA A1O A2O A3O A4O A5O A6O A7O A8O A9O
+ B1O B2O B3O B4O B5O B6O B7O B8O B9O
+ D0_GATE IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABAB = {~GAB1BAR & ~GAB2BAR}
+   ENABBA = {~GBA1BAR & ~GBA2BAR}
+   B1O = {~A1}
+   B2O = {~A2}
+   B3O = {~A3}
+   B4O = {~A4}
+   B5O = {~A5}
+   B6O = {~A6}
+   B7O = {~A7}
+   B8O = {~A8}
+   B9O = {~A9}
+   A1O = {~B1}
+   A2O = {~B2}
+   A3O = {~B3}
+   A4O = {~B4}
+   A5O = {~B5}
+   A6O = {~B6}
+   A7O = {~B7}
+   A8O = {~B8}
+   A9O = {~B9}

U2 PINDLY(18,2,0) DPWR DGND
+ A1O A2O A3O A4O A5O A6O A7O A8O A9O B1O B2O B3O B4O B5O B6O B7O B8O B9O
+ ENABAB ENABBA
+ A1 A2 A3 A4 A5 A6 A7 A8 A9 B1 B2 B3 B4 B5 B6 B7 B8 B9
+ IO_ALS000 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+    ENABLE HI = ENABBA
+    A1 A2 A3 A4 A5 A6 A7 A8 A9 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,6NS,8NS),
+          TRN_LZ, DELAY(-1,3.5NS,8NS),
+          TRN_LH, DELAY(-1,5NS,6NS),
+          TRN_HL, DELAY(-1,3NS,8NS),
+          DELAY(-1,10.5NS,13NS))}
+ TRISTATE:
+    ENABLE HI = ENABAB
+    B1 B2 B3 B4 B5 B6 B7 B8 B9 = {
+       CASE(
+          TRN_ZH, DELAY(-1,6.5NS,12NS),
+          TRN_ZL, DELAY(-1,9.5NS,12NS),
+          TRN_HZ, DELAY(-1,6NS,8NS),
+          TRN_LZ, DELAY(-1,3.5NS,8NS),
+          TRN_LH, DELAY(-1,5NS,6NS),
+          TRN_HL, DELAY(-1,3NS,8NS),
+          DELAY(-1,10.5NS,13NS))}

.ENDS 74ALS29864

*------------------------------------------------------------74F30240----

* Octal 30-Ohm Line Driver with Enable, Inverting (Open Collector)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 1008 to 1013
* jat 8/1/96

.SUBCKT 74F30240
+ OEBAR D0 D1 D2 D3 Q0BAR Q1BAR Q2BAR Q3BAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,4) DPWR DGND
+ D0 D1 D2 D3 OEBAR
+ Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   Q0BARO = {OEBAR | ~D0}
+   Q1BARO = {OEBAR | ~D1}
+   Q2BARO = {OEBAR | ~D2}
+   Q3BARO = {OEBAR | ~D3}

U2 PINDLY(4,0,5) DPWR DGND
+ Q0BARO Q1BARO Q2BARO Q3BARO
+ OEBAR D0 D1 D2 D3
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ IO_F_OC_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)}
+   OUT = {CHANGED(OEBAR,0)}
+ PINDLY:
+   Q0BAR Q1BAR Q2BAR Q3BAR = {
+      CASE(
+        OUT & TRN_LH, DELAY(4NS,10NS,14NS),
+        OUT & TRN_HL, DELAY(3.5NS,6NS,9NS),
+        DATA & TRN_LH, DELAY(4NS,10NS,14.5NS),
+        DATA & TRN_HL, DELAY(1NS,2NS,5NS),
+        DELAY(5NS,11NS,15.5NS))}

.ENDS 74F30240

*-----------------------------------------------------------74F30244----

* Octal 30-Ohm Line Driver with Enable, Non-Inverting (Open Collector)
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 1008 to 1013
* jat 8/1/96

.SUBCKT 74F30244
+ OEBAR D0 D1 D2 D3 Q0 Q1 Q2 Q3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(5,4) DPWR DGND
+ D0 D1 D2 D3 OEBAR
+ Q0O Q1O Q2O Q3O
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   Q0O = {OEBAR | D0}
+   Q1O = {OEBAR | D1}
+   Q2O = {OEBAR | D2}
+   Q3O = {OEBAR | D3}

U2 PINDLY(4,0,5) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ OEBAR D0 D1 D2 D3
+ Q0 Q1 Q2 Q3
+ IO_F_OC_30 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)}
+   OUT = {CHANGED(OEBAR,0)}
+ PINDLY:
+   Q0 Q1 Q2 Q3 = {
+      CASE(
+        OUT & TRN_LH, DELAY(4NS,9.5NS,14NS),
+        OUT & TRN_HL, DELAY(3.5NS,6NS,9NS),
+        DATA & TRN_LH, DELAY(4NS,10.5NS,14.5NS),
+        DATA & TRN_HL, DELAY(3NS,5.5NS,9NS),
+        DELAY(5NS,11.5NS,15.5NS))}

.ENDS 74F30244

*------------------------------------------------------------74HC40102----

* 8-Bit Synchronous BCD Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1359 to 1366
* jat 9/19/96

.SUBCKT 74HC40102 CP PLBAR TEBAR PEBAR MRBAR TCBAR P0 P1 P2 P3 P4 P5 P6 P7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(21,34) DPWR DGND
+ MRBAR TEBAR PEBAR PLBAR P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 CP
+ SET0 SET1 SET2 SET3 SET4 SET5 SET6 SET7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6
+ CLR7 J0 J1 J2 J3 J4 J5 J6 J7 K0 K1 K2 K3 K4 K5 K6 K7 TCBARO CPBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CPBAR = {~CP}
+   SET0 = {MRBAR & (PLBAR | ~P0)}
+   CLR0 = {~MRBAR | (PLBAR | P0)}
+   SET1 = {~MRBAR | (PLBAR | ~P1)}
+   CLR1 = {MRBAR & (PLBAR | P1)}
+   SET2 = {~MRBAR | (PLBAR | ~P2)}
+   CLR2 = {MRBAR & (PLBAR | P2)}
+   SET3 = {MRBAR & (PLBAR | ~P3)}
+   CLR3 = {~MRBAR | (PLBAR | P3)}
+   SET4 = {MRBAR & (PLBAR | ~P4)}
+   CLR4 = {~MRBAR | (PLBAR | P4)}
+   SET5 = {~MRBAR | (PLBAR | ~P5)}
+   CLR5 = {MRBAR & (PLBAR | P5)}
+   SET6 = {~MRBAR | (PLBAR | ~P6)}
+   CLR6 = {MRBAR & (PLBAR | P6)}
+   SET7 = {MRBAR & (PLBAR | ~P7)}
+   CLR7 = {~MRBAR | (PLBAR | P7)}
+   J0 = {(~PEBAR & P0) | (PEBAR & ((TEBAR & Q0) | (~TEBAR)))}
+   K0 = {(~PEBAR & ~P0) | (PEBAR & TEBAR & ~J0) | (PEBAR & ~TEBAR & J0)}
+   J1 = {(~PEBAR & P1) | (PEBAR & ((TEBAR & Q1) | (~TEBAR & (~Q0) & (Q0 | Q1 | Q2 | Q3))))}
+   K1 = {(~PEBAR & ~P1) | (PEBAR & TEBAR & ~J1) | (PEBAR & ~TEBAR & J1)}
+   J2 = {(~PEBAR & P2) | (PEBAR & ((TEBAR & Q2) | (~TEBAR & (~Q0 & ~Q1) & (Q0 | Q1 | Q2 | Q3))))}
+   K2 = {(~PEBAR & ~P2) | (PEBAR & TEBAR & ~J2) | (PEBAR & ~TEBAR & J2)}
+   J3 = {(~PEBAR & P3) | (PEBAR & ((TEBAR & Q3) | (~TEBAR & (~Q0 & ~Q1 & ~Q2))))}
+   K3 = {(~PEBAR & ~P3) | (PEBAR & TEBAR & ~J3) | (PEBAR & ~TEBAR & J3)}
+   J4 = {(~PEBAR & P4) | (PEBAR & ((TEBAR & Q4) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3))))}
+   K4 = {(~PEBAR & ~P4) | (PEBAR & TEBAR & ~J4) | (PEBAR & ~TEBAR & J4)}
+   J5 = {(~PEBAR & P5) | (PEBAR & ((TEBAR & Q5) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4) & (Q4 | Q5 | Q6 | Q7))))}
+   K5 = {(~PEBAR & ~P5) | (PEBAR & TEBAR & ~J5) | (PEBAR & ~TEBAR & J5)}
+   J6 = {(~PEBAR & P6) | (PEBAR & ((TEBAR & Q6) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5) & (Q4 | Q5 | Q6 | Q7))))}
+   K6 = {(~PEBAR & ~P6) | (PEBAR & TEBAR & ~J6) | (PEBAR & ~TEBAR & J6)}
+   J7 = {(~PEBAR & P7) | (PEBAR & ((TEBAR & Q7) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5 & ~Q6))))}
+   K7 = {(~PEBAR & ~P7) | (PEBAR & TEBAR & ~J7) | (PEBAR & ~TEBAR & J7)}
+   TCBARO = {Q0 | Q1 | Q2 | Q3 | Q4 | Q5 | Q6 | Q7 | TEBAR}

U2 JKFF(1) DPWR DGND
+ SET0 CLR0 CPBAR
+ J0 K0 Q0 Q0BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ SET1 CLR1 CPBAR
+ J1 K1 Q1 Q1BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ SET2 CLR2 CPBAR
+ J2 K2 Q2 Q2BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ SET3 CLR3 CPBAR
+ J3 K3 Q3 Q3BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ SET4 CLR4 CPBAR
+ J4 K4 Q4 Q4BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ SET5 CLR5 CPBAR
+ J5 K5 Q5 Q5BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ SET6 CLR6 CPBAR
+ J6 K6 Q6 Q6BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ SET7 CLR7 CPBAR
+ J7 K7 Q7 Q7BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(1,0,12) DPWR DGND
+ TCBARO
+ CP TEBAR PLBAR MRBAR P0 P1 P2 P3 P4 P5 P6 P7
+ TCBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(MRBAR,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED_HL(TEBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+   DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) |
+           CHANGED(P4,0) | CHANGED(P5,0) | CHANGED(P6,0) | CHANGED(P7,0)}
+ PINDLY:
+   TCBAR = {
+    CASE(
+      SET & (TRN_LH | TRN_HL), DELAY(-1,30NS,55NS),
+      (DATA | LOAD) & (TRN_LH | TRN_HL), DELAY(-1,40NS,68NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,18NS,40NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,35NS,60NS),
+      DELAY(-1,41NS,69NS))}

U11 CONSTRAINT(13) DPWR DGND
+ CP MRBAR PLBAR PEBAR TEBAR P0 P1 P2 P3 P4 P5 P6 P7
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 27MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 8NS
+  MIN_LO = 8NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 11NS
+ WIDTH:
+  NODE = PLBAR
+  MIN_LO = 14NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(8) = P0 P1 P2 P3 P4 P5 P6 P7
+  SETUPTIME = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = TEBAR
+  SETUPTIME = 18NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 13NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PLBAR
+  SETUPTIME_HI = 3NS

.ENDS 74HC40102

*------------------------------------------------------------74HCT40102----

* 8-Bit Synchronous BCD Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1359 to 1366
* jat 9/19/96

.SUBCKT 74HCT40102 CP PLBAR TEBAR PEBAR MRBAR TCBAR P0 P1 P2 P3 P4 P5 P6 P7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(21,34) DPWR DGND
+ MRBAR TEBAR PEBAR PLBAR P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 CP
+ SET0 SET1 SET2 SET3 SET4 SET5 SET6 SET7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6
+ CLR7 J0 J1 J2 J3 J4 J5 J6 J7 K0 K1 K2 K3 K4 K5 K6 K7 TCBARO CPBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CPBAR = {~CP}
+   SET0 = {MRBAR & (PLBAR | ~P0)}
+   CLR0 = {~MRBAR | (PLBAR | P0)}
+   SET1 = {~MRBAR | (PLBAR | ~P1)}
+   CLR1 = {MRBAR & (PLBAR | P1)}
+   SET2 = {~MRBAR | (PLBAR | ~P2)}
+   CLR2 = {MRBAR & (PLBAR | P2)}
+   SET3 = {MRBAR & (PLBAR | ~P3)}
+   CLR3 = {~MRBAR | (PLBAR | P3)}
+   SET4 = {MRBAR & (PLBAR | ~P4)}
+   CLR4 = {~MRBAR | (PLBAR | P4)}
+   SET5 = {~MRBAR | (PLBAR | ~P5)}
+   CLR5 = {MRBAR & (PLBAR | P5)}
+   SET6 = {~MRBAR | (PLBAR | ~P6)}
+   CLR6 = {MRBAR & (PLBAR | P6)}
+   SET7 = {MRBAR & (PLBAR | ~P7)}
+   CLR7 = {~MRBAR | (PLBAR | P7)}
+   J0 = {(~PEBAR & P0) | (PEBAR & ((TEBAR & Q0) | (~TEBAR)))}
+   K0 = {(~PEBAR & ~P0) | (PEBAR & TEBAR & ~J0) | (PEBAR & ~TEBAR & J0)}
+   J1 = {(~PEBAR & P1) | (PEBAR & ((TEBAR & Q1) | (~TEBAR & (~Q0) & (Q0 | Q1 | Q2 | Q3))))}
+   K1 = {(~PEBAR & ~P1) | (PEBAR & TEBAR & ~J1) | (PEBAR & ~TEBAR & J1)}
+   J2 = {(~PEBAR & P2) | (PEBAR & ((TEBAR & Q2) | (~TEBAR & (~Q0 & ~Q1) & (Q0 | Q1 | Q2 | Q3))))}
+   K2 = {(~PEBAR & ~P2) | (PEBAR & TEBAR & ~J2) | (PEBAR & ~TEBAR & J2)}
+   J3 = {(~PEBAR & P3) | (PEBAR & ((TEBAR & Q3) | (~TEBAR & (~Q0 & ~Q1 & ~Q2))))}
+   K3 = {(~PEBAR & ~P3) | (PEBAR & TEBAR & ~J3) | (PEBAR & ~TEBAR & J3)}
+   J4 = {(~PEBAR & P4) | (PEBAR & ((TEBAR & Q4) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3))))}
+   K4 = {(~PEBAR & ~P4) | (PEBAR & TEBAR & ~J4) | (PEBAR & ~TEBAR & J4)}
+   J5 = {(~PEBAR & P5) | (PEBAR & ((TEBAR & Q5) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4) & (Q4 | Q5 | Q6 | Q7))))}
+   K5 = {(~PEBAR & ~P5) | (PEBAR & TEBAR & ~J5) | (PEBAR & ~TEBAR & J5)}
+   J6 = {(~PEBAR & P6) | (PEBAR & ((TEBAR & Q6) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5) & (Q4 | Q5 | Q6 | Q7))))}
+   K6 = {(~PEBAR & ~P6) | (PEBAR & TEBAR & ~J6) | (PEBAR & ~TEBAR & J6)}
+   J7 = {(~PEBAR & P7) | (PEBAR & ((TEBAR & Q7) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5 & ~Q6))))}
+   K7 = {(~PEBAR & ~P7) | (PEBAR & TEBAR & ~J7) | (PEBAR & ~TEBAR & J7)}
+   TCBARO = {Q0 | Q1 | Q2 | Q3 | Q4 | Q5 | Q6 | Q7 | TEBAR}

U2 JKFF(1) DPWR DGND
+ SET0 CLR0 CPBAR
+ J0 K0 Q0 Q0BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ SET1 CLR1 CPBAR
+ J1 K1 Q1 Q1BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ SET2 CLR2 CPBAR
+ J2 K2 Q2 Q2BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ SET3 CLR3 CPBAR
+ J3 K3 Q3 Q3BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ SET4 CLR4 CPBAR
+ J4 K4 Q4 Q4BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ SET5 CLR5 CPBAR
+ J5 K5 Q5 Q5BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ SET6 CLR6 CPBAR
+ J6 K6 Q6 Q6BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ SET7 CLR7 CPBAR
+ J7 K7 Q7 Q7BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(1,0,12) DPWR DGND
+ TCBARO
+ CP TEBAR PLBAR MRBAR P0 P1 P2 P3 P4 P5 P6 P7
+ TCBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(MRBAR,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED_HL(TEBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+   DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) |
+           CHANGED(P4,0) | CHANGED(P5,0) | CHANGED(P6,0) | CHANGED(P7,0)}
+ PINDLY:
+   TCBAR = {
+    CASE(
+      SET & (TRN_LH | TRN_HL), DELAY(-1,31NS,55NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,49NS,83NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,25NS,50NS),
+      (DATA | EDGE) & (TRN_LH | TRN_HL), DELAY(-1,38NS,63NS),
+      DELAY(-1,50NS,84NS))}

U11 CONSTRAINT(13) DPWR DGND
+ CP MRBAR PLBAR PEBAR TEBAR P0 P1 P2 P3 P4 P5 P6 P7
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 27MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 11NS
+  MIN_LO = 11NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 16NS
+ WIDTH:
+  NODE = PLBAR
+  MIN_LO = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(8) = P0 P1 P2 P3 P4 P5 P6 P7
+  SETUPTIME = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = TEBAR
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 1NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PLBAR
+  SETUPTIME_HI = 1NS

.ENDS 74HCT40102

*------------------------------------------------------------74HC40103----

* 8-Bit Synchronous Binary Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1367 to 1375
* jat 9/19/96

.SUBCKT 74HC40103 CP PLBAR TEBAR PEBAR MRBAR TCBAR P0 P1 P2 P3 P4 P5 P6 P7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(21,34) DPWR DGND
+ MRBAR TEBAR PEBAR PLBAR P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 CP
+ SET0 SET1 SET2 SET3 SET4 SET5 SET6 SET7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6
+ CLR7 J0 J1 J2 J3 J4 J5 J6 J7 K0 K1 K2 K3 K4 K5 K6 K7 TCBARO CPBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CPBAR = {~CP}
+   SET0 = {MRBAR & (PLBAR | ~P0)}
+   CLR0 = {~MRBAR | (PLBAR | P0)}
+   SET1 = {MRBAR & (PLBAR | ~P1)}
+   CLR1 = {~MRBAR | (PLBAR | P1)}
+   SET2 = {MRBAR & (PLBAR | ~P2)}
+   CLR2 = {~MRBAR | (PLBAR | P2)}
+   SET3 = {MRBAR & (PLBAR | ~P3)}
+   CLR3 = {~MRBAR | (PLBAR | P3)}
+   SET4 = {MRBAR & (PLBAR | ~P4)}
+   CLR4 = {~MRBAR | (PLBAR | P4)}
+   SET5 = {MRBAR & (PLBAR | ~P5)}
+   CLR5 = {~MRBAR | (PLBAR | P5)}
+   SET6 = {MRBAR & (PLBAR | ~P6)}
+   CLR6 = {~MRBAR | (PLBAR | P6)}
+   SET7 = {MRBAR & (PLBAR | ~P7)}
+   CLR7 = {~MRBAR | (PLBAR | P7)}
+   J0 = {(~PEBAR & P0) | (PEBAR & ((TEBAR & Q0) | (~TEBAR)))}
+   K0 = {(~PEBAR & ~P0) | (PEBAR & TEBAR & ~J0) | (PEBAR & ~TEBAR & J0)}
+   J1 = {(~PEBAR & P1) | (PEBAR & ((TEBAR & Q1) | (~TEBAR & (~Q0))))}
+   K1 = {(~PEBAR & ~P1) | (PEBAR & TEBAR & ~J1) | (PEBAR & ~TEBAR & J1)}
+   J2 = {(~PEBAR & P2) | (PEBAR & ((TEBAR & Q2) | (~TEBAR & (~Q0 & ~Q1))))}
+   K2 = {(~PEBAR & ~P2) | (PEBAR & TEBAR & ~J2) | (PEBAR & ~TEBAR & J2)}
+   J3 = {(~PEBAR & P3) | (PEBAR & ((TEBAR & Q3) | (~TEBAR & (~Q0 & ~Q1 & ~Q2))))}
+   K3 = {(~PEBAR & ~P3) | (PEBAR & TEBAR & ~J3) | (PEBAR & ~TEBAR & J3)}
+   J4 = {(~PEBAR & P4) | (PEBAR & ((TEBAR & Q4) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3))))}
+   K4 = {(~PEBAR & ~P4) | (PEBAR & TEBAR & ~J4) | (PEBAR & ~TEBAR & J4)}
+   J5 = {(~PEBAR & P5) | (PEBAR & ((TEBAR & Q5) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4))))}
+   K5 = {(~PEBAR & ~P5) | (PEBAR & TEBAR & ~J5) | (PEBAR & ~TEBAR & J5)}
+   J6 = {(~PEBAR & P6) | (PEBAR & ((TEBAR & Q6) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5))))}
+   K6 = {(~PEBAR & ~P6) | (PEBAR & TEBAR & ~J6) | (PEBAR & ~TEBAR & J6)}
+   J7 = {(~PEBAR & P7) | (PEBAR & ((TEBAR & Q7) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5 & ~Q6))))}
+   K7 = {(~PEBAR & ~P7) | (PEBAR & TEBAR & ~J7) | (PEBAR & ~TEBAR & J7)}
+   TCBARO = {Q0 | Q1 | Q2 | Q3 | Q4 | Q5 | Q6 | Q7 | TEBAR}

U2 JKFF(1) DPWR DGND
+ SET0 CLR0 CPBAR
+ J0 K0 Q0 Q0BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ SET1 CLR1 CPBAR
+ J1 K1 Q1 Q1BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ SET2 CLR2 CPBAR
+ J2 K2 Q2 Q2BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ SET3 CLR3 CPBAR
+ J3 K3 Q3 Q3BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ SET4 CLR4 CPBAR
+ J4 K4 Q4 Q4BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ SET5 CLR5 CPBAR
+ J5 K5 Q5 Q5BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ SET6 CLR6 CPBAR
+ J6 K6 Q6 Q6BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ SET7 CLR7 CPBAR
+ J7 K7 Q7 Q7BAR
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(1,0,4) DPWR DGND
+ TCBARO
+ CP TEBAR PLBAR MRBAR
+ TCBAR
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(MRBAR,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED_HL(TEBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+   TCBAR = {
+    CASE(
+      SET & (TRN_LH | TRN_HL), DELAY(-1,30NS,55NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,37NS,63NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,18NS,35NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,35NS,60NS),
+      DELAY(-1,38NS,64NS))}

U11 CONSTRAINT(13) DPWR DGND
+ CP MRBAR PLBAR PEBAR TEBAR P0 P1 P2 P3 P4 P5 P6 P7
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 29MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 8NS
+  MIN_LO = 8NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 14NS
+ WIDTH:
+  NODE = PLBAR
+  MIN_LO = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(8) = P0 P1 P2 P3 P4 P5 P6 P7
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = TEBAR
+  SETUPTIME = 16NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PLBAR
+  SETUPTIME_HI = 5NS

.ENDS 74HC40103

*------------------------------------------------------------74HCT40103----

* 8-Bit Synchronous Binary Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1367 to 1375
* jat 9/19/96

.SUBCKT 74HCT40103 CP PLBAR TEBAR PEBAR MRBAR TCBAR P0 P1 P2 P3 P4 P5 P6 P7
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(21,34) DPWR DGND
+ MRBAR TEBAR PEBAR PLBAR P0 P1 P2 P3 P4 P5 P6 P7 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 CP
+ SET0 SET1 SET2 SET3 SET4 SET5 SET6 SET7 CLR0 CLR1 CLR2 CLR3 CLR4 CLR5 CLR6
+ CLR7 J0 J1 J2 J3 J4 J5 J6 J7 K0 K1 K2 K3 K4 K5 K6 K7 TCBARO CPBAR
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CPBAR = {~CP}
+   SET0 = {MRBAR & (PLBAR | ~P0)}
+   CLR0 = {~MRBAR | (PLBAR | P0)}
+   SET1 = {MRBAR & (PLBAR | ~P1)}
+   CLR1 = {~MRBAR | (PLBAR | P1)}
+   SET2 = {MRBAR & (PLBAR | ~P2)}
+   CLR2 = {~MRBAR | (PLBAR | P2)}
+   SET3 = {MRBAR & (PLBAR | ~P3)}
+   CLR3 = {~MRBAR | (PLBAR | P3)}
+   SET4 = {MRBAR & (PLBAR | ~P4)}
+   CLR4 = {~MRBAR | (PLBAR | P4)}
+   SET5 = {MRBAR & (PLBAR | ~P5)}
+   CLR5 = {~MRBAR | (PLBAR | P5)}
+   SET6 = {MRBAR & (PLBAR | ~P6)}
+   CLR6 = {~MRBAR | (PLBAR | P6)}
+   SET7 = {MRBAR & (PLBAR | ~P7)}
+   CLR7 = {~MRBAR | (PLBAR | P7)}
+   J0 = {(~PEBAR & P0) | (PEBAR & ((TEBAR & Q0) | (~TEBAR)))}
+   K0 = {(~PEBAR & ~P0) | (PEBAR & TEBAR & ~J0) | (PEBAR & ~TEBAR & J0)}
+   J1 = {(~PEBAR & P1) | (PEBAR & ((TEBAR & Q1) | (~TEBAR & (~Q0))))}
+   K1 = {(~PEBAR & ~P1) | (PEBAR & TEBAR & ~J1) | (PEBAR & ~TEBAR & J1)}
+   J2 = {(~PEBAR & P2) | (PEBAR & ((TEBAR & Q2) | (~TEBAR & (~Q0 & ~Q1))))}
+   K2 = {(~PEBAR & ~P2) | (PEBAR & TEBAR & ~J2) | (PEBAR & ~TEBAR & J2)}
+   J3 = {(~PEBAR & P3) | (PEBAR & ((TEBAR & Q3) | (~TEBAR & (~Q0 & ~Q1 & ~Q2))))}
+   K3 = {(~PEBAR & ~P3) | (PEBAR & TEBAR & ~J3) | (PEBAR & ~TEBAR & J3)}
+   J4 = {(~PEBAR & P4) | (PEBAR & ((TEBAR & Q4) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3))))}
+   K4 = {(~PEBAR & ~P4) | (PEBAR & TEBAR & ~J4) | (PEBAR & ~TEBAR & J4)}
+   J5 = {(~PEBAR & P5) | (PEBAR & ((TEBAR & Q5) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4))))}
+   K5 = {(~PEBAR & ~P5) | (PEBAR & TEBAR & ~J5) | (PEBAR & ~TEBAR & J5)}
+   J6 = {(~PEBAR & P6) | (PEBAR & ((TEBAR & Q6) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5))))}
+   K6 = {(~PEBAR & ~P6) | (PEBAR & TEBAR & ~J6) | (PEBAR & ~TEBAR & J6)}
+   J7 = {(~PEBAR & P7) | (PEBAR & ((TEBAR & Q7) | (~TEBAR & (~Q0 & ~Q1 & ~Q2 & ~Q3 & ~Q4 & ~Q5 & ~Q6))))}
+   K7 = {(~PEBAR & ~P7) | (PEBAR & TEBAR & ~J7) | (PEBAR & ~TEBAR & J7)}
+   TCBARO = {Q0 | Q1 | Q2 | Q3 | Q4 | Q5 | Q6 | Q7 | TEBAR}

U2 JKFF(1) DPWR DGND
+ SET0 CLR0 CPBAR
+ J0 K0 Q0 Q0BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ SET1 CLR1 CPBAR
+ J1 K1 Q1 Q1BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ SET2 CLR2 CPBAR
+ J2 K2 Q2 Q2BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ SET3 CLR3 CPBAR
+ J3 K3 Q3 Q3BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ SET4 CLR4 CPBAR
+ J4 K4 Q4 Q4BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ SET5 CLR5 CPBAR
+ J5 K5 Q5 Q5BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ SET6 CLR6 CPBAR
+ J6 K6 Q6 Q6BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ SET7 CLR7 CPBAR
+ J7 K7 Q7 Q7BAR
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(1,0,4) DPWR DGND
+ TCBARO
+ CP TEBAR PLBAR MRBAR
+ TCBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(MRBAR,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED_HL(TEBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+   TCBAR = {
+    CASE(
+      SET & (TRN_LH | TRN_HL), DELAY(-1,29NS,55NS),
+      LOAD & (TRN_LH | TRN_HL), DELAY(-1,44NS,75NS),
+      COUNT & (TRN_LH | TRN_HL), DELAY(-1,23NS,40NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,35NS,60NS),
+      DELAY(-1,45NS,76NS))}

U11 CONSTRAINT(13) DPWR DGND
+ CP MRBAR PLBAR PEBAR TEBAR P0 P1 P2 P3 P4 P5 P6 P7
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 28MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 10NS
+  MIN_LO = 10NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 16NS
+ WIDTH:
+  NODE = PLBAR
+  MIN_LO = 22NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(8) = P0 P1 P2 P3 P4 P5 P6 P7
+  SETUPTIME = 11NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = TEBAR
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 11NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 1NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PLBAR
+  SETUPTIME_HI = 1NS

.ENDS 74HCT40103

*------------------------------------------------------------74HC40104----

* 4-Bit Bidirectional Univeral Shift Register
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1377 to 1381
* jat 9/19/96

.SUBCKT 74HC40104 D0 D1 D2 D3 DSR DSL S0 S1 CP OE Q0 Q1 Q2 Q3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,4) DPWR DGND
+ DSR DSL D0 D1 D2 D3 S0 S1 Q0O Q1O Q2O Q3O
+ DATA0 DATA1 DATA2 DATA3
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  DATA0 = {(DSR & ~S1 & S0) | (D0 & S0 & S1) | (Q1O & S1 & ~S0)}
+  DATA1 = {(Q0O & ~S1 & S0) | (D1 & S0 & S1) | (Q2O & S1 & ~S0)}
+  DATA2 = {(Q1O & ~S1 & S0) | (D2 & S0 & S1) | (Q3O & S1 & ~S0)}
+  DATA3 = {(Q2O & ~S1 & S0) | (D3 & S0 & S1) | (DSL & S1 & ~S0)}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ DATA0 DATA1 DATA2 DATA3
+ Q0O Q1O Q2O Q3O
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,1,0) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ OE
+ Q0 Q1 Q2 Q3
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = OE
+   Q0 Q1 Q2 Q3 = {
+    CASE(
+      TRN_$Z, DELAY(-1,18NS,30NS),
+      TRN_Z$, DELAY(-1,12NS,30NS),
+      (TRN_LH | TRN_HL), DELAY(-1,16NS,34NS),
+      DELAY(-1,19NS,35NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP D0 D1 D2 D3 DSR DSL S0 S1
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  CP
+  MAXFREQ = 56MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 4NS
+  MIN_LO = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(6) = D0 D1 D2 D3 DSR DSL
+  SETUPTIME = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = S0 S1
+  SETUPTIME = 8NS

.ENDS 74HC40104

*------------------------------------------------------------74HCT40104----

* 4-Bit Bidirectional Univeral Shift Register
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 1377 to 1381
* jat 9/19/96

.SUBCKT 74HCT40104 D0 D1 D2 D3 DSR DSL S0 S1 CP OE Q0 Q1 Q2 Q3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,4) DPWR DGND
+ DSR DSL D0 D1 D2 D3 S0 S1 Q0O Q1O Q2O Q3O
+ DATA0 DATA1 DATA2 DATA3
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  DATA0 = {(DSR & ~S1 & S0) | (D0 & S0 & S1) | (Q1O & S1 & ~S0)}
+  DATA1 = {(Q0O & ~S1 & S0) | (D1 & S0 & S1) | (Q2O & S1 & ~S0)}
+  DATA2 = {(Q1O & ~S1 & S0) | (D2 & S0 & S1) | (Q3O & S1 & ~S0)}
+  DATA3 = {(Q2O & ~S1 & S0) | (D3 & S0 & S1) | (DSL & S1 & ~S0)}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ DATA0 DATA1 DATA2 DATA3
+ Q0O Q1O Q2O Q3O
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,1,0) DPWR DGND
+ Q0O Q1O Q2O Q3O
+ OE
+ Q0 Q1 Q2 Q3
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ TRISTATE:
+ ENABLE HI = OE
+   Q0 Q1 Q2 Q3 = {
+    CASE(
+      TRN_$Z, DELAY(-1,21NS,35NS),
+      TRN_Z$, DELAY(-1,12NS,30NS),
+      (TRN_LH | TRN_HL), DELAY(-1,18NS,34NS),
+      DELAY(-1,22NS,36NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP D0 D1 D2 D3 DSR DSL S0 S1
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE =  CP
+  MAXFREQ = 52MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(6) = D0 D1 D2 D3 DSR DSL
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = S0 S1
+  SETUPTIME = 9NS

.ENDS 74HCT40104

*------------------------------------------------------------74F50109----

* Synchronizing dual J-KBAR positive edge-triggered flip-flop with
* metastable immune characteristics
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 1014 to 1021
* jat 8/1/96

.SUBCKT 74F50109 J KBAR CP SDBAR RDBAR Q QBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1A INVA(2) DPWR DGND
+ CP KBAR CPBAR K
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U1 JKFF(1) DPWR DGND
+ SDBAR RDBAR CPBAR
+ J K QO QBARO
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(2,0,3) DPWR DGND
+ QO QBARO
+ CP SDBAR RDBAR
+ Q QBAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(SDBAR,0)}
+   RESET = {CHANGED_HL(RDBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+   Q QBAR = {
+     CASE(
+       (RESET | SET) & (TRN_LH | TRN_HL), DELAY(3.5NS,5.5NS,8NS),
+       EDGE & (TRN_LH | TRN_HL), DELAY(2NS,3.8NS,6NS),
+       DELAY(4.5NS,6.5NS,9NS))}

U3 CONSTRAINT(5) DPWR DGND
+ CP SDBAR RDBAR J KBAR
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 150MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 3NS
+   MIN_LO = 4NS
+ WIDTH:
+   NODE = SDBAR
+   MIN_LO = 3.5NS
+ WIDTH:
+   NODE = RDBAR
+   MIN_LO = 3.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(2) = J KBAR
+   SETUPTIME = 1.5NS
+   HOLDTIME = 1NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = SDBAR
+   SETUPTIME_HI = 3NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = RDBAR
+   SETUPTIME_HI = 3NS

.ENDS 74F50109

*------------------------------------------------------------74F50728----

* Synchronizing cascaded dual positive edge-triggered D-Type Flip-Flop
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 1022 to 1027
* jat 8/1/96

.SUBCKT 74F50728 D CP SDBAR RDBAR Q QBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(1) DPWR DGND
+ SDBAR RDBAR CP
+ D QX QXBAR
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(1) DPWR DGND
+ SDBAR RDBAR CP
+ QX QO QBARO
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(2,0,3) DPWR DGND
+ QO QBARO
+ CP SDBAR RDBAR
+ Q QBAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_HL(SDBAR,0)}
+   RESET = {CHANGED_HL(RDBAR,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+   Q QBAR = {
+     CASE(
+       (RESET | SET) & (TRN_LH | TRN_HL), DELAY(3.5NS,5NS,8NS),
+       EDGE & (TRN_LH | TRN_HL), DELAY(2NS,3.8NS,6NS),
+       DELAY(4.5NS,6NS,9NS))}

U4 CONSTRAINT(4) DPWR DGND
+ CP SDBAR RDBAR D
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 145MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 3NS
+   MIN_LO = 4NS
+ WIDTH:
+   NODE = SDBAR
+   MIN_LO = 4.5NS
+ WIDTH:
+   NODE = RDBAR
+   MIN_LO = 4.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = D
+   SETUPTIME = 1.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = SDBAR
+   SETUPTIME_HI = 3.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = RDBAR
+   SETUPTIME_HI = 3.5NS

.ENDS 74F50728

*------------------------------------------------------------74F50729----

* Synchronizing dual D-Type flip-flop with edge-triggered set and reset
* and metastable immune characteristics
* Philips FAST TTL Logic Series Data Handbook, 1992, pages 1028 to 1035
* jat 8/1/96

.SUBCKT 74F50729 D CP SD RD Q QBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 INVA(2) DPWR DGND
+ SD RD
+ SDDEL RDDEL
+ DLY_F50729 IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.MODEL DLY_F50729 UGATE(TPLHMN=0NS TPLHTY=0NS TPLHMX=0NS
+                       TPHLMN=4NS TPHLTY=4NS TPHLMX=4NS)

U2 LOGICEXP(4,2) DPWR DGND
+ SD SDDEL RD RDDEL
+ SET RESET
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   SET = {~(SD & SDDEL)}
+   RESET = {~(RD & RDDEL)}

U3 DFF(1) DPWR DGND
+ SET RESET CP
+ D QO QBARO
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 PINDLY(2,0,3) DPWR DGND
+ QO QBARO
+ CP SD RD
+ Q QBAR
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   SET = {CHANGED_LH(SD,0)}
+   RESET = {CHANGED_LH(RD,0)}
+   EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+   Q QBAR = {
+     CASE(
+       (RESET | SET) & TRN_LH, DELAY(2NS,4NS,6.5NS),
+       (RESET | SET) & TRN_HL, DELAY(3NS,5NS,7.5NS),
+       EDGE & (TRN_LH | TRN_HL), DELAY(2NS,3.9NS,6NS),
+       DELAY(4NS,6NS,8.5NS))}

U5 CONSTRAINT(4) DPWR DGND
+ CP SD RD D
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 120MEG
+ WIDTH:
+   NODE = CP
+   MIN_HI = 3NS
+   MIN_LO = 4NS
+ WIDTH:
+   NODE = SD
+   MIN_LO = 3.5NS
+ WIDTH:
+   NODE = RD
+   MIN_LO = 3.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = D
+   SETUPTIME = 1.5NS
+   HOLDTIME = 1NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = SD
+   SETUPTIME_LO = 6NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = RD
+   SETUPTIME_LO = 6NS
+ SETUP_HOLD:
+   CLOCK LH = SD
+   DATA(1) = RD
+   SETUPTIME_LO = 6NS
+ SETUP_HOLD:
+   CLOCK LH = RD
+   DATA(1) = SD
+   SETUPTIME_LO = 6NS

.ENDS 74F50729
