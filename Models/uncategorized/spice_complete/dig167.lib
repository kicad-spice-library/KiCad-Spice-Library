* -------------------------------------------------------------------------
*    Spectrum Software, all rights reserved, copywrite 1994,
*    Micro-Cap V Digital Library
*
*    Parts in this library are modeled at ambient room temperature (TA=25øC)
*    unless otherwise noted.
*
*    DIGITAL LIBRARY range 74167 - 74194
*
*
* ----------------------------------------------------------- 74167 ------
*  Synchronous Decade Rate Multiplier
*
*  The TTL Logic Data Book, 1988, TI Pages 2-537 to 2-542
*  jds    4/21/94
*
.SUBCKT 74167  CLK STROBE ENin UNI_CAS CLR SET B0 B1 B2 B3 Z Y ENout
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74167 LOGICEXP (17,11) DPWR DGND
+      CLK STROBE ENin UNI_CAS CLR SET B0 B1 B2 B3 
+      qa qb qc qabar qcbar qd qdbar
+      j0 j1 j2 j3 clkbar clr0 clrbar Y_O Z_O ENout_O setbar
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      setbar = {(~SET)}
+      clkbar = {(~CLK)}
+      clrbar = {(~CLR)}
+      enibar = {(~ENin)}
+      strbclk   = { (clkbar & ~STROBE) }
+      rate0 = { (B0 & strbclk & qc & qdbar) }
+      rate1 = { (B1 & strbclk & qabar & qb) }
+      rate2 = { (B2 & strbclk & qa) }
+      rate3 = { (B3 & strbclk & qcbar) }
+      j0 = {(enibar & qcbar)}
+      j1 = {(enibar & qa) }
+      j2 = {((enibar & qa & qb) | (enibar & qc))}
+      j3 = {(enibar & qc)}
+      clr0 =  {(setbar & clrbar)}
+      Z_O = {(~(rate0 | rate1 | rate2 | rate3))} 
+      Y_O = {(~( Z_O & UNI_CAS))}
+      ENout_O = {(~( enibar & qc & qd ))}

uf0  JKff(2)  DPWR DGND
+    $D_HI clr0 clkbar
+    j0 j1 j0 j1
+    qa qb  qabar qbbar
+    D0_EFF IO_STD

uf1  JKff(2)  DPWR DGND
+    setbar clrbar clkbar
+    j2 j3 j2 j3
+    qc qd  qcbar qdbar
+    D0_EFF IO_STD


Udly PINDLY (3,0,10) DPWR DGND
+    Y_O Z_O ENout_O
+    STROBE CLK B0 B1 B2 B3 UNI_CAS CLR SET  ENin
+    Y Z ENout
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     RATE = { CHANGED(B0,0) | CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0) }
+     ENI = { CHANGED(ENin,0) }
+     STRB = {CHANGED(STROBE,0)}
+     SET9 = { CHANGED(SET,0) }
+     CLOCK = {CHANGED(CLK,0)}
+     CLEAR = { CHANGED(CLR,0) }
+     UNI = { CHANGED(UNI_CAS,0) }
+
+    PINDLY:
+       Y = {
+            CASE(
+                 CLEAR, DELAY(-1,24ns,36ns),
+                 RATE , DELAY(-1,15ns,23ns),
+                 CLOCK & TRN_LH, DELAY(-1,26ns,39ns),
+                 CLOCK & TRN_HL, DELAY(-1,20ns,30ns),
+                 STRB & TRN_LH, DELAY(-1,19ns,30ns),
+                 STRB & TRN_HL, DELAY(-1,22ns,33ns),
+                 UNI & TRN_LH, DELAY(-1,9ns,14ns),
+                 UNI & TRN_HL, DELAY(-1,6ns,10ns),
+                 DELAY(-1,24ns,36ns)
+                )
+            }
+       Z = {
+            CASE(
+                 CLEAR, DELAY(-1,15ns,23ns),
+                 RATE & TRN_LH , DELAY(-1,9ns,14ns),
+                 RATE & TRN_HL, DELAY(-1,6ns,10ns),
+                 CLOCK & TRN_LH, DELAY(-1,12ns,18ns),
+                 CLOCK & TRN_HL, DELAY(-1,17ns,26ns),
+                 STRB & TRN_LH, DELAY(-1,12ns,18ns),
+                 STRB & TRN_HL, DELAY(-1,15ns,23ns),
+                 DELAY(-1,24ns,36ns)
+                )
+            }
+       ENout = {
+            CASE(
+                 ENI & TRN_LH, DELAY(-1,13ns,20ns),
+                 ENI & TRN_HL, DELAY(-1,14ns,21ns),
+                 CLOCK & TRN_LH, DELAY(-1,19ns,30ns),
+                 CLOCK & TRN_HL, DELAY(-1,22ns,33ns),
+                 SET9, DELAY(-1,18ns,27ns),
+                 DELAY(-1,23ns,34ns)
+                )
+            }

Ucnstr CONSTRAINT(4) DPWR DGND
+          CLR CLK SET ENin
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 15ns
+      WIDTH:
+         NODE = SET
+         MIN_HI = 15ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = ENin
+        SETUPTIME = 25ns
+        HOLDTIME = 20ns

.ENDS 74167
*
*
* ----------------------------------------------------------- 74ALS168B ------
*  Synchronous 4-Bit Up/Down Decade Counter
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-172 to 2-180
*  jds    4/21/94
*
.SUBCKT 74ALS168B U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS168B LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = {(a0 & a3 & U/DBAR)}
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = {( (B & load) |
+            ((~(U/DBAR & a3)) & enable & a0 & b0 & qbbar) |
+            (LOADBAR & ~(enable & a0) & QB_O)) }
+      d2 = {( (C & load) |
+               (LOADBAR & (~(enable & a0 & a1)) & QC_O) |
+               (enable & a0 & a1 & b0 & (~(LOADBAR & QC_O))) )}
+      d3 = {( (D & load) |
+               (enable & a0 & a1 & a2 & (~(LOADBAR & QD_O))) |
+               (LOADBAR & (~(enable & a0)) & QD_O) )}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_ALS00

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(3ns,-1,20ns),
+                 CLOCK & TRN_HL, DELAY(6ns,-1,20ns),
+                 UP/DOWN, DELAY(5ns,-1,19ns),
+                 ENAT & TRN_LH, DELAY(2ns,-1,13ns),
+                 ENAT & TRN_HL, DELAY(3ns,-1,16ns),
+                 DELAY(7ns,-1,21ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2ns,-1,15ns),
+                 CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                 DELAY(7ns,-1,21ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 12.5ns
+         MIN_LO = 12.5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = ENPBAR ENTBAR LOADBAR U/DBAR A B C D
+        SETUPTIME = 15ns

.ENDS 74ALS168B
*
*
* ----------------------------------------------------------- 74AS168 ------
*  Synchronous 4-Bit Up/Down Decade Counter
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-172 to 2-180
*  jds    4/21/94
*
.SUBCKT 74AS168 U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS168B LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = {(a0 & a3 & U/DBAR)}
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = {( (B & load) |
+            ((~(U/DBAR & a3)) & enable & a0 & b0 & qbbar) |
+            (LOADBAR & ~(enable & a0) & QB_O)) }
+      d2 = {( (C & load) |
+               (LOADBAR & (~(enable & a0 & a1)) & QC_O) |
+               (enable & a0 & a1 & b0 & (~(LOADBAR & QC_O))) )}
+      d3 = {( (D & load) |
+               (enable & a0 & a1 & a2 & (~(LOADBAR & QD_O))) |
+               (LOADBAR & (~(enable & a0)) & QD_O) )}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_AS00

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(3ns,-1,16.5ns),
+                 CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                 UP/DOWN & TRN_LH, DELAY(2ns,-1,12ns),
+                 UP/DOWN & TRN_HL, DELAY(2ns,-1,13ns),
+                 ENAT, DELAY(1.5ns,-1,9ns),
+                 DELAY(4ns,-1,17.5ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(1ns,-1,7ns),
+                 CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                 DELAY(3ns,-1,14ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_AS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 75MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 6.7ns
+         MIN_LO = 6.7ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = ENPBAR ENTBAR LOADBAR U/DBAR A B C D
+        SETUPTIME = 8ns

.ENDS 74AS168

*-----------------------------------------------------------74AS168A------

* Synchronous Four Bit Up/Down Counter
* National ALS/AS Logic Databook, 1990, pages 3-50 to 3-54
* jat 8/21/96

.SUBCKT 74AS168A LOADBAR A B C D U/DBAR CLK ENPBAR ENTBAR RCOBAR QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) DPWR DGND
+ LOADBAR A B C D ENTBAR ENPBAR U/DBAR Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 RCOBARO
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(ENTBAR | ENPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X2 = {~(Q2BAR & Q3BAR)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q0BAR & CE)}
+  X7 = {~(Q0O & CE)}
+  D0 = {(LOADBAR & ~CE & Q0O) | (A & ~LOADBAR) | (CE & LOADBAR & Q0BAR)}
+  D1 = {(X1 & LOADBAR & Q1O & ~U/DBAR) | (Q1BAR & X2 & ~U/DBAR & LOADBAR & Q0BAR & CE)
+      | (B & ~LOADBAR) | (Q1O & X3 & LOADBAR & U/DBAR) |
+        (Q1BAR & LOADBAR & U/DBAR & CE & Q0O & Q3BAR)}
+  D2 = {(X4 & LOADBAR & U/DBAR & Q2O) | (U/DBAR & LOADBAR & Q2BAR & Q1O & Q0O & CE) |
+        (C & ~LOADBAR) | (Q2O & X5 & LOADBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & LOADBAR & Q1BAR & Q0BAR & Q3O)}
+  D3 = {(X6 & LOADBAR & ~U/DBAR & Q3O) | (~U/DBAR & LOADBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (D & ~LOADBAR) | (Q3O & X7 & LOADBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & LOADBAR & Q0O & Q1O & Q2O)}
+  RCOBARO = {~((~U/DBAR & ~ENTBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~ENTBAR & Q0O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CLK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O RCOBARO
+ CLK ENTBAR U/DBAR
+ QA QB QC QD RCOBAR
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLK,0)}
+  T = {CHANGED(ENTBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  QA QB QC QD = {
+    CASE(
+      EDGE & TRN_LH, DELAY(1NS,-1,7NS),
+      EDGE & TRN_HL, DELAY(2NS,-1,13NS),
+      DELAY(3NS,-1,14NS))}
+  RCOBAR = {
+    CASE(
+      T & TRN_LH, DELAY(1.5NS,-1,9NS),
+      T & TRN_HL, DELAY(1.5NS,-1,9NS),
+      UPDOWN & TRN_LH, DELAY(2NS,-1,12NS),
+      UPDOWN & TRN_HL, DELAY(2NS,-1,13NS),
+      EDGE & TRN_LH, DELAY(3NS,-1,16.5NS),
+      EDGE & TRN_HL, DELAY(2NS,-1,13NS),
+      DELAY(3NS,-1,17.5NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CLK A B C D ENPBAR ENTBAR LOADBAR U/DBAR
+ IO_AS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 75MEG
+ WIDTH:
+  NODE  = CLK
+  MIN_LO = 6.7NS
+  MIN_HI = 6.7NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(7) = A B C D ENPBAR ENTBAR LOADBAR
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = U/DBAR
+  SETUPTIME = 11NS

.ENDS 74AS168A

* ----------------------------------------------------------- 74F168 ------
*  Synchronous 4-Bit Up/Down Decade Counter
*
*  The F Logic Logic Data Book, 1994, TI Pages 2-121 to 2-128
*  jds    4/25/94
*
.SUBCKT 74F168 U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F168 LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = {(a0 & a3 & U/DBAR)}
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = {( (B & load) |
+            ((~(U/DBAR & a3)) & enable & a0 & b0 & qbbar) |
+            (LOADBAR & ~(enable & a0) & QB_O)) }
+      d2 = {( (C & load) |
+               (LOADBAR & (~(enable & a0 & a1)) & QC_O) |
+               (enable & a0 & a1 & b0 & (~(LOADBAR & QC_O))) )}
+      d3 = {( (D & load) |
+               (enable & a0 & a1 & a2 & (~(LOADBAR & QD_O))) |
+               (LOADBAR & (~(enable & a0)) & QD_O) )}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_F

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(4.7ns,11.6ns,15.5ns),
+                 CLOCK & TRN_HL, DELAY(3.2ns,8.1ns,11ns),
+                 UP/DOWN, DELAY(2.7ns,8.1ns,11ns),
+                 UP/DOWN, DELAY(3.2ns,12.1ns,16ns),
+                 ENAT & TRN_LH, DELAY(1.7ns,4.1ns,6ns),
+                 ENAT & TRN_HL, DELAY(1.7ns,5.6ns,8ns),
+                 DELAY(5.7ns,13.1ns,17ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2.2ns,6.1ns,8.5ns),
+                 CLOCK & TRN_HL, DELAY(3.2ns,8.6ns,11.5ns),
+                 DELAY(4.2ns,9.6ns,12.5ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_F
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 115MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 5ns
+         MIN_LO = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  A B C D
+        SETUPTIME = 4ns
+        HOLDTIME = 3ns
+        WHEN = { LOADBAR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  ENTBAR ENPBAR
+        SETUPTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  LOADBAR
+        SETUPTIME = 8ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  U/DBAR
+        SETUPTIME_HI = 11ns
+        SETUPTIME_LO = 16.5ns

.ENDS 74F168

*-----------------------------------------------------------74LS168------

* BCD Decade Synchronous Bi-directional Counter
* Motorola FAST and LS TTL Logic Data, 1992, pages 5-178 to 5-183
* jat 8/7/96

.SUBCKT 74LS168 PEBAR P0 P1 P2 P3 CEPBAR CETBAR U/DBAR CP Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,5) DPWR DGND
+ PEBAR P0 P1 P2 P3 CETBAR CEPBAR U/DBAR CP Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 TCBARO
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(CETBAR | CEPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X2 = {~(Q2BAR & Q3BAR)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q0BAR & CE)}
+  X7 = {~(Q0O & CE)}
+  D0 = {(PEBAR & ~CE & Q0O) | (P0 & ~PEBAR) | (CE & PEBAR & Q0BAR)}
+  D1 = {(X1 & PEBAR & Q1O & ~U/DBAR) | (Q1BAR & X2 & ~U/DBAR & PEBAR & Q0BAR & CE)
+      | (P1 & ~PEBAR) | (Q1O & X3 & PEBAR & U/DBAR) |
+        (Q1BAR & PEBAR & U/DBAR & CE & Q0O & Q3BAR)}
+  D2 = {(X4 & PEBAR & U/DBAR & Q2O) | (U/DBAR & PEBAR & Q2BAR & Q1O & Q0O & CE) |
+        (P2 & ~PEBAR) | (Q2O & X5 & PEBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & PEBAR & Q1BAR & Q0BAR & Q3O)}
+  D3 = {(X6 & PEBAR & ~U/DBAR & Q3O) | (~U/DBAR & PEBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (P3 & ~PEBAR) | (Q3O & X7 & PEBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & PEBAR & Q0O & Q1O & Q2O)}
+  TCBARO = {~((~U/DBAR & ~CETBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~CETBAR & Q0O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP CETBAR U/DBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  T = {CHANGED(CETBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      EDGE & TRN_LH, DELAY(-1,13NS,20NS),
+      EDGE & TRN_HL, DELAY(-1,15NS,23NS),
+      DELAY(-1,16NS,24NS))}
+  TCBAR = {
+    CASE(
+      T & TRN_LH, DELAY(-1,15NS,20NS),
+      T & TRN_HL, DELAY(-1,15NS,20NS),
+      UPDOWN & TRN_LH, DELAY(-1,17NS,25NS),
+      UPDOWN & TRN_HL, DELAY(-1,19NS,29NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,35NS),
+      DELAY(-1,24NS,36NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP P0 P1 P2 P3 CETBAR CEPBAR U/DBAR PEBAR
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 32MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 25NS
+  MIN_HI = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(6) = P0 P1 P2 P3 CETBAR CEPBAR
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = U/DBAR
+  SETUPTIME = 30NS

.ENDS 74LS168

*-----------------------------------------------------------74LS168A------

* BCD Decade Synchronous Bi-directional Counter
* Motorola Schottky TTL Data, 1983, pages 4-148 to 4-152
* jat 8/7/96

.SUBCKT 74LS168A PEBAR P0 P1 P2 P3 CEPBAR CETBAR U/DBAR CP Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,5) DPWR DGND
+ PEBAR P0 P1 P2 P3 CETBAR CEPBAR U/DBAR CP Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 TCBARO
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(CETBAR | CEPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X2 = {~(Q2BAR & Q3BAR)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q0BAR & CE)}
+  X7 = {~(Q0O & CE)}
+  D0 = {(PEBAR & ~CE & Q0O) | (P0 & ~PEBAR) | (CE & PEBAR & Q0BAR)}
+  D1 = {(X1 & PEBAR & Q1O & ~U/DBAR) | (Q1BAR & X2 & ~U/DBAR & PEBAR & Q0BAR & CE)
+      | (P1 & ~PEBAR) | (Q1O & X3 & PEBAR & U/DBAR) |
+        (Q1BAR & PEBAR & U/DBAR & CE & Q0O & Q3BAR)}
+  D2 = {(X4 & PEBAR & U/DBAR & Q2O) | (U/DBAR & PEBAR & Q2BAR & Q1O & Q0O & CE) |
+        (P2 & ~PEBAR) | (Q2O & X5 & PEBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & PEBAR & Q1BAR & Q0BAR & Q3O)}
+  D3 = {(X6 & PEBAR & ~U/DBAR & Q3O) | (~U/DBAR & PEBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (P3 & ~PEBAR) | (Q3O & X7 & PEBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & PEBAR & Q0O & Q1O & Q2O)}
+  TCBARO = {~((~U/DBAR & ~CETBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~CETBAR & Q0O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP CETBAR U/DBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  T = {CHANGED(CETBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      EDGE & TRN_LH, DELAY(-1,13NS,20NS),
+      EDGE & TRN_HL, DELAY(-1,15NS,23NS),
+      DELAY(-1,16NS,24NS))}
+  TCBAR = {
+    CASE(
+      T & TRN_LH, DELAY(-1,15NS,20NS),
+      T & TRN_HL, DELAY(-1,15NS,20NS),
+      UPDOWN & TRN_LH, DELAY(-1,17NS,25NS),
+      UPDOWN & TRN_HL, DELAY(-1,19NS,29NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,35NS),
+      DELAY(-1,24NS,36NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP P0 P1 P2 P3 CETBAR CEPBAR U/DBAR PEBAR
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 32MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 25NS
+  MIN_HI = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(6) = P0 P1 P2 P3 CETBAR CEPBAR
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = U/DBAR
+  SETUPTIME = 30NS

.ENDS 74LS168A

* ----------------------------------------------------------- 74S168 ------
*  Synchronous 4-Bit Up/Down Decade Counter
*
*  The TTL Logic Data Book, 198, TI Pages 3-651 to 3-654
*  jds    4/25/94
*
.SUBCKT 74S168 U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S168 LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = {(a0 & a3 & U/DBAR)}
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = {( (B & load) |
+            ((~(U/DBAR & a3)) & enable & a0 & b0 & qbbar) |
+            (LOADBAR & ~(enable & a0) & QB_O)) }
+      d2 = {( (C & load) |
+               (LOADBAR & (~(enable & a0 & a1)) & QC_O) |
+               (enable & a0 & a1 & b0 & (~(LOADBAR & QC_O))) )}
+      d3 = {( (D & load) |
+               (enable & a0 & a1 & a2 & (~(LOADBAR & QD_O))) |
+               (LOADBAR & (~(enable & a0)) & QD_O) )}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_S

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     COUNTING_UP = {  U/DBAR == '1 }
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,14ns,21ns),
+                 CLOCK & TRN_HL, DELAY(-1,20ns,28ns),
+                 UP/DOWN & COUNTING_UP & TRN_LH, DELAY(-1,9ns,15ns),
+                 UP/DOWN & COUNTING_UP & TRN_HL, DELAY(-1,10ns,15ns),
+                 ENAT & COUNTING_UP & TRN_LH, DELAY(-1,7.5ns,11ns),
+                 ENAT & COUNTING_UP & TRN_LH, DELAY(-1,15ns,22ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,8ns,15ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,16ns,22ns),
+                 ENAT & TRN_LH, DELAY(-1,6ns,12ns),
+                 ENAT & TRN_LH, DELAY(-1,15ns,25ns),
+                 DELAY(-1,21ns,29ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,8ns,15ns),
+                 CLOCK & TRN_HL, DELAY(-1,11ns,15ns),
+                 DELAY(-1,12ns,16ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_S
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 10ns
+         MIN_LO = 10ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  A B C D
+        SETUPTIME = 4ns
+        HOLDTIME = 1ns
+        WHEN = { LOADBAR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  ENTBAR ENPBAR
+        SETUPTIME = 14ns
+        HOLDTIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  LOADBAR
+        SETUPTIME = 6ns
+        HOLDTIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  U/DBAR
+        SETUPTIME = 20ns
+        HOLDTIME = 1ns

.ENDS 74S168
*
*
* ----------------------------------------------------------- 74AC169 ------
*  Synchronous 4-Bit Up/Down Binary Counter
*
*  The FACT Advanced CMOS Logic Data Book, 1989,  National Semiconductor
*  jds    4/26/94                                 Pages 4-100 to 4-104
*
.SUBCKT 74AC169 U/DBAR CP P0 P1 P2 P3 CEPBAR PEBAR CETBAR Q0 Q1 Q2 Q3 TCBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC169 LOGICEXP (17,10) DPWR DGND
+      U/DBAR P0 P1 P2 P3 CEPBAR PEBAR CETBAR CP
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~PEBAR)}
+      ent = {(~CETBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & q0bar) | (ubar/d & Q0_O)))}
+      a1 = {(~((U/DBAR & q1bar) | (ubar/d & Q1_O)))}
+      a2 = {(~((U/DBAR & q2bar) | (ubar/d & Q2_O)))}
+      a3 = {(~((U/DBAR & q3bar) | (ubar/d & Q3_O)))}
+      a4 = { (a0 & a1 & a2 & a3 & ent & U/DBAR) }
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      TCBAR_O = { (~(a4 | a5))}
+      b0 = {~(q3bar & q2bar & ubar/d)}
+      enable = {( ent & ~CEPBAR & PEBAR)}
+      d0 = { (((PEBAR & Q0_O) ^ enable) | (P0 & load))}
+      d1 = { (((PEBAR & Q1_O) ^ (enable & a0)) | (P1 & load))}
+      d2 = { (((PEBAR & Q2_O) ^ (enable & a0 & a1)) | (P2 & load))}
+      d3 = { (((PEBAR & Q3_O) ^ (enable & a0 & a1 & a2)) | (P3 & load))}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CP }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+ D0_EFF IO_AC

Udly PINDLY (5,0,3) DPWR DGND
+    TCBAR_O Q0_O Q1_O Q2_O Q3_O
+    CETBAR U/DBAR CP
+    TCBAR Q0 Q1 Q2 Q3
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CP,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(CETBAR,0)}
+
+    PINDLY:
+       TCBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(3ns,9.5ns,13ns),
+                 CLOCK & TRN_HL, DELAY(2.5ns,9.5ns,13ns),
+                 UP/DOWN & TRN_LH, DELAY(2.5ns,8ns,10.5ns),
+                 UP/DOWN & TRN_HL, DELAY(1.5ns,7ns,9.5ns),
+                 ENAT & TRN_LH, DELAY(3ns,8ns,10.5ns),
+                 ENAT & TRN_HL, DELAY(2ns,7ns,9ns),
+                 DELAY(4ns,10.5ns,14ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(1.5ns,7ns,10ns),
+                 CLOCK & TRN_HL, DELAY(1.5ns,7.5ns,11ns),
+                 DELAY(2.5ns,8.5ns,12ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CP CETBAR CEPBAR PEBAR U/DBAR P0 P1 P2 P3
+          IO_AC
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 154MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 2ns
+         MIN_LO = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) =  P0 P1 P2 P3
+        SETUPTIME = 1.5ns
+        HOLDTIME = 0.5ns
+        WHEN = { PEBAR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) =  CETBAR
+        SETUPTIME = 4ns
+        HOLDTIME = 4ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) =  CEPBAR
+        SETUPTIME = 4.5ns
+        HOLDTIME = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) =  PEBAR
+        SETUPTIME = 2ns
+        HOLDTIME = 1.5ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) =  U/DBAR
+        SETUPTIME_HI = 4.5ns
+        SETUPTIME_LO = 4ns

.ENDS 74AC169

*-----------------------------------------------------------74ACT169------

* 4-Stage Synchronous Bidirectional Counter
* National FACT Advanced CMOS Logic DAtabook, 1993, pages 4-116 to 4-123
* jat 8/27/96

.SUBCKT 74ACT169 PEBAR P0 P1 P2 P3 CEPBAR CETBAR U/DBAR CP Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,5) DPWR DGND
+ PEBAR P0 P1 P2 P3 CETBAR CEPBAR U/DBAR CP Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 TCBARO
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(CETBAR | CEPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q2BAR & Q1BAR & Q0BAR & CE)}
+  X7 = {~(Q2O & Q1O & Q0O & CE)}
+  D0 = {(PEBAR & ~CE & Q0O) | (P0 & ~PEBAR) | (CE & PEBAR & Q0BAR)}
+  D1 = {(X1 & PEBAR & Q1O & ~U/DBAR) | (Q1BAR & ~U/DBAR & PEBAR & Q0BAR & CE)
+      | (P1 & ~PEBAR) | (Q1O & X3 & PEBAR & U/DBAR) |
+        (Q1BAR & PEBAR & U/DBAR & CE & Q0O)}
+  D2 = {(X4 & PEBAR & U/DBAR & Q2O) | (U/DBAR & PEBAR & Q0O & Q1O & Q2BAR & CE) |
+        (P2 & ~PEBAR) | (Q2O & X5 & PEBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & PEBAR & Q1BAR & Q0BAR)}
+  D3 = {(X6 & PEBAR & ~U/DBAR & Q3O) | (~U/DBAR & PEBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (P3 & ~PEBAR) | (Q3O & X7 & PEBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & PEBAR & Q0O & Q1O & Q2O)}
+  TCBARO = {~((~U/DBAR & ~CETBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~CETBAR & Q0O & Q1O & Q2O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP CETBAR U/DBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  T = {CHANGED(CETBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      EDGE & TRN_LH, DELAY(2NS,6.5NS,9NS),
+      EDGE & TRN_HL, DELAY(2NS,6.5NS,9NS),
+      DELAY(3NS,7.5NS,10NS))}
+  TCBAR = {
+    CASE(
+      T & TRN_LH, DELAY(2.5NS,7.5NS,10NS),
+      T & TRN_HL, DELAY(2.5NS,7.5NS,10NS),
+      UPDOWN & TRN_LH, DELAY(2.5NS,8NS,10.5NS),
+      UPDOWN & TRN_HL, DELAY(2.5NS,8NS,10.5NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(3NS,9NS,11.5NS),
+      DELAY(4NS,10NS,12.5NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP P0 P1 P2 P3 CETBAR CEPBAR U/DBAR PEBAR
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 90MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 4NS
+  MIN_HI = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = P0 P1 P2 P3
+  SETUPTIME = 2.5NS
+  HOLDTIME = 1.5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CEPBAR CETBAR
+  SETUPTIME = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 6NS
+  HOLDTIME = 0.5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = U/DBAR
+  SETUPTIME = 7NS
+  HOLDTIME = 0.5NS

.ENDS 74ACT169

* ----------------------------------------------------------- 74ALS169B ------
*  Synchronous 4-Bit Up/Down Binary Counter
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-172 to 2-180
*  jds    4/25/94
*
.SUBCKT 74ALS169B U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS169B LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = { (a0 & a1 & a2 & a3 & ent & U/DBAR) }
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = { (((LOADBAR & QB_O) ^ (enable & a0)) | (B & load))}
+      d2 = { (((LOADBAR & QC_O) ^ (enable & a0 & a1)) | (C & load))}
+      d3 = { (((LOADBAR & QD_O) ^ (enable & a0 & a1 & a2)) | (D & load))}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_ALS00

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(3ns,-1,20ns),
+                 CLOCK & TRN_HL, DELAY(6ns,-1,20ns),
+                 UP/DOWN, DELAY(5ns,-1,19ns),
+                 ENAT & TRN_LH, DELAY(2ns,-1,13ns),
+                 ENAT & TRN_HL, DELAY(3ns,-1,16ns),
+                 DELAY(7ns,-1,21ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2ns,-1,15ns),
+                 CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                 DELAY(7ns,-1,21ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 12.5ns
+         MIN_LO = 12.5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = ENPBAR ENTBAR LOADBAR U/DBAR A B C D
+        SETUPTIME = 15ns

.ENDS 74ALS169B
*
*
* ----------------------------------------------------------- 74AS169 ------
*  Synchronous 4-Bit Up/Down Binary Counter
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-172 to 2-180
*  jds    4/25/94
*
.SUBCKT 74AS169 U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS169 LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = { (a0 & a1 & a2 & a3 & ent & U/DBAR) }
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = { (((LOADBAR & QB_O) ^ (enable & a0)) | (B & load))}
+      d2 = { (((LOADBAR & QC_O) ^ (enable & a0 & a1)) | (C & load))}
+      d3 = { (((LOADBAR & QD_O) ^ (enable & a0 & a1 & a2)) | (D & load))}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_AS00

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(3ns,-1,16.5ns),
+                 CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                 UP/DOWN & TRN_LH, DELAY(2ns,-1,12ns),
+                 UP/DOWN & TRN_HL, DELAY(2ns,-1,13ns),
+                 ENAT, DELAY(1.5ns,-1,9ns),
+                 DELAY(4ns,-1,17.5ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(1ns,-1,7ns),
+                 CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                 DELAY(3ns,-1,14ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_AS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 75MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 6.7ns
+         MIN_LO = 6.7ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = ENPBAR ENTBAR LOADBAR U/DBAR A B C D
+        SETUPTIME = 8ns

.ENDS 74AS169

*-----------------------------------------------------------74AS169A------

* Synchronous Four Bit Up/Down Counter
* National ALS/AS Logic Databook, 1990, pages 3-50 to 3-54
* jat 8/21/96

.SUBCKT 74AS169A LOADBAR A B C D U/DBAR CLK ENPBAR ENTBAR RCOBAR QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) DPWR DGND
+ LOADBAR A B C D ENTBAR ENPBAR U/DBAR Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 RCOBARO
+ D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(ENTBAR | ENPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q2BAR & Q1BAR & Q0BAR & CE)}
+  X7 = {~(Q2O & Q1O & Q0O & CE)}
+  D0 = {(LOADBAR & ~CE & Q0O) | (A & ~LOADBAR) | (CE & LOADBAR & Q0BAR)}
+  D1 = {(X1 & LOADBAR & Q1O & ~U/DBAR) | (Q1BAR & ~U/DBAR & LOADBAR & Q0BAR & CE)
+      | (B & ~LOADBAR) | (Q1O & X3 & LOADBAR & U/DBAR) |
+        (Q1BAR & LOADBAR & U/DBAR & CE & Q0O)}
+  D2 = {(X4 & LOADBAR & U/DBAR & Q2O) | (U/DBAR & LOADBAR & Q0O & Q1O & Q2BAR & CE) |
+        (C & ~LOADBAR) | (Q2O & X5 & LOADBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & LOADBAR & Q1BAR & Q0BAR)}
+  D3 = {(X6 & LOADBAR & ~U/DBAR & Q3O) | (~U/DBAR & LOADBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (D & ~LOADBAR) | (Q3O & X7 & LOADBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & LOADBAR & Q0O & Q1O & Q2O)}
+  RCOBARO = {~((~U/DBAR & ~ENTBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~ENTBAR & Q0O & Q1O & Q2O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CLK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O RCOBARO
+ CLK ENTBAR U/DBAR
+ QA QB QC QD RCOBAR
+ IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLK,0)}
+  T = {CHANGED(ENTBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  QA QB QC QD = {
+    CASE(
+      EDGE & TRN_LH, DELAY(1NS,-1,7NS),
+      EDGE & TRN_HL, DELAY(2NS,-1,13NS),
+      DELAY(3NS,-1,14NS))}
+  RCOBAR = {
+    CASE(
+      T & TRN_LH, DELAY(1.5NS,-1,9NS),
+      T & TRN_HL, DELAY(1.5NS,-1,9NS),
+      UPDOWN & TRN_LH, DELAY(2NS,-1,12NS),
+      UPDOWN & TRN_HL, DELAY(2NS,-1,13NS),
+      EDGE & TRN_LH, DELAY(3NS,-1,16.5NS),
+      EDGE & TRN_HL, DELAY(2NS,-1,13NS),
+      DELAY(3NS,-1,17.5NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CLK A B C D ENPBAR ENTBAR LOADBAR U/DBAR
+ IO_AS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 75MEG
+ WIDTH:
+  NODE  = CLK
+  MIN_LO = 6.7NS
+  MIN_HI = 6.7NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(7) = A B C D ENPBAR ENTBAR LOADBAR
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = U/DBAR
+  SETUPTIME = 11NS

.ENDS 74AS169A

* ----------------------------------------------------------- 74F169 ------
*  Synchronous 4-Bit Up/Down Binary Counter
*
*  The F Logic Data Book, 1994, TI Pages 2-129 to 2-135
*  jds    4/26/94
*
.SUBCKT 74F169 U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F169 LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = { (a0 & a1 & a2 & a3 & ent & U/DBAR) }
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = { (((LOADBAR & QB_O) ^ (enable & a0)) | (B & load))}
+      d2 = { (((LOADBAR & QC_O) ^ (enable & a0 & a1)) | (C & load))}
+      d3 = { (((LOADBAR & QD_O) ^ (enable & a0 & a1 & a2)) | (D & load))}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_F

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(4.7ns,11.6ns,15.5ns),
+                 CLOCK & TRN_HL, DELAY(3.2ns,8.1ns,11ns),
+                 UP/DOWN & TRN_LH, DELAY(2.7ns,8.1ns,11ns),
+                 UP/DOWN & TRN_HL, DELAY(3.2ns,12.1ns,16ns),
+                 ENAT & TRN_LH, DELAY(1.7ns,4.1ns,6ns),
+                 ENAT & TRN_HL, DELAY(1.7ns,5.6ns,8ns),
+                 DELAY(5.7ns,13.1ns,17ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2.2ns,6.1ns,8.5ns),
+                 CLOCK & TRN_HL, DELAY(3.2ns,8.6ns,11.5ns),
+                 DELAY(4.2ns,9.6ns,12.5ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_F
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 115MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 5ns
+         MIN_LO = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  A B C D
+        SETUPTIME = 4ns
+        HOLDTIME = 3ns
+        WHEN = { LOADBAR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  ENTBAR ENPBAR
+        SETUPTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  LOADBAR
+        SETUPTIME = 8ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  U/DBAR
+        SETUPTIME_HI = 11ns
+        SETUPTIME_LO = 16.5ns

.ENDS 74F169

*-----------------------------------------------------------74LS169------

* Modulo 16 Binary Synchronous Bi-directional Counter
* Motorola FAST and LS TTL Logic Data, 1992, pages 5-178 to 5-183
* jat 8/7/96

.SUBCKT 74LS169 PEBAR P0 P1 P2 P3 CEPBAR CETBAR U/DBAR CP Q0 Q1 Q2 Q3 TCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,5) DPWR DGND
+ PEBAR P0 P1 P2 P3 CETBAR CEPBAR U/DBAR CP Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 TCBARO
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(CETBAR | CEPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q2BAR & Q1BAR & Q0BAR & CE)}
+  X7 = {~(Q2O & Q1O & Q0O & CE)}
+  D0 = {(PEBAR & ~CE & Q0O) | (P0 & ~PEBAR) | (CE & PEBAR & Q0BAR)}
+  D1 = {(X1 & PEBAR & Q1O & ~U/DBAR) | (Q1BAR & ~U/DBAR & PEBAR & Q0BAR & CE)
+      | (P1 & ~PEBAR) | (Q1O & X3 & PEBAR & U/DBAR) |
+        (Q1BAR & PEBAR & U/DBAR & CE & Q0O)}
+  D2 = {(X4 & PEBAR & U/DBAR & Q2O) | (U/DBAR & PEBAR & Q0O & Q1O & Q2BAR & CE) |
+        (P2 & ~PEBAR) | (Q2O & X5 & PEBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & PEBAR & Q1BAR & Q0BAR)}
+  D3 = {(X6 & PEBAR & ~U/DBAR & Q3O) | (~U/DBAR & PEBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (P3 & ~PEBAR) | (Q3O & X7 & PEBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & PEBAR & Q0O & Q1O & Q2O)}
+  TCBARO = {~((~U/DBAR & ~CETBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~CETBAR & Q0O & Q1O & Q2O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O TCBARO
+ CP CETBAR U/DBAR
+ Q0 Q1 Q2 Q3 TCBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  T = {CHANGED(CETBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+    CASE(
+      EDGE & TRN_LH, DELAY(-1,13NS,20NS),
+      EDGE & TRN_HL, DELAY(-1,15NS,23NS),
+      DELAY(-1,16NS,24NS))}
+  TCBAR = {
+    CASE(
+      T & TRN_LH, DELAY(-1,15NS,20NS),
+      T & TRN_HL, DELAY(-1,15NS,20NS),
+      UPDOWN & TRN_LH, DELAY(-1,17NS,25NS),
+      UPDOWN & TRN_HL, DELAY(-1,19NS,29NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,35NS),
+      DELAY(-1,24NS,36NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP P0 P1 P2 P3 CETBAR CEPBAR U/DBAR PEBAR
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 32MEG
+ WIDTH:
+  NODE  = CP
+  MIN_LO = 25NS
+  MIN_HI = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(6) = P0 P1 P2 P3 CETBAR CEPBAR
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = U/DBAR
+  SETUPTIME = 30NS

.ENDS 74LS169

*-----------------------------------------------------------74LS169A------

* Synchronous 4-Bit Up/Down Binary Counter
* National LS/S/TTL Logic Databook, 1989, pages 2-203 to 2-207
* jat 8/7/96

.SUBCKT 74LS169A LDBAR ENTBAR ENPBAR U/DBAR CLOCK A B C D QA QB QC QD RCBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,5) DPWR DGND
+ LDBAR ENTBAR ENPBAR U/DBAR A B C D CP Q0O Q1O Q2O Q3O Q0BAR Q1BAR Q2BAR Q3BAR
+ D0 D1 D2 D3 RCBARO
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CE = {~(ENTBAR | ENPBAR)}
+  X1 = {~(Q0BAR & CE)}
+  X3 = {~(Q0O & CE)}
+  X4 = {~(Q1O & Q0O & CE)}
+  X5 = {~(Q1BAR & Q0BAR & CE)}
+  X6 = {~(Q2BAR & Q1BAR & Q0BAR & CE)}
+  X7 = {~(Q2O & Q1O & Q0O & CE)}
+  D0 = {(LDBAR & ~CE & Q0O) | (A & ~LDBAR) | (CE & LDBAR & Q0BAR)}
+  D1 = {(X1 & LDBAR & Q1O & ~U/DBAR) | (Q1BAR & ~U/DBAR & LDBAR & Q0BAR & CE)
+      | (B & ~LDBAR) | (Q1O & X3 & LDBAR & U/DBAR) |
+        (Q1BAR & LDBAR & U/DBAR & CE & Q0O)}
+  D2 = {(X4 & LDBAR & U/DBAR & Q2O) | (U/DBAR & LDBAR & Q0O & Q1O & Q2BAR & CE) |
+        (C & ~LDBAR) | (Q2O & X5 & LDBAR & ~U/DBAR) |
+        (Q2BAR & ~U/DBAR & CE & LDBAR & Q1BAR & Q0BAR)}
+  D3 = {(X6 & LDBAR & ~U/DBAR & Q3O) | (~U/DBAR & LDBAR & Q3BAR & Q2BAR & Q1BAR & Q0BAR & CE) |
+        (D & ~LDBAR) | (Q3O & X7 & LDBAR & U/DBAR) |
+        (Q3BAR & U/DBAR & CE & LDBAR & Q0O & Q1O & Q2O)}
+  RCBARO = {~((~U/DBAR & ~ENTBAR & Q0BAR & Q1BAR & Q2BAR & Q3BAR) |
+               (U/DBAR & ~ENTBAR & Q0O & Q1O & Q2O & Q3O))}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CLOCK
+ D0 D1 D2 D3
+ Q0O Q1O Q2O Q3O
+ Q0BAR Q1BAR Q2BAR Q3BAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O RCBARO
+ CLOCK ENTBAR U/DBAR
+ QA QB QC QD RCBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLOCK,0)}
+  T = {CHANGED(ENTBAR,0)}
+  UPDOWN = {CHANGED(U/DBAR,0)}
+ PINDLY:
+  QA QB QC QD = {
+    CASE(
+      EDGE & TRN_LH, DELAY(-1,-1,20NS),
+      EDGE & TRN_HL, DELAY(-1,-1,23NS),
+      DELAY(-1,-1,24NS))}
+  RCBAR = {
+    CASE(
+      T & TRN_LH, DELAY(-1,-1,18NS),
+      T & TRN_HL, DELAY(-1,-1,18NS),
+      UPDOWN & TRN_LH, DELAY(-1,-1,25NS),
+      UPDOWN & TRN_HL, DELAY(-1,-1,29NS),
+      EDGE & (TRN_LH | TRN_HL), DELAY(-1,-1,35NS),
+      DELAY(-1,-1,36NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CLOCK A B C D ENTBAR ENPBAR U/DBAR LDBAR
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 25MEG
+ WIDTH:
+  NODE  = CLOCK
+  MIN_LO = 25NS
+  MIN_HI = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(6) = A B C D ENTBAR ENPBAR
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LDBAR
+  SETUPTIME = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = U/DBAR
+  SETUPTIME = 30NS

.ENDS 74LS169A

* ----------------------------------------------------------- 74LS169B ------
*  Synchronous 4-Bit Up/Down Binary Counter
*
*  The TTL Logic Data Book, 1985, TI Pages 3-651 to 3-664
*  jds    4/25/94
*
.SUBCKT 74LS169B U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS169B LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = { (a0 & a1 & a2 & a3 & ent & U/DBAR) }
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = { (((LOADBAR & QB_O) ^ (enable & a0)) | (B & load))}
+      d2 = { (((LOADBAR & QC_O) ^ (enable & a0 & a1)) | (C & load))}
+      d3 = { (((LOADBAR & QD_O) ^ (enable & a0 & a1 & a2)) | (D & load))}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_LS

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,26ns,40ns),
+                 CLOCK & TRN_HL, DELAY(-1,17ns,25ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,23ns,35ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,15ns,25ns),
+                 ENAT & TRN_LH, DELAY(-1,15ns,25ns),
+                 ENAT & TRN_LH, DELAY(-1,11ns,20ns),
+                 DELAY(-1,27ns,36ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,16ns,25ns),
+                 CLOCK & TRN_HL, DELAY(-1,17ns,25ns),
+                 DELAY(-1,18ns,26ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 35MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+         MIN_LO = 25ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(6) =  A B C D ENTBAR ENPBAR
+        SETUPTIME = 30ns
+         WHEN = { LOADBAR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  LOADBAR U/DBAR
+        SETUPTIME = 35ns

.ENDS 74LS169B
*
*
* ----------------------------------------------------------- 74S169 ------
*  Synchronous 4-Bit Up/Down Binary Counter
*
*  The TTL Logic Data Book, 1985, TI Pages 3-651 to 3-664
*  jds    4/25/94
*
.SUBCKT 74S169 U/DBAR CLK A B C D ENPBAR LOADBAR ENTBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S169 LOGICEXP (17,10) DPWR DGND
+      U/DBAR A B C D ENPBAR LOADBAR ENTBAR CLK
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O d0 d1 d2 d3 k0 k1 k2 k3 clkbar
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      load = {(~LOADBAR)}
+      ent = {(~ENTBAR)}
+      ubar/d = {(~U/DBAR)}
+      a0 = {(~((U/DBAR & qabar) | (ubar/d & QA_O)))}
+      a1 = {(~((U/DBAR & qbbar) | (ubar/d & QB_O)))}
+      a2 = {(~((U/DBAR & qcbar) | (ubar/d & QC_O)))}
+      a3 = {(~((U/DBAR & qdbar) | (ubar/d & QD_O)))}
+      a4 = { (a0 & a1 & a2 & a3 & ent & U/DBAR) }
+      a5 = { (a0 & a1 & a2 & a3 & ent & ubar/d) }
+      RCOBAR_O = { (~(a4 | a5))}
+      b0 = {~(qdbar & qcbar & ubar/d)}
+      enable = {( ent & ~ENPBAR & LOADBAR)}
+      d0 = { (((LOADBAR & QA_O) ^ enable) | (A & load))}
+      d1 = { (((LOADBAR & QB_O) ^ (enable & a0)) | (B & load))}
+      d2 = { (((LOADBAR & QC_O) ^ (enable & a0 & a1)) | (C & load))}
+      d3 = { (((LOADBAR & QD_O) ^ (enable & a0 & a1 & a2)) | (D & load))}
+      k0 = { ~d0 }
+      k1 = { ~d1 }
+      k2 = { ~d2 }
+      k3 = { ~d3 }
+      clkbar = {~CLK }

uf0 jkFF(4) DPWR DGND
+ $D_HI $D_HI clkbar d0 d1 d2 d3 k0 k1 k2 k3
+ QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+ D0_EFF IO_S

Udly PINDLY (5,0,3) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O
+    ENTBAR U/DBAR CLK
+    RCOBAR QA QB QC QD
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     UP/DOWN = {CHANGED(U/DBAR,0)}
+     COUNTING_UP = {  U/DBAR == '1 }
+     ENAT = {CHANGED(ENTBAR,0)}
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,14ns,21ns),
+                 CLOCK & TRN_HL, DELAY(-1,20ns,28ns),
+                 UP/DOWN & COUNTING_UP & TRN_LH, DELAY(-1,9ns,15ns),
+                 UP/DOWN & COUNTING_UP & TRN_HL, DELAY(-1,10ns,15ns),
+                 ENAT & COUNTING_UP & TRN_LH, DELAY(-1,7.5ns,11ns),
+                 ENAT & COUNTING_UP & TRN_LH, DELAY(-1,15ns,22ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,8ns,15ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,16ns,22ns),
+                 ENAT & TRN_LH, DELAY(-1,6ns,12ns),
+                 ENAT & TRN_LH, DELAY(-1,15ns,25ns),
+                 DELAY(-1,21ns,29ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,8ns,15ns),
+                 CLOCK & TRN_HL, DELAY(-1,11ns,15ns),
+                 DELAY(-1,12ns,16ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLK ENTBAR ENPBAR LOADBAR U/DBAR A B C D
+          IO_S
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 10ns
+         MIN_LO = 10ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  A B C D
+        SETUPTIME = 4ns
+        HOLDTIME = 1ns
+        WHEN = { LOADBAR !='1 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  ENTBAR ENPBAR
+        SETUPTIME = 14ns
+        HOLDTIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  LOADBAR
+        SETUPTIME = 6ns
+        HOLDTIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  U/DBAR
+        SETUPTIME = 20ns
+        HOLDTIME = 1ns

.ENDS 74S169
*
*
* ----------------------------------------------------------- 74170 ------
*  4-By-4 Register Files with Open-Collector Outputs
*
*  The TTL Logic Data Book, 1988, TI Pages 2-555 to 2-563
*  jds    4/25/94

.SUBCKT 74170 D1 D2 D3 D4 GWBAR WB WA Q1 Q2 Q3 Q4 RB RA GRBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74170 LOGICEXP (26,8) DPWR DGND
+      D1 D2 D3 D4 GWBAR WB WA RB RA GRBAR
+      q11 q12 q13 q14 q21 q22 q23 q24
+      q31 q32 q33 q34 q41 q42 q43 q44
+      g1 g2 g3 g4 Q1_O Q2_O Q3_O Q4_O
+      D0_GATE IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+    g1 = { ((~WB & ~GWBAR) & (~WA)) }
+    g2 = { ((~WB & ~GWBAR) & WA) }
+    g3 = { ((~(~WB & ~GWBAR) & ~GWBAR) & (~WA)) }
+    g4 = { ((~(~WB & ~GWBAR) & ~GWBAR) & (WA)) }
+    a1 = { ~((q11 & (~RB) & (~RA)) |
+             (q21 & (~RB) & (RA)) |
+             (q31 & (RB) & (~RA)) |
+             (q41 & (RB) & (RA)) ) }
+    a2 = { ~((q12 & (~RB) & (~RA)) |
+             (q22 & (~RB) & (RA)) |
+             (q32 & (RB) & (~RA)) |
+             (q42 & (RB) & (RA)) ) }
+    a3 = { ~((q13 & (~RB) & (~RA)) |
+             (q23 & (~RB) & (RA)) |
+             (q33 & (RB) & (~RA)) |
+             (q43 & (RB) & (RA)) ) }
+    a4 = { ~((q14 & (~RB) & (~RA)) |
+             (q24 & (~RB) & (RA)) |
+             (q34 & (RB) & (~RA)) |
+             (q44 & (RB) & (RA)) ) }
+    Q1_O = { ~(a1 & ~GRBAR) }
+    Q2_O = { ~(a2 & ~GRBAR) }
+    Q3_O = { ~(a3 & ~GRBAR) }
+    Q4_O = { ~(a4 & ~GRBAR) }

uf1 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g1 D1 D2 D3 D4
+ q11 q12 q13 q14 q11bar q12bar q13bar q14bar
+ D0_GFF IO_STD_OC

uf2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g2 D1 D2 D3 D4
+ q21 q22 q23 q24 q21bar q22bar q23bar q24bar
+ D0_GFF IO_STD_OC

uf3 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g3 D1 D2 D3 D4
+ q31 q32 q33 q34 q31bar q32bar q33bar q34bar
+ D0_GFF IO_STD_OC

uf4 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g4 D1 D2 D3 D4
+ q41 q42 q43 q44 q41bar q42bar q43bar q44bar
+ D0_GFF IO_STD_OC

Udly PINDLY (4,0,8) DPWR DGND
+    Q1_O Q2_O Q3_O Q4_O
+    GRBAR GWBAR D1 D2 D3 D4 RA RB
+    Q1 Q2 Q3 Q4
+    IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     READ_EN = { CHANGED(GRBAR,0) }
+     READ_SEL = { CHANGED(RA,0) | CHANGED(RB,0) }
+     WRITE_EN = { CHANGED(GWBAR,0) }
+     DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D4,0)}
+
+    PINDLY:
+       Q1 Q2 Q3 Q4 = {
+            CASE(
+                 READ_EN & TRN_LH, DELAY(-1,10ns,15ns),
+                 READ_EN & TRN_HL, DELAY(-1,20ns,30ns),
+                 READ_SEL & TRN_LH, DELAY(-1,23ns,35ns),
+                 READ_SEL & TRN_HL, DELAY(-1,30ns,40ns),
+                 WRITE_EN & TRN_LH, DELAY(-1,25ns,40ns),
+                 WRITE_EN & TRN_HL, DELAY(-1,34ns,45ns),
+                 DATA & TRN_LH, DELAY(-1,20ns,30ns),
+                 DATA & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,35ns,46ns)
+                )
+            }

Ucnstr CONSTRAINT(10) DPWR DGND
+          D1 D2 D3 D4 GWBAR WB WA RB RA GRBAR
+          IO_STD_OC
+
+ WIDTH:
+   NODE      = GWBAR
+   MIN_LO    = 25ns
+ WIDTH:
+   NODE      = GRBAR
+   MIN_LO    = 25ns
+ SETUP_HOLD:
+   CLOCK LH  = GWBAR
+   DATA(4)   = D1 D2 D3 D4
+   SETUPTIME = 10ns
+   HOLDTIME  = 15ns
+ SETUP_HOLD:
+   CLOCK HL  = GWBAR
+   DATA(2)   = WA WB
+   SETUPTIME = 15ns
+ SETUP_HOLD:
+   CLOCK LH  = GWBAR
+   DATA(2)   = WA WB
+   HOLDTIME  = 5ns

.ENDS 74170
*
*
* ----------------------------------------------------------- 74LS170 ------
*  4-By-4 Register Files with Open-Collector Outputs
*
*  The TTL Logic Data Book, 1988, TI Pages 2-555 to 2-563
*  jds    4/25/94

.SUBCKT 74LS170 D1 D2 D3 D4 GWBAR WB WA Q1 Q2 Q3 Q4 RB RA GRBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS170 LOGICEXP (26,8) DPWR DGND
+      D1 D2 D3 D4 GWBAR WB WA RB RA GRBAR
+      q11 q12 q13 q14 q21 q22 q23 q24
+      q31 q32 q33 q34 q41 q42 q43 q44
+      g1 g2 g3 g4 Q1_O Q2_O Q3_O Q4_O
+      D0_GATE IO_LS_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+    g1 = { ((~WB & ~GWBAR) & (~WA)) }
+    g2 = { ((~WB & ~GWBAR) & WA) }
+    g3 = { ((~(~WB & ~GWBAR) & ~GWBAR) & (~WA)) }
+    g4 = { ((~(~WB & ~GWBAR) & ~GWBAR) & (WA)) }
+    a1 = { ~((q11 & (~RB) & (~RA)) |
+             (q21 & (~RB) & (RA)) |
+             (q31 & (RB) & (~RA)) |
+             (q41 & (RB) & (RA)) ) }
+    a2 = { ~((q12 & (~RB) & (~RA)) |
+             (q22 & (~RB) & (RA)) |
+             (q32 & (RB) & (~RA)) |
+             (q42 & (RB) & (RA)) ) }
+    a3 = { ~((q13 & (~RB) & (~RA)) |
+             (q23 & (~RB) & (RA)) |
+             (q33 & (RB) & (~RA)) |
+             (q43 & (RB) & (RA)) ) }
+    a4 = { ~((q14 & (~RB) & (~RA)) |
+             (q24 & (~RB) & (RA)) |
+             (q34 & (RB) & (~RA)) |
+             (q44 & (RB) & (RA)) ) }
+    Q1_O = { ~(a1 & ~GRBAR) }
+    Q2_O = { ~(a2 & ~GRBAR) }
+    Q3_O = { ~(a3 & ~GRBAR) }
+    Q4_O = { ~(a4 & ~GRBAR) }

uf1 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g1 D1 D2 D3 D4
+ q11 q12 q13 q14 q11bar q12bar q13bar q14bar
+ D0_GFF IO_LS_OC

uf2 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g2 D1 D2 D3 D4
+ q21 q22 q23 q24 q21bar q22bar q23bar q24bar
+ D0_GFF IO_LS_OC

uf3 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g3 D1 D2 D3 D4
+ q31 q32 q33 q34 q31bar q32bar q33bar q34bar
+ D0_GFF IO_LS_OC

uf4 DLTCH(4) DPWR DGND
+ $D_HI $D_HI g4 D1 D2 D3 D4
+ q41 q42 q43 q44 q41bar q42bar q43bar q44bar
+ D0_GFF IO_LS_OC

Udly PINDLY (4,0,8) DPWR DGND
+    Q1_O Q2_O Q3_O Q4_O
+    GRBAR GWBAR D1 D2 D3 D4 RA RB
+    Q1 Q2 Q3 Q4
+    IO_LS_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     READ_EN = { CHANGED(GRBAR,0) }
+     READ_SEL = { CHANGED(RA,0) | CHANGED(RB,0) }
+     WRITE_EN = { CHANGED(GWBAR,0) }
+     DATA = {CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) | CHANGED(D4,0)}
+
+    PINDLY:
+       Q1 Q2 Q3 Q4 = {
+            CASE(
+                 READ_EN, DELAY(-1,20ns,30ns),
+                 READ_SEL & TRN_LH, DELAY(-1,25ns,40ns),
+                 READ_SEL & TRN_HL, DELAY(-1,24ns,40ns),
+                 WRITE_EN & TRN_LH, DELAY(-1,30ns,45ns),
+                 WRITE_EN & TRN_HL, DELAY(-1,26ns,40ns),
+                 DATA & TRN_LH, DELAY(-1,30ns,45ns),
+                 DATA & TRN_HL, DELAY(-1,22ns,35ns),
+                 DELAY(-1,31ns,46ns)
+                )
+            }

Ucnstr CONSTRAINT(10) DPWR DGND
+          D1 D2 D3 D4 GWBAR WB WA RB RA GRBAR
+          IO_LS_OC
+
+ WIDTH:
+   NODE      = GWBAR
+   MIN_LO    = 25ns
+ WIDTH:
+   NODE      = GRBAR
+   MIN_LO    = 25ns
+ SETUP_HOLD:
+   CLOCK LH  = GWBAR
+   DATA(4)   = D1 D2 D3 D4
+   SETUPTIME = 10ns
+   HOLDTIME  = 15ns
+ SETUP_HOLD:
+   CLOCK HL  = GWBAR
+   DATA(2)   = WA WB
+   SETUPTIME = 15ns
+ SETUP_HOLD:
+   CLOCK LH  = GWBAR
+   DATA(2)   = WA WB
+   HOLDTIME  = 5ns

.ENDS 74LS170
*
*
* ----------------------------------------------------------- 74LS171 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-565 to 2-567
*  jds    4/27/94
*
.SUBCKT 74LS171 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dFF(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFF171 IO_LS

.model DFF171 ueff(TPPCQLHMN=-1  TPPCQLHTY=18ns   TPPCQLHMX=30ns
+                  TPPCQHLMN=-1   TPPCQHLTY=24ns   TPPCQHLMX=40ns
+                  TWPCLMN=-1     TWPCLTY=20ns     TWPCLMX=-1
+                  TPCLKQLHMN=-1  TPCLKQLHTY=15ns  TPCLKQLHMX=25ns
+                  TPCLKQHLMN=-1  TPCLKQHLTY=18ns  TPCLKQHLMX=30ns
+                  TWCLKLMN=-1    TWCLKLTY=-1      TWCLKLMX=-1
+                  TWCLKHMN=-1    TWCLKHTY=20ns    TWCLKHMX=-1
+                  TSUDCLKMN=-1   TSUDCLKTY=20ns   TSUDCLKMX=-1
+                  TSUPCCLKHMN=-1 TSUPCCLKHTY=25ns TSUPCCLKHMX=-1
+                  THDCLKMN=-1    THDCLKTY=5ns     THDCLKMX=-1)

.ENDS 74LS171
*
*
* ----------------------------------------------------------- 74172 ------
*  16-Bit Multiple Port Register File with 3-State Outputs
*
*  The TTL Logic Data Book, 1988, TI Pages 2-569 to 2-574
*  jds    4/27/94
*  Note: This part is not yet available in the component editor.

.SUBCKT 74172 1W0 1W1 1W2 1R0 1R1 1R2 1GWBAR 1GRBAR 2W/R0 2W/R1 2W/R2
+             2GWBAR 2GRBAR CLK 1DA 2DA 1DB 2DB 1QA 2QA 1QB 2QB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74172 LOGICEXP (32,14) DPWR DGND
+      1W0 1W1 1W2 1R0 1R1 1R2 1GWBAR 2W/R0 2W/R1 2W/R2
+      2GWBAR CLK 1DA 2DA 1DB 2DB
+      q11 q21 q31 q41 q51 q61 q71 q81
+      q12 q22 q32 q42 q52 q62 q72 q82
+      ad1 ad2 ad3 ad4 ad5 ad6 ad7 ad8
+      data1 data2 1QA_O 2QA_O 1QB_O 2QB_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      dat1a = { 1DA & (~1GWBAR) & 2GWBAR }
+      dat1b = { 2DA & 1GWBAR & (~2GWBAR) }
+      dat1c = { 1DA & 2DA & (~(1GWBAR | 2GWBAR)) }
+      data1 = { dat1a | dat1b | dat1c }
+      dat2a = { 1DB & (~1GWBAR) & 2GWBAR }
+      dat2b = { 2DB & 1GWBAR & (~2GWBAR) }
+      dat2c = { 1DB & 2DB & (~(1GWBAR | 2GWBAR)) }
+      data2 = { dat2a | dat2b | dat2c }
+      clksig1 = { (CLK & (~1GWBAR)) }
+      clksig2 = { (CLK & (~2GWBAR)) }
+      y01 = { (clksig1 & (~1W2) & (~1W1) & (~1W0) ) }
+      y11 = { (clksig1 & (~1W2) & (~1W1) & 1W0 ) }
+      y21 = { (clksig1 & (~1W2) & 1W1 & (~1W0) ) }
+      y31 = { (clksig1 & (~1W2) & 1W1 & 1W0 ) }
+      y41 = { (clksig1 & 1W2 & (~1W1) & (~1W0) ) }
+      y51 = { (clksig1 & 1W2 & (~1W1) & 1W0 ) }
+      y61 = { (clksig1 & 1W2 & 1W1 & (~1W0) ) }
+      y71 = { (clksig1 & 1W2 & 1W1 & ~1W0 ) }
+      y02 = { (clksig2 & (~2W/R2) & (~2W/R1) & (~2W/R0) ) }
+      y12 = { (clksig2 & (~2W/R2) & (~2W/R1) & 2W/R0 ) }
+      y22 = { (clksig2 & (~2W/R2) & 2W/R1 & (~2W/R0) ) }
+      y32 = { (clksig2 & (~2W/R2) & 2W/R1 & 2W/R0 ) }
+      y42 = { (clksig2 & 2W/R2 & (~2W/R1) & (~2W/R0) ) }
+      y52 = { (clksig2 & 2W/R2 & (~2W/R1) & 2W/R0 ) }
+      y62 = { (clksig2 & 2W/R2 & 2W/R1 & (~2W/R0) ) }
+      y72 = { (clksig2 & 2W/R2 & 2W/R1 & 2W/R0 ) }
+      ad1 = { y01 | y02 }
+      ad2 = { y11 | y12 }
+      ad3 = { y21 | y22 }
+      ad4 = { y31 | y32 }
+      ad5 = { y41 | y42 }
+      ad6 = { y51 | y52 }
+      ad7 = { y61 | y62 }
+      ad8 = { y71 | y72 }
+      za0 = { (q11 & (~1R2) & (~1R1) & (~1R0) ) }
+      za1 = { (q21 & (~1R2) & (~1R1) & 1R0 ) }
+      za2 = { (q31 & (~1R2) & 1R1 & (~1R0) ) }
+      za3 = { (q41 & (~1R2) & 1R1 & 1R0 ) }
+      za4 = { (q51 & 1R2 & (~1R1) & (~1R0) ) }
+      za5 = { (q61 & 1R2 & (~1R1) & 1R0 ) }
+      za6 = { (q71 & 1R2 & 1R1 & (~1R0) ) }
+      za7 = { (q81 & 1R2 & 1R1 & 1R0 ) }
+      zb0 = { (q12 & (~1R2) & (~1R1) & (~1R0) ) }
+      zb1 = { (q22 & (~1R2) & (~1R1) & 1R0 ) }
+      zb2 = { (q32 & (~1R2) & 1R1 & (~1R0) ) }
+      zb3 = { (q42 & (~1R2) & 1R1 & 1R0 ) }
+      zb4 = { (q52 & 1R2 & (~1R1) & (~1R0) ) }
+      zb5 = { (q62 & 1R2 & (~1R1) & 1R0 ) }
+      zb6 = { (q72 & 1R2 & 1R1 & (~1R0) ) }
+      zb7 = { (q82 & 1R2 & 1R1 & 1R0 ) }
+      xa0 = { (q11 & (~2W/R2) & (~2W/R1) & (~2W/R0) ) }
+      xa1 = { (q21 & (~2W/R2) & (~2W/R1) & 2W/R0 ) }
+      xa2 = { (q31 & (~2W/R2) & 2W/R1 & (~2W/R0) ) }
+      xa3 = { (q41 & (~2W/R2) & 2W/R1 & 2W/R0 ) }
+      xa4 = { (q51 & 2W/R2 & (~2W/R1) & (~2W/R0) ) }
+      xa5 = { (q61 & 2W/R2 & (~2W/R1) & 2W/R0 ) }
+      xa6 = { (q71 & 2W/R2 & 2W/R1 & (~2W/R0) ) }
+      xa7 = { (q81 & 2W/R2 & 2W/R1 & 2W/R0 ) }
+      xb0 = { (q12 & (~2W/R2) & (~2W/R1) & (~2W/R0) ) }
+      xb1 = { (q22 & (~2W/R2) & (~2W/R1) & 2W/R0 ) }
+      xb2 = { (q32 & (~2W/R2) & 2W/R1 & (~2W/R0) ) }
+      xb3 = { (q42 & (~2W/R2) & 2W/R1 & 2W/R0 ) }
+      xb4 = { (q52 & 2W/R2 & (~2W/R1) & (~2W/R0) ) }
+      xb5 = { (q62 & 2W/R2 & (~2W/R1) & 2W/R0 ) }
+      xb6 = { (q72 & 2W/R2 & 2W/R1 & (~2W/R0) ) }
+      xb7 = { (q82 & 2W/R2 & 2W/R1 & 2W/R0 ) }
+      1QA_O = { ( za0 | za1 | za2 | za3 | za4 | za5 | za6 | za7 ) }
+      1QB_O = { ( zb0 | zb1 | zb2 | zb3 | zb4 | zb5 | zb6 | zb7 ) }
+      2QA_O = { ( xa0 | xa1 | xa2 | xa3 | xa4 | xa5 | xa6 | xa7 ) }
+      2QB_O = { ( xb0 | xb1 | xb2 | xb3 | xb4 | xb5 | xb6 | xb7 ) }

uf1 DFF(2) DPWR DGND
+ $D_HI $D_HI ad1 data1 data2
+ q11 q12 q11bar q12bar
+ D0_EFF IO_STD

uf2 DFF(2) DPWR DGND
+ $D_HI $D_HI ad2 data1 data2
+ q21 q22 q21bar q22bar
+ D0_EFF IO_STD

uf3 DFF(2) DPWR DGND
+ $D_HI $D_HI ad3 data1 data2
+ q31 q32 q31bar q32bar
+ D0_EFF IO_STD

uf4 DFF(2) DPWR DGND
+ $D_HI $D_HI ad4 data1 data2
+ q41 q42 q41bar q42bar
+ D0_EFF IO_STD

uf5 DFF(2) DPWR DGND
+ $D_HI $D_HI ad5 data1 data2
+ q51 q52 q51bar q52bar
+ D0_EFF IO_STD

uf6 DFF(2) DPWR DGND
+ $D_HI $D_HI ad6 data1 data2
+ q61 q62 q61bar q62bar
+ D0_EFF IO_STD

uf7 DFF(2) DPWR DGND
+ $D_HI $D_HI ad7 data1 data2
+ q71 q72 q71bar q72bar
+ D0_EFF IO_STD

uf8 DFF(2) DPWR DGND
+ $D_HI $D_HI ad8 data1 data2
+ q81 q82 q81bar q82bar
+ D0_EFF IO_STD

Udly PINDLY (4,2,7) DPWR DGND
+    1QA_O 1QB_O 2QA_O 2QB_O
+    1GRBAR 2GRBAR
+    CLK 1R2 1R1 1R0 2W/R2 2W/R1 2W/R0
+    1QA 1QB 2QA 2QB
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     READ_SEL = { CHANGED(1R2,0) | CHANGED(1R1,0) | CHANGED(1R0,0) |
+                  CHANGED(2W/R2,0) | CHANGED(2W/R1,0) | CHANGED(2W/R0,0) }
+     CLOCK = { CHANGED(CLK,0) }
+
+    TRISTATE:
+      ENABLE LO = 1GRBAR
+       1QA 2QA = {
+            CASE(
+                 TRN_ZH, DELAY(-1,14ns,30ns),
+                 TRN_ZL, DELAY(-1,16ns,30ns),
+                 TRN_HZ, DELAY(-1,6ns,20ns),
+                 TRN_LZ, DELAY(-1,11ns,20ns),
+                 READ_SEL & TRN_LH, DELAY(-1,33ns,45ns),
+                 READ_SEL & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,35ns,50ns)
+                )
+            }
+    TRISTATE:
+      ENABLE LO = 2GRBAR
+       1QB 2QB = {
+            CASE(
+                 TRN_ZH, DELAY(-1,14ns,30ns),
+                 TRN_ZL, DELAY(-1,16ns,30ns),
+                 TRN_HZ, DELAY(-1,6ns,20ns),
+                 TRN_LZ, DELAY(-1,11ns,20ns),
+                 READ_SEL & TRN_LH, DELAY(-1,33ns,45ns),
+                 READ_SEL & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,35ns,50ns)
+                )
+            }

Ucnstr CONSTRAINT(7) DPWR DGND
+          1GWBAR 2GWBAR CLK 1DA 2DA 1DB 2DB
+          IO_STD
+
+ WIDTH:
+   NODE      = CLK
+   MIN_HI    = 25ns
+ SETUP_HOLD:
+   CLOCK LH  = CLK
+   DATA(4)   = 1DA 2DA 1DB 2DB
+   SETUPTIME_LO = 45ns
+   SETUPTIME_HI = 30ns
+ SETUP_HOLD:
+   CLOCK LH  = CLK
+   DATA(2)   = 1GWBAR 2GWBAR
+   SETUPTIME = 35ns

.ENDS 74172
*
*
* ----------------------------------------------------------- 74173 ------
*  4-Bit D-Type Registers with 3-State Outputs
*
*  The TTL Logic Data Book, 1988, TI Pages 2-575 to 2-579
*  jds    4/28/94
*
.SUBCKT 74173 CLK CLR 1D 2D 3D 4D 1Q 2Q 3Q 4Q M N G1BAR G2BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74173 LOGICEXP (17,10) DPWR DGND
+      M N 1D 2D 3D 4D CLR q1 q2 q3 q4 q1bar q2bar q3bar q4bar G1BAR G2BAR
+      d1 d2 d3 d4 clrbar 1Q_O 2Q_O 3Q_O 4Q_O enout
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clrbar = { ~(CLR) }
+      enable = { ~(G1BAR | G2BAR) }
+      enout = { ~( M | N ) }
+      d1 = { (q1 & (~enable)) | (1D & enable) }
+      d2 = { (q2 & (~enable)) | (2D & enable) }
+      d3 = { (q3 & (~enable)) | (3D & enable) }
+      d4 = { (q4 & (~enable)) | (4D & enable) }
+      1Q_O = { ~(q1bar)}
+      2Q_O = { ~(q2bar)}
+      3Q_O = { ~(q3bar)}
+      4Q_O = { ~(q4bar)}

uf0 dFF(4) DPWR DGND
+ $D_HI clrbar CLK d1 d2 d3 d4
+ q1 q2 q3 q4 q1bar q2bar q3bar q4bar
+ D0_EFF IO_STD

Udly PINDLY (4,1,2) DPWR DGND
+    1Q_O 2Q_O 3Q_O 4Q_O
+    enout
+    CLK clrbar
+    1Q 2Q 3Q 4Q
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     CLEAR = { CHANGED(clrbar,0) }
+
+    TRISTATE:
+      ENABLE HI = enout
+       1Q 2Q 3Q 4Q = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,18ns,27ns),
+                 CLOCK & TRN_LH, DELAY(-1,28ns,43ns),
+                 CLOCK & TRN_HL, DELAY(-1,19ns,31ns),
+                 TRN_ZH, DELAY(7ns,16ns,30ns),
+                 TRN_ZL, DELAY(7ns,21ns,30ns),
+                 TRN_HZ, DELAY(3ns,5ns,14ns),
+                 TRN_LZ, DELAY(3ns,11ns,20ns),
+                 DELAY(8ns,29ns,44ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK 1D 2D 3D 4D G1BAR G2BAR CLR
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  1D 2D 3D 4D
+        SETUPTIME = 10ns
+        HOLDTIME = 10ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  G1BAR G2BAR
+        SETUPTIME = 17ns
+        HOLDTIME = 2ns

.ENDS 74173
*
*
* ----------------------------------------------------------- 74F173 ------
*  4-Bit D-Type Registers with 3-State Outputs
*
*  The Philips Fast TTL Logic Data Book, 1992, TI Pages 229-233
*  jds    4/28/94
*
.SUBCKT 74F173 CP MR D0 D1 D2 D3 Q0 Q1 Q2 Q3 OE0BAR OE1BAR E0BAR E1BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F173 LOGICEXP (13,6) DPWR DGND
+      E0BAR E1BAR D0 D1 D2 D3 MR Q0_O Q1_O Q2_O Q3_O OE0BAR OE1BAR
+      da db dc dd mrbar en_out
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      mrbar = { ~(MR) }
+      enable = { ~(E0BAR | E1BAR) }
+      en_out = { ~( OE0BAR | OE1BAR ) }
+      da = { (Q0_O & (~enable)) | (D0 & enable) }
+      db = { (Q1_O & (~enable)) | (D1 & enable) }
+      dc = { (Q2_O & (~enable)) | (D2 & enable) }
+      dd = { (Q3_O & (~enable)) | (D3 & enable) }

uf0 dFF(4) DPWR DGND
+ $D_HI mrbar CP da db dc dd
+ Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+ D0_EFF IO_F

Udly PINDLY (4,1,2) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O
+    en_out
+    CP mrbar
+    Q0 Q1 Q2 Q3
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CP,0) }
+     CLEAR = { CHANGED(mrbar,0) }
+
+    TRISTATE:
+      ENABLE HI = en_out
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(6.5ns,8.5ns,11.5ns),
+                 CLOCK & TRN_LH, DELAY(4.5ns,6.5ns,9ns),
+                 CLOCK & TRN_HL, DELAY(6ns,8ns,10.5ns),
+                 TRN_ZH, DELAY(3.5ns,5ns,8ns),
+                 TRN_ZL, DELAY(5.5ns,7ns,10ns),
+                 TRN_HZ, DELAY(1.5ns,3.5ns,7ns),
+                 TRN_LZ, DELAY(3ns,5ns,8.5ns),
+                 DELAY(7.5ns,9.5ns,11.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CP D0 D1 D2 D3 E0BAR E1BAR MR
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 125MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 3ns
+         MIN_LO = 6ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 3.5ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) =  D0 D1 D2 D3
+        SETUPTIME = 2.5ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) =  E0BAR E1BAR
+        SETUPTIME_HI = 4.5ns
+        SETUPTIME_LO = 7.5ns

*      SETUP_HOLD:
*      CLOCK LH = CP
*       DATA(1) =  MR
*        SETUPTIME_LO = 4.5ns       
*        SETUPTIME_LO = 4.5ns
.ENDS 74F173
*
*
* ----------------------------------------------------------- 74HC173 ------
*  4-Bit D-Type Registers with 3-State Outputs
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-247 to 2-252
*  jds    4/28/94
*
.SUBCKT 74HC173 CLK CLR 1D 2D 3D 4D 1Q 2Q 3Q 4Q M N G1BAR G2BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC173 LOGICEXP (13,6) DPWR DGND
+      M N 1D 2D 3D 4D CLR 1Q_O 2Q_O 3Q_O 4Q_O  G1BAR G2BAR
+      d1 d2 d3 d4 clrbar en_out
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clrbar = { ~(CLR) }
+      enable = { ~(G1BAR | G2BAR) }
+      en_out = { ~( M | N ) }
+      d1 = { (1Q_O & (~enable)) | (1D & enable) }
+      d2 = { (2Q_O & (~enable)) | (2D & enable) }
+      d3 = { (3Q_O & (~enable)) | (3D & enable) }
+      d4 = { (4Q_O & (~enable)) | (4D & enable) }

uf0 dFF(4) DPWR DGND
+ $D_HI clrbar CLK d1 d2 d3 d4
+ 1Q_O 2Q_O 3Q_O 4Q_O q1bar q2bar q3bar q4bar
+ D0_EFF IO_HC

Udly PINDLY (4,1,2) DPWR DGND
+    1Q_O 2Q_O 3Q_O 4Q_O
+    en_out
+    CLK clrbar
+    1Q 2Q 3Q 4Q
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     CLEAR = { CHANGED(clrbar,0) }
+
+    TRISTATE:
+      ENABLE HI = en_out
+       1Q 2Q 3Q 4Q = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,21ns,30ns),
+                 CLOCK & TRN_LH, DELAY(-1,21ns,30ns),
+                 CLOCK & TRN_HL, DELAY(-1,21ns,30ns),
+                 TRN_ZH, DELAY(-1,20ns,30ns),
+                 TRN_ZL, DELAY(-1,20ns,30ns),
+                 TRN_HZ, DELAY(-1,18ns,30ns),
+                 TRN_LZ, DELAY(-1,18ns,30ns),
+                 DELAY(-1,22ns,31ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK 1D 2D 3D 4D G1BAR G2BAR CLR
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+         MIN_LO = 16ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 16ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  1D 2D 3D 4D
+        SETUPTIME = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  G1BAR G2BAR
+        SETUPTIME = 20ns
*      SETUP_HOLD:
*        CLOCK LH = CLK
*        DATA(1) =  CLR
*        SETUPTIME_LO = 18ns

.ENDS 74HC173
*
*
* ----------------------------------------------------------- 74HCT173 ------
*  4-Bit D-Type Registers with 3-State Outputs
*
*  The High Speed CMOS Logic Family, Philips, 1994, Pages 369-373
*  jds    4/28/94
*
.SUBCKT 74HCT173 CP MR D0 D1 D2 D3 Q0 Q1 Q2 Q3 OE0BAR OE1BAR E0BAR E1BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT173 LOGICEXP (13,6) DPWR DGND
+      E0BAR E1BAR D0 D1 D2 D3 MR Q0_O Q1_O Q2_O Q3_O OE0BAR OE1BAR
+      da db dc dd mrbar en_out
+      D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      mrbar = { ~(MR) }
+      enable = { ~(E0BAR | E1BAR) }
+      en_out = { ~( OE0BAR | OE1BAR ) }
+      da = { (Q0_O & (~enable)) | (D0 & enable) }
+      db = { (Q1_O & (~enable)) | (D1 & enable) }
+      dc = { (Q2_O & (~enable)) | (D2 & enable) }
+      dd = { (Q3_O & (~enable)) | (D3 & enable) }

uf0 dFF(4) DPWR DGND
+ $D_HI mrbar CP da db dc dd
+ Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+ D0_EFF IO_HCT

Udly PINDLY (4,1,2) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O
+    en_out
+    CP mrbar
+    Q0 Q1 Q2 Q3
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CP,0) }
+     CLEAR = { CHANGED(mrbar,0) }
+
+    TRISTATE:
+      ENABLE HI = en_out
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,20ns,37ns),
+                 CLOCK, DELAY(-1,20ns,40ns),
+                 TRN_ZH, DELAY(-1,20ns,35ns),
+                 TRN_ZL, DELAY(-1,20ns,35ns),
+                 TRN_HZ, DELAY(-1,19ns,30ns),
+                 TRN_LZ, DELAY(-1,19ns,30ns),
+                 DELAY(-1,21,41ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CP D0 D1 D2 D3 E0BAR E1BAR MR
+          IO_HCT
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 80MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 7ns
+         MIN_LO = 7ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 6ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) =  D0 D1 D2 D3
+        SETUPTIME = 7ns
+        HOLDTIME = 3ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) =  E0BAR E1BAR
+        SETUPTIME = 13ns
+        HOLDTIME = 6ns
*      SETUP_HOLD:
*        CLOCK LH = CP
*        DATA(1) =  MR
*        SETUPTIME_LO = 2ns

.ENDS 74HCT173
*
*
* ----------------------------------------------------------- 74LS173A ------
*  4-Bit D-Type Registers with 3-State Outputs
*
*  The TTL Logic Data Book, 1988, TI Pages 2-575 to 2-579
*  jds    4/28/94
*
.SUBCKT 74LS173A CLK CLR 1D 2D 3D 4D 1Q 2Q 3Q 4Q M N G1BAR G2BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS173A LOGICEXP (13,6) DPWR DGND
+      M N 1D 2D 3D 4D CLR 1Q_O 2Q_O 3Q_O 4Q_O G1BAR G2BAR
+      d1 d2 d3 d4 clrbar  en_out
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clrbar = { ~(CLR) }
+      enable = { ~(G1BAR | G2BAR) }
+      en_out = { ~( M | N ) }
+      d1 = { (1Q_O  & (~enable)) | (1D & enable) }
+      d2 = { (2Q_O  & (~enable)) | (2D & enable) }
+      d3 = { (3Q_O  & (~enable)) | (3D & enable) }
+      d4 = { (4Q_O  & (~enable)) | (4D & enable) }

uf0 dFF(4) DPWR DGND
+ $D_HI clrbar CLK d1 d2 d3 d4
+ 1Q_O 2Q_O 3Q_O 4Q_O q1bar q2bar q3bar q4bar
+ D0_EFF IO_LS

Udly PINDLY (4,1,2) DPWR DGND
+    1Q_O 2Q_O 3Q_O 4Q_O
+    en_out
+    CLK clrbar
+    1Q 2Q 3Q 4Q
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     CLEAR = { CHANGED(clrbar,0) }
+
+    TRISTATE:
+      ENABLE HI = en_out
+       1Q 2Q 3Q 4Q = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,26ns,35ns),
+                 CLOCK & TRN_LH, DELAY(-1,17ns,25ns),
+                 CLOCK & TRN_HL, DELAY(-1,22ns,30ns),
+                 TRN_ZH, DELAY(-1,15ns,23ns),
+                 TRN_ZL, DELAY(-1,18ns,27ns),
+                 TRN_HZ, DELAY(-1,11ns,20ns),
+                 TRN_LZ, DELAY(-1,11ns,17ns),
+                 DELAY(-1,27ns,36ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK 1D 2D 3D 4D G1BAR G2BAR CLR
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 30MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 25ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) =  1D 2D 3D 4D
+        SETUPTIME = 17ns
+        HOLDTIME = 3ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) =  G1BAR G2BAR
+        SETUPTIME = 35ns
*      SETUP_HOLD:
*        CLOCK LH = CLK
*        DATA(1) =  CLR
*        SETUPTIME_LO = 10ns

.ENDS 74LS173A
*
*
* ----------------------------------------------------------- 74174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-581 to 2-586
*  jds    4/28/94
*
.SUBCKT 74174 CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFF174 IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

.model DFF174 ueff(TPPCQLHMN=-1  TPPCQLHTY=-1     TPPCQLHMX=-1
+                  TPPCQHLMN=-1   TPPCQHLTY=23ns   TPPCQHLMX=35ns
+                  TWPCLMN=-1     TWPCLTY=20ns     TWPCLMX=-1
+                  TPCLKQLHMN=-1  TPCLKQLHTY=20ns  TPCLKQLHMX=30ns
+                  TPCLKQHLMN=-1  TPCLKQHLTY=24ns  TPCLKQHLMX=35ns
+                  TWCLKLMN=-1    TWCLKLTY=20ns    TWCLKLMX=-1
+                  TWCLKHMN=-1    TWCLKHTY=20ns    TWCLKHMX=-1
+                  TSUDCLKMN=-1   TSUDCLKTY=20ns   TSUDCLKMX=-1
+                  TSUPCCLKHMN=-1 TSUPCCLKHTY=25ns   TSUPCCLKHMX=-1
+                  THDCLKMN=-1    THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74174
*
*
* ----------------------------------------------------------- 74AC174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    4/28/94                            Pages 4-105 to 4-110
*
.SUBCKT 74AC174 CP MRBAR D0 D1 D2 D3 D4 D5 Q0 Q1 Q2 Q3 Q4 Q5
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dFF(6) DPWR DGND
+ $D_HI MRBAR CP D0 D1 D2 D3 D4 D5
+ Q0 Q1 Q2 Q3 Q4 Q5 Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar
+ DFFAC174 IO_AC

.model DFFAC174 ueff(TPPCQLHMN=-1  TPPCQLHTY=-1     TPPCQLHMX=-1
+                  TPPCQHLMN=1.5ns   TPPCQHLTY=7ns   TPPCQHLMX=9ns
+                  TWPCLMN=-1     TWPCLTY=1ns       TWPCLMX=-1
+                  TPCLKQLHMN=1.5ns  TPCLKQLHTY=6ns  TPCLKQLHMX=8.5ns
+                  TPCLKQHLMN=1.5ns  TPCLKQHLTY=6ns  TPCLKQHLMX=8ns
+                  TWCLKLMN=-1    TWCLKLTY=1ns      TWCLKLMX=-1
+                  TWCLKHMN=-1    TWCLKHTY=1ns    TWCLKHMX=-1
+                  TSUDCLKMN=-1   TSUDCLKTY=2ns   TSUDCLKMX=-1
+                  TSUPCCLKHMN=-1 TSUPCCLKHTY=-1 TSUPCCLKHMX=-1
+                  THDCLKMN=-1    THDCLKTY=.5ns     THDCLKMX=-1)

.ENDS 74AC174
*
*
* ----------------------------------------------------------- 74ACT174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    4/29/94                            Pages 4-105 to 4-110
*
.SUBCKT 74ACT174 CP MRBAR D0 D1 D2 D3 D4 D5 Q0 Q1 Q2 Q3 Q4 Q5
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dFF(6) DPWR DGND
+ $D_HI MRBAR CP D0 D1 D2 D3 D4 D5
+ Q0 Q1 Q2 Q3 Q4 Q5 Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar
+ DFFACT174 IO_ACT

.model DFFACT174 ueff(TPPCQLHMN=-1  TPPCQLHTY=-1     TPPCQLHMX=-1
+                  TPPCQHLMN=1.5ns   TPPCQHLTY=6.5ns   TPPCQHLMX=9.5ns
+                  TWPCLMN=-1     TWPCLTY=1.5ns       TWPCLMX=-1
+                  TPCLKQLHMN=1.5ns  TPCLKQLHTY=7ns  TPCLKQLHMX=10.5ns
+                  TPCLKQHLMN=1.5ns  TPCLKQHLTY=7ns  TPCLKQHLMX=10.5ns
+                  TWCLKLMN=-1    TWCLKLTY=1.5ns      TWCLKLMX=-1
+                  TWCLKHMN=-1    TWCLKHTY=1.5ns    TWCLKHMX=-1
+                  TSUDCLKMN=-1   TSUDCLKTY=.5ns   TSUDCLKMX=-1
+                  TSUPCCLKHMN=-1 TSUPCCLKHTY=-1 TSUPCCLKHMX=-1
+                  THDCLKMN=-1    THDCLKTY=1ns     THDCLKMX=-1)

.ENDS 74ACT174
*
*
* ----------------------------------------------------------- 74ALS174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  ALS/AS Logic Data Book, 1986, TI Pages 2-181 to 2-186
*  jds    4/29/94
*
.SUBCKT 74ALS174 CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFFALS174 IO_ALS00

.model DFFALS174 ueff(TPPCQLHMN=-1   TPPCQLHTY=-1    TPPCQLHMX=-1
+                     TPPCQHLMN=8ns   TPPCQHLTY=-1    TPPCQHLMX=23ns
+                     TWPCLMN=-1      TWPCLTY=10ns    TWPCLMX=-1
+                     TPCLKQLHMN=3ns  TPCLKQLHTY=-1   TPCLKQLHMX=15ns
+                     TPCLKQHLMN=5ns  TPCLKQHLTY=-1   TPCLKQHLMX=17ns
+                     TWCLKLMN=-1     TWCLKLTY=10ns   TWCLKLMX=-1
+                     TWCLKHMN=-1     TWCLKHTY=10ns   TWCLKHMX=-1
+                     TSUDCLKMN=-1    TSUDCLKTY=10ns  TSUDCLKMX=-1
+                     TSUPCCLKHMN=-1  TSUPCCLKHTY=-1  TSUPCCLKHMX=-1
+                     THDCLKMN=-1     THDCLKTY=-1     THDCLKMX=-1)

.ENDS 74ALS174
*
*
* ----------------------------------------------------------- 74AS174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  ALS/AS Logic Data Book, 1986, TI Pages 2-181 to 2-186
*  jds    4/29/94
*
.SUBCKT 74AS174 CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFFAS174 IO_AS00

.model DFFAS174 ueff(TPPCQLHMN=-1   TPPCQLHTY=-1    TPPCQLHMX=-1
+                    TPPCQHLMN=5ns   TPPCQHLTY=-1    TPPCQHLMX=14ns
+                    TWPCLMN=-1      TWPCLTY=5ns    TWPCLMX=-1
+                    TPCLKQLHMN=3.5ns  TPCLKQLHTY=-1   TPCLKQLHMX=8ns
+                    TPCLKQHLMN=4.5ns  TPCLKQHLTY=-1   TPCLKQHLMX=10ns
+                    TWCLKLMN=-1     TWCLKLTY=6ns   TWCLKLMX=-1
+                    TWCLKHMN=-1     TWCLKHTY=4ns   TWCLKHMX=-1
+                    TSUDCLKMN=-1    TSUDCLKTY=4ns  TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1  TSUPCCLKHTY=-1  TSUPCCLKHMX=-1
+                    THDCLKMN=-1     THDCLKTY=1ns     THDCLKMX=-1)

.ENDS 74AS174

* -----------------------------------------------------------74F174------

* Hex D Flip-Flop with Master Reset
* National Advanced Bipoloar Logic Databook, 1995, pages 7-135 to 7-138
* jat 7/9/96

.SUBCKT 74F174 MRBAR CP D0 D1 D2 D3 D4 D5 Q0 Q1 Q2 Q3 Q4 Q5
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(6) DPWR DGND
+ $D_HI MRBAR CP
+ D0 D1 D2 D3 D4 D5
+ Q0O Q1O Q2O Q3O Q4O Q5O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(6,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O
+ MRBAR CP
+ Q0 Q1 Q2 Q3 Q4 Q5
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CP,0)}
+   RESET = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+     Q0 Q1 Q2 Q3 Q4 Q5 = {
+      CASE(
+        RESET & TRN_HL, DELAY(5NS,10NS,14NS),
+        EDGE & TRN_LH, DELAY(3.5NS,5.5NS,8NS),
+        EDGE & TRN_HL, DELAY(4NS,7NS,10NS),
+        DELAY(6NS,11NS,15NS))}

U3 CONSTRAINT(8) DPWR DGND
+ MRBAR CP D0 D1 D2 D3 D4 D5
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = CP
+    MAXFREQ = 80MEG
+ WIDTH:
+    NODE = CP
+    MIN_LO = 6NS
+    MIN_HI = 4NS
+ WIDTH:
+    NODE = MRBAR
+    MIN_LO = 5NS
+ SETUP_HOLD:
+    CLOCK LH = CP
+    DATA(6) = D0 D1 D2 D3 D4 D5
+    SETUPTIME_HI = 4.8NS
+    SETUPTIME_LO = 4NS
+ SETUP_HOLD:
+    CLOCK LH = CP
+    DATA(1) = MRBAR
+    SETUPTIME_HI = 5NS

.ENDS 74F174

* ----------------------------------------------------------- 74F174A ------
*  Hex D-Type Flip-Flops with Clear
*
*  F Logic Data Book, 1994, TI Pages 2-137 to 2-140
*  jds    4/29/94
*
.SUBCKT 74F174A CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFFF174A IO_F

.model DFFF174A ueff(TPPCQLHMN=-1     TPPCQLHTY=-1      TPPCQLHMX=-1
+                    TPPCQHLMN=4.2ns   TPPCQHLTY=6.3ns   TPPCQHLMX=14ns
+                    TWPCLMN=-1        TWPCLTY=5ns       TWPCLMX=-1
+                    TPCLKQLHMN=2.7ns  TPCLKQLHTY=4.5ns  TPCLKQLHMX=8ns
+                    TPCLKQHLMN=3.4ns  TPCLKQHLTY=4.2ns  TPCLKQHLMX=10ns
+                    TWCLKLMN=-1       TWCLKLTY=6ns      TWCLKLMX=-1
+                    TWCLKHMN=-1       TWCLKHTY=4ns      TWCLKHMX=-1
+                    TSUDCLKMN=-1      TSUDCLKTY=4ns     TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1    TSUPCCLKHTY=-1    TSUPCCLKHMX=-1
+                    THDCLKMN=-1       THDCLKTY=.5ns     THDCLKMX=-1)

.ENDS 74F174A
*
*
* ----------------------------------------------------------- 74HC174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  High Speed CMOS Logic Data Book, 1989, TI Pages 2-253 to 2-257
*  jds    4/29/94
*
.SUBCKT 74HC174 CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFFHC174 IO_HC

.model DFFHC174 ueff(TPPCQLHMN=-1     TPPCQLHTY=-1     TPPCQLHMX=-1
+                    TPPCQHLMN=-1      TPPCQHLTY=17ns   TPPCQHLMX=32ns
+                    TWPCLMN=-1        TWPCLTY=16ns     TWPCLMX=-1
+                    TPCLKQLHMN=-1     TPCLKQLHTY=17ns  TPCLKQLHMX=32ns
+                    TPCLKQHLMN=-1     TPCLKQHLTY=17ns  TPCLKQHLMX=32ns
+                    TWCLKLMN=-1       TWCLKLTY=16ns    TWCLKLMX=-1
+                    TWCLKHMN=-1       TWCLKHTY=16ns    TWCLKHMX=-1
+                    TSUDCLKMN=-1      TSUDCLKTY=20ns   TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1    TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                    THDCLKMN=-1       THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74HC174

* -----------------------------------------------------------74HC174A------

* Hex D Flip-Flop with Common Clock and Reset
* Motorola High-Speed CMOS Data, 1993, pages 5-198 to 5-201
* jat 9/10/96

.SUBCKT 74HC174A RESET CLOCK D0 D1 D2 D3 D4 D5 Q0 Q1 Q2 Q3 Q4 Q5
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(6) DPWR DGND
+ $D_HI RESET CLOCK
+ D0 D1 D2 D3 D4 D5
+ Q0O Q1O Q2O Q3O Q4O Q5O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(6,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O
+ RESET CLOCK
+ Q0 Q1 Q2 Q3 Q4 Q5
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CLOCK,0)}
+   CLEAR = {CHANGED_HL(RESET,0)}
+ PINDLY:
+     Q0 Q1 Q2 Q3 Q4 Q5 = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,-1,21NS),
+        EDGE & TRN_LH, DELAY(-1,-1,22NS),
+        EDGE & TRN_HL, DELAY(-1,-1,22NS),
+        DELAY(-1,-1,23NS))}

U3 CONSTRAINT(8) DPWR DGND
+ RESET CLOCK D0 D1 D2 D3 D4 D5
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = CLOCK
+    MAXFREQ = 30MEG
+ WIDTH:
+    NODE = CLOCK
+    MIN_LO = 15NS
+    MIN_HI = 15NS
+ WIDTH:
+    NODE = RESET
+    MIN_LO = 15NS
+ SETUP_HOLD:
+    CLOCK LH = CLOCK
+    DATA(6) = D0 D1 D2 D3 D4 D5
+    SETUPTIME = 10NS
+    HOLDTIME = 5NS
+ SETUP_HOLD:
+    CLOCK LH = CLOCK
+    DATA(1) = RESET
+    SETUPTIME_HI = 5NS

.ENDS 74HC174A

* ----------------------------------------------------------- 74HCT174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  High Speed CMOS Logic Data Book, 1994, Philips
*  jds    4/29/94                         Pages 375-379
*
.SUBCKT 74HCT174 CP MRBAR D0 D1 D2 D3 D4 D5 Q0 Q1 Q2 Q3 Q4 Q5
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dFF(6) DPWR DGND
+ $D_HI MRBAR CP D0 D1 D2 D3 D4 D5
+ Q0 Q1 Q2 Q3 Q4 Q5 Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar
+ DFFHCT174 IO_HCT

.model DFFHCT174 ueff(TPPCQLHMN=-1  TPPCQLHTY=-1     TPPCQLHMX=-1
+                     TPPCQHLMN=-1   TPPCQHLTY=20ns   TPPCQHLMX=35ns
+                     TWPCLMN=20ns   TWPCLTY=7ns      TWPCLMX=-1
+                     TPCLKQLHMN=-1  TPCLKQLHTY=21ns  TPCLKQLHMX=35ns
+                     TPCLKQHLMN=-1  TPCLKQHLTY=21ns  TPCLKQHLMX=35ns
+                     TWCLKLMN=16ns  TWCLKLTY=7ns     TWCLKLMX=-1
+                     TWCLKHMN=16ns  TWCLKHTY=7ns     TWCLKHMX=-1
+                     TSUDCLKMN=16ns TSUDCLKTY=4ns    TSUDCLKMX=-1
+                     TSUPCCLKHMN=-1 TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                     THDCLKMN=5ns   THDCLKTY=3ns     THDCLKMX=-1)

.ENDS 74HCT174

* -----------------------------------------------------------74HCT174A------

* Hex D Flip-Flop with Common Clock and Reset
* Motorola High-Speed CMOS Data, 1993, pages 5-202 to 5-205
* jat 9/10/96

.SUBCKT 74HCT174A RESET CLOCK D0 D1 D2 D3 D4 D5 Q0 Q1 Q2 Q3 Q4 Q5
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 DFF(6) DPWR DGND
+ $D_HI RESET CLOCK
+ D0 D1 D2 D3 D4 D5
+ Q0O Q1O Q2O Q3O Q4O Q5O
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 PINDLY(6,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O Q4O Q5O
+ RESET CLOCK
+ Q0 Q1 Q2 Q3 Q4 Q5
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CLOCK,0)}
+   CLEAR = {CHANGED_HL(RESET,0)}
+ PINDLY:
+     Q0 Q1 Q2 Q3 Q4 Q5 = {
+      CASE(
+        CLEAR & TRN_HL, DELAY(-1,-1,23NS),
+        EDGE & TRN_LH, DELAY(-1,-1,24NS),
+        EDGE & TRN_HL, DELAY(-1,-1,24NS),
+        DELAY(-1,-1,25NS))}

U3 CONSTRAINT(8) DPWR DGND
+ RESET CLOCK D0 D1 D2 D3 D4 D5
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = CLOCK
+    MAXFREQ = 30MEG
+ WIDTH:
+    NODE = CLOCK
+    MIN_LO = 15NS
+    MIN_HI = 15NS
+ WIDTH:
+    NODE = RESET
+    MIN_LO = 15NS
+ SETUP_HOLD:
+    CLOCK LH = CLOCK
+    DATA(6) = D0 D1 D2 D3 D4 D5
+    SETUPTIME = 10NS
+    HOLDTIME = 5NS
+ SETUP_HOLD:
+    CLOCK LH = CLOCK
+    DATA(1) = RESET
+    SETUPTIME_HI = 5NS

.ENDS 74HCT174A

* ----------------------------------------------------------- 74LS174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-581 to 2-586
*  jds    4/29/94
*
.SUBCKT 74LS174 CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFFLS174 IO_LS

.model DFFLS174 ueff(TPPCQLHMN=-1  TPPCQLHTY=-1     TPPCQLHMX=-1
+                    TPPCQHLMN=-1   TPPCQHLTY=23ns   TPPCQHLMX=35ns
+                    TWPCLMN=-1     TWPCLTY=20ns     TWPCLMX=-1
+                    TPCLKQLHMN=-1  TPCLKQLHTY=20ns  TPCLKQLHMX=30ns
+                    TPCLKQHLMN=-1  TPCLKQHLTY=21ns  TPCLKQHLMX=30ns
+                    TWCLKLMN=-1    TWCLKLTY=20ns    TWCLKLMX=-1
+                    TWCLKHMN=-1    TWCLKHTY=20ns    TWCLKHMX=-1
+                    TSUDCLKMN=-1   TSUDCLKTY=20ns   TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1 TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                    THDCLKMN=-1    THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74LS174
*
*
* ----------------------------------------------------------- 74S174 ------
*  Hex D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-581 to 2-586
*  jds    4/29/94
*
.SUBCKT 74S174 CLK CLRBAR 1D 2D 3D 4D 5D 6D 1Q 2Q 3Q 4Q 5Q 6Q
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(6) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D 5D 6D
+ 1Q 2Q 3Q 4Q 5Q 6Q 1Qbar 2Qbar 3Qbar 4Qbar 5Qbar 6Qbar
+ DFFS174 IO_S

.model DFFS174 ueff(TPPCQLHMN=-1  TPPCQLHTY=-1      TPPCQLHMX=-1
+                   TPPCQHLMN=-1   TPPCQHLTY=13ns    TPPCQHLMX=22ns
+                   TWPCLMN=-1     TWPCLTY=10ns      TWPCLMX=-1
+                   TPCLKQLHMN=-1  TPCLKQLHTY=8ns    TPCLKQLHMX=12ns
+                   TPCLKQHLMN=-1  TPCLKQHLTY=11.5ns TPCLKQHLMX=17ns
+                   TWCLKLMN=-1    TWCLKLTY=7ns      TWCLKLMX=-1
+                   TWCLKHMN=-1    TWCLKHTY=7ns      TWCLKHMX=-1
+                   TSUDCLKMN=-1   TSUDCLKTY=5ns     TSUDCLKMX=-1
+                   TSUPCCLKHMN=-1 TSUPCCLKHTY=-1    TSUPCCLKHMX=-1
+                   THDCLKMN=-1    THDCLKTY=3ns      THDCLKMX=-1)

.ENDS 74S174
*
*
* ----------------------------------------------------------- 74175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-581 to 2-586
*  jds    4/29/94
*
.SUBCKT 74175 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dFF(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFF175 IO_STD

.model DFF175 ueff(TPPCQLHMN=-1  TPPCQLHTY=16ns   TPPCQLHMX=25ns
+                  TPPCQHLMN=-1   TPPCQHLTY=23ns   TPPCQHLMX=35ns
+                  TWPCLMN=-1     TWPCLTY=20ns     TWPCLMX=-1
+                  TPCLKQLHMN=-1  TPCLKQLHTY=20ns  TPCLKQLHMX=30ns
+                  TPCLKQHLMN=-1  TPCLKQHLTY=24ns  TPCLKQHLMX=35ns
+                  TWCLKLMN=-1    TWCLKLTY=20ns    TWCLKLMX=-1
+                  TWCLKHMN=-1    TWCLKHTY=20ns    TWCLKHMX=-1
+                  TSUDCLKMN=-1   TSUDCLKTY=20ns   TSUDCLKMX=-1
+                  TSUPCCLKHMN=-1 TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                  THDCLKMN=-1    THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74175
*
*
* ----------------------------------------------------------- 74AC175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    4/28/94                            Pages 4-111 to 4-116
*
.SUBCKT 74AC175 CP MRBAR D0 D1 D2 D3 Q0 Q1 Q2 Q3 Q0BAR Q1BAR Q2BAR Q3BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dff(4) DPWR DGND
+ $D_HI MRBAR CP D0 D1 D2 D3
+ Q0 Q1 Q2 Q3 Q0BAR Q1BAR Q2BAR Q3BAR
+ DFFAC175 IO_AC

.model DFFAC175 ueff(TPPCQLHMN=2ns   TPPCQLHTY=6ns   TPPCQLHMX=8.5ns
+                    TPPCQHLMN=2ns    TPPCQHLTY=5.5ns TPPCQHLMX=9ns
+                    TWPCLMN=-1       TWPCLTY=4ns     TWPCLMX=-1
+                    TPCLKQLHMN=1.5ns TPCLKQLHTY=6ns  TPCLKQLHMX=9.5ns
+                    TPCLKQHLMN=1.5ns TPCLKQHLTY=7ns  TPCLKQHLMX=9ns
+                    TWCLKLMN=-1      TWCLKLTY=4ns    TWCLKLMX=-1
+                    TWCLKHMN=-1      TWCLKHTY=4ns    TWCLKHMX=-1
+                    TSUDCLKMN=-1     TSUDCLKTY=1ns   TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1   TSUPCCLKHTY=-1  TSUPCCLKHMX=-1
+                    THDCLKMN=-1      THDCLKTY=1ns    THDCLKMX=-1)

.ENDS 74AC175
*
*
* ----------------------------------------------------------- 74ACT175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    4/29/94                            Pages 4-111 to 4-116
*
.SUBCKT 74ACT175 CP MRBAR D0 D1 D2 D3 Q0 Q1 Q2 Q3 Q0BAR Q1BAR Q2BAR Q3BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dff(4) DPWR DGND
+ $D_HI MRBAR CP D0 D1 D2 D3
+ Q0 Q1 Q2 Q3 Q0BAR Q1BAR Q2BAR Q3BAR
+ DFFACT175 IO_ACT

.model DFFACT175 ueff(TPPCQLHMN=2ns  TPPCQLHTY=6ns     TPPCQLHMX=9.5ns
+                  TPPCQHLMN=2ns   TPPCQHLTY=5.5ns   TPPCQHLMX=9.5ns
+                  TWPCLMN=-1     TWPCLTY=4ns       TWPCLMX=-1
+                  TPCLKQLHMN=2ns  TPCLKQLHTY=6ns  TPCLKQLHMX=10ns
+                  TPCLKQHLMN=2ns  TPCLKQHLTY=7ns  TPCLKQHLMX=11ns
+                  TWCLKLMN=-1    TWCLKLTY=4ns      TWCLKLMX=-1
+                  TWCLKHMN=-1    TWCLKHTY=4ns    TWCLKHMX=-1
+                  TSUDCLKMN=-1   TSUDCLKTY=3ns   TSUDCLKMX=-1
+                  TSUPCCLKHMN=-1 TSUPCCLKHTY=-1 TSUPCCLKHMX=-1
+                  THDCLKMN=-1    THDCLKTY=-1     THDCLKMX=-1)

.ENDS 74ACT175
*
*
* ----------------------------------------------------------- 74ALS175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  ALS/AS Logic Data Book, 1986, TI Pages 2-181 to 2-186
*  jds    4/29/94
*
.SUBCKT 74ALS175 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dff(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFFALS175 IO_ALS00

.model DFFALS175 ueff(TPPCQLHMN=5ns  TPPCQLHTY=-1    TPPCQLHMX=18ns
+                     TPPCQHLMN=8ns   TPPCQHLTY=-1    TPPCQHLMX=23ns
+                     TWPCLMN=-1      TWPCLTY=10ns    TWPCLMX=-1
+                     TPCLKQLHMN=3ns  TPCLKQLHTY=-1   TPCLKQLHMX=15ns
+                     TPCLKQHLMN=5ns  TPCLKQHLTY=-1   TPCLKQHLMX=17ns
+                     TWCLKLMN=-1     TWCLKLTY=10ns   TWCLKLMX=-1
+                     TWCLKHMN=-1     TWCLKHTY=10ns   TWCLKHMX=-1
+                     TSUDCLKMN=-1    TSUDCLKTY=10ns  TSUDCLKMX=-1
+                     TSUPCCLKHMN=-1  TSUPCCLKHTY=-1  TSUPCCLKHMX=-1
+                     THDCLKMN=-1     THDCLKTY=-1     THDCLKMX=-1)

.ENDS 74ALS175
*
*
* ----------------------------------------------------------- 74AS175A ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  ALS/AS Logic Data Book, 1986, TI Pages 2-181 to 2-186
*  jds    4/29/94
*
.SUBCKT 74AS175A CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dff(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFFAS175A IO_AS00

.model DFFAS175A ueff(TPPCQLHMN=4ns  TPPCQLHTY=-1    TPPCQLHMX=9ns
+                     TPPCQHLMN=4.5ns TPPCQHLTY=-1    TPPCQHLMX=13ns
+                     TWPCLMN=-1      TWPCLTY=5ns     TWPCLMX=-1
+                     TPCLKQLHMN=4ns  TPCLKQLHTY=-1   TPCLKQLHMX=7.5ns
+                     TPCLKQHLMN=4ns  TPCLKQHLTY=-1   TPCLKQHLMX=10ns
+                     TWCLKLMN=-1     TWCLKLTY=5ns    TWCLKLMX=-1
+                     TWCLKHMN=-1     TWCLKHTY=4ns    TWCLKHMX=-1
+                     TSUDCLKMN=-1    TSUDCLKTY=3ns   TSUDCLKMX=-1
+                     TSUPCCLKHMN=-1  TSUPCCLKHTY=-1  TSUPCCLKHMX=-1
+                     THDCLKMN=-1     THDCLKTY=1ns    THDCLKMX=-1)

.ENDS 74AS175A
*
*
* ----------------------------------------------------------- 74F175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  F Logic Data Book, 1994, TI Pages 2-141 to 2-144
*  jds    4/29/94
*
.SUBCKT 74F175 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dff(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFFF175 IO_F

.model DFFF175 ueff(TPPCQLHMN=3.2ns   TPPCQLHTY=6.1ns   TPPCQLHMX=8.5ns
+                    TPPCQHLMN=3.7ns   TPPCQHLTY=8.6ns   TPPCQHLMX=11.5ns
+                    TWPCLMN=-1        TWPCLTY=5ns       TWPCLMX=-1
+                    TPCLKQLHMN=3.2ns  TPCLKQLHTY=4.6ns  TPCLKQLHMX=6.5ns
+                    TPCLKQHLMN=3.2ns  TPCLKQHLTY=6.1ns  TPCLKQHLMX=8.5ns
+                    TWCLKLMN=-1       TWCLKLTY=5ns      TWCLKLMX=-1
+                    TWCLKHMN=-1       TWCLKHTY=4ns      TWCLKHMX=-1
+                    TSUDCLKMN=-1      TSUDCLKTY=3ns     TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1    TSUPCCLKHTY=-1    TSUPCCLKHMX=-1
+                    THDCLKMN=-1       THDCLKTY=1ns      THDCLKMX=-1)

.ENDS 74F175
*
*
* ----------------------------------------------------------- 74HC175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  High Speed CMOS Logic Data Book, 1989, TI Pages 2-253 to 2-257
*  jds    4/29/94
*
.SUBCKT 74HC175 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dff(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFFHC175 IO_HC

.model DFFHC175 ueff(TPPCQLHMN=-1     TPPCQLHTY=15ns   TPPCQLHMX=30ns
+                    TPPCQHLMN=-1      TPPCQHLTY=15ns   TPPCQHLMX=30ns
+                    TWPCLMN=-1        TWPCLTY=16ns     TWPCLMX=-1
+                    TPCLKQLHMN=-1     TPCLKQLHTY=16ns  TPCLKQLHMX=30ns
+                    TPCLKQHLMN=-1     TPCLKQHLTY=16ns  TPCLKQHLMX=30ns
+                    TWCLKLMN=-1       TWCLKLTY=16ns    TWCLKLMX=-1
+                    TWCLKHMN=-1       TWCLKHTY=16ns    TWCLKHMX=-1
+                    TSUDCLKMN=-1      TSUDCLKTY=20ns   TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1    TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                    THDCLKMN=-1       THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74HC175
*
*
* ----------------------------------------------------------- 74HCT175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  High Speed CMOS Logic Data Book, 1994, Philips
*  jds    4/29/94                         Pages 381-385
*
.SUBCKT 74HCT175 CP MRBAR D0 D1 D2 D3 Q0 Q1 Q2 Q3 Q0BAR Q1BAR Q2BAR Q3BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

uf0 dff(4) DPWR DGND
+ $D_HI MRBAR CP D0 D1 D2 D3
+ Q0 Q1 Q2 Q3 Q0BAR Q1BAR Q2BAR Q3BAR
+ DFFHCT175 IO_HCT

.model DFFHCT175 ueff(TPPCQLHMN=-1  TPPCQLHTY=20ns   TPPCQLHMX=35ns
+                     TPPCQHLMN=-1   TPPCQHLTY=20ns   TPPCQHLMX=35ns
+                     TWPCLMN=16ns   TWPCLTY=7ns      TWPCLMX=-1
+                     TPCLKQLHMN=-1  TPCLKQLHTY=21ns  TPCLKQLHMX=35ns
+                     TPCLKQHLMN=-1  TPCLKQHLTY=21ns  TPCLKQHLMX=35ns
+                     TWCLKLMN=16ns  TWCLKLTY=8ns     TWCLKLMX=-1
+                     TWCLKHMN=16ns  TWCLKHTY=8ns     TWCLKHMX=-1
+                     TSUDCLKMN=16ns TSUDCLKTY=1ns    TSUDCLKMX=-1
+                     TSUPCCLKHMN=-1 TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                     THDCLKMN=5ns   THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74HCT175
*
*
* ----------------------------------------------------------- 74LS175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-581 to 2-586
*  jds    4/29/94
*
.SUBCKT 74LS175 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dff(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFFLS175 IO_LS

.model DFFLS175 ueff(TPPCQLHMN=-1  TPPCQLHTY=20ns   TPPCQLHMX=30ns
+                    TPPCQHLMN=-1   TPPCQHLTY=20ns   TPPCQHLMX=30ns
+                    TWPCLMN=-1     TWPCLTY=20ns     TWPCLMX=-1
+                    TPCLKQLHMN=-1  TPCLKQLHTY=13ns  TPCLKQLHMX=25ns
+                    TPCLKQHLMN=-1  TPCLKQHLTY=16ns  TPCLKQHLMX=25ns
+                    TWCLKLMN=-1    TWCLKLTY=20ns    TWCLKLMX=-1
+                    TWCLKHMN=-1    TWCLKHTY=20ns    TWCLKHMX=-1
+                    TSUDCLKMN=-1   TSUDCLKTY=20ns   TSUDCLKMX=-1
+                    TSUPCCLKHMN=-1 TSUPCCLKHTY=-1   TSUPCCLKHMX=-1
+                    THDCLKMN=-1    THDCLKTY=-1      THDCLKMX=-1)

.ENDS 74LS175
*

*
* ----------------------------------------------------------- 74S175 ------
*  Quadruple D-Type Flip-Flops with Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-581 to 2-586
*  jds    4/29/94
*
.SUBCKT 74S175 CLK CLRBAR 1D 2D 3D 4D 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0


uf0 dff(4) DPWR DGND
+ $D_HI CLRBAR CLK 1D 2D 3D 4D
+ 1Q 2Q 3Q 4Q 1QBAR 2QBAR 3QBAR 4QBAR
+ DFFS175 IO_S

.model DFFS175 ueff(TPPCQLHMN=-1  TPPCQLHTY=10ns    TPPCQLHMX=15ns
+                   TPPCQHLMN=-1   TPPCQHLTY=13ns    TPPCQHLMX=22ns
+                   TWPCLMN=-1     TWPCLTY=10ns      TWPCLMX=-1
+                   TPCLKQLHMN=-1  TPCLKQLHTY=8ns    TPCLKQLHMX=12ns
+                   TPCLKQHLMN=-1  TPCLKQHLTY=11.5ns TPCLKQHLMX=17ns
+                   TWCLKLMN=-1    TWCLKLTY=7ns      TWCLKLMX=-1
+                   TWCLKHMN=-1    TWCLKHTY=7ns      TWCLKHMX=-1
+                   TSUDCLKMN=-1   TSUDCLKTY=5ns     TSUDCLKMX=-1
+                   TSUPCCLKHMN=-1 TSUPCCLKHTY=-1    TSUPCCLKHMX=-1
+                   THDCLKMN=-1    THDCLKTY=3ns      THDCLKMX=-1)

.ENDS 74S175
*
*
* ----------------------------------------------------------- 74176 ------
*  35MHz Presettable Decade and Binary Counters/Latches
*
*  The TTL Logic Data Book, 1988, TI Pages 2-587 to 2-592
*  jds    5/2/94
*
.SUBCKT 74176  LOADBAR CLRBAR CLK1 CLK2 A B C D QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74176 LOGICEXP (8,9) DPWR DGND
+      A B C D LOADBAR CLRBAR QB_O QC_O
+      s0 s1 s2 s3 r0 r1 r2 r3 j3
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0 = {~(A & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r0 = {~(s0 & (~(LOADBAR & CLRBAR)))}
+      s1 = {~(B & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r1 = {~(s1 & (~(LOADBAR & CLRBAR)))}
+      s2 = {~(C & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r2 = {~(s2 & (~(LOADBAR & CLRBAR)))}
+      s3 = {~(D & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r3 = {~(s3 & (~(LOADBAR & CLRBAR)))}
+      j3 = {(QB_O & QC_O)}

uf0  JKff(1)  DPWR DGND
+    s0 r0 CLK1
+    $D_HI $D_HI QA_O qabar
+    D0_EFF IO_STD

uf1  JKff(1)  DPWR DGND
+    s1 r1 CLK2
+    qdbar qdbar QB_O qbbar
+    D0_EFF IO_STD

uf2  JKff(1)  DPWR DGND
+    s2 r2 QB_O
+    $D_HI $D_HI QC_O qcbar
+    D0_EFF IO_STD

uf3  JKff(1)  DPWR DGND
+    s3 r3 CLK2
+    j3 QD_O QD_O qdbar
+    D0_EFF IO_STD


Udly PINDLY (4,0,8) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLK1 CLK2 LOADBAR CLRBAR A B C D
+    QA QB QC QD
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+     LOAD = {CHANGED(LOADBAR,0)}
+     CLOCK1 = {CHANGED(CLK1,0)}
+     CLOCK2 = {CHANGED(CLK2,0)}
+     CLEAR = { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+     QA = {
+            CASE(
+                 CLOCK1 & TRN_LH, DELAY(-1,8ns,13ns),
+                 CLOCK1 & TRN_HL, DELAY(-1,11ns,17ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,32ns,49ns)
+                )
+            }
+      QB = {
+            CASE(
+                 CLOCK2 & TRN_LH, DELAY(-1,11ns,17ns),
+                 CLOCK2 & TRN_HL, DELAY(-1,17ns,26ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,32ns,49ns)
+                )
+            }
+      QC = {
+            CASE(
+                 CLOCK2 & TRN_LH, DELAY(-1,27ns,41ns),
+                 CLOCK2 & TRN_HL, DELAY(-1,34ns,51ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      QD = {
+            CASE(
+                 CLOCK2 & TRN_LH, DELAY(-1,13ns,20ns),
+                 CLOCK2 & TRN_HL, DELAY(-1,17ns,26ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,32ns,49ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK1 CLK2 A B C D CLRBAR LOADBAR
+          IO_STD
+
+      FREQ:
+         NODE = CLK1
+         MAXFREQ = 35MEG
+      FREQ:
+         NODE = CLK2
+         MAXFREQ = 17.5MEG
+      WIDTH:
+         NODE = CLK1
+         MIN_HI = 14ns
+      WIDTH:
+         NODE = CLK2
+         MIN_HI = 28ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        HOLDTIME = 25ns
+      SETUP_HOLD:
+        CLOCK HL = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME_HI = 15ns
+        SETUPTIME_LO = 20ns

.ENDS 74176
*
*
* ----------------------------------------------------------- 74177 ------
*  35MHz Presettable Decade and Binary Counters/Latches
*
*  The TTL Logic Data Book, 1988, TI Pages 2-587 to 2-592
*  jds    5/2/94
*
.SUBCKT 74177  LOADBAR CLRBAR CLK1 CLK2 A B C D QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74177 LOGICEXP (6,8) DPWR DGND
+      A B C D LOADBAR CLRBAR
+      s0 s1 s2 s3 r0 r1 r2 r3
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0 = {~(A & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r0 = {~(s0 & (~(LOADBAR & CLRBAR)))}
+      s1 = {~(B & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r1 = {~(s1 & (~(LOADBAR & CLRBAR)))}
+      s2 = {~(C & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r2 = {~(s2 & (~(LOADBAR & CLRBAR)))}
+      s3 = {~(D & CLRBAR & (~(LOADBAR & CLRBAR)))}
+      r3 = {~(s3 & (~(LOADBAR & CLRBAR)))}

uf0  JKff(1)  DPWR DGND
+    s0 r0 CLK1
+    $D_HI $D_HI QA_O qabar
+    D0_EFF IO_STD

uf1  JKff(1)  DPWR DGND
+    s1 r1 CLK2
+    $D_HI $D_HI QB_O qbbar
+    D0_EFF IO_STD

uf2  JKff(1)  DPWR DGND
+    s2 r2 QB_O
+    $D_HI $D_HI QC_O qcbar
+    D0_EFF IO_STD

uf3  JKff(1)  DPWR DGND
+    s3 r3 QC_O
+    $D_HI $D_HI QD_O qdbar
+    D0_EFF IO_STD

Udly PINDLY (4,0,8) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLK1 CLK2 LOADBAR CLRBAR A B C D
+    QA QB QC QD
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+     LOAD = {CHANGED(LOADBAR,0)}
+     CLOCK1 = {CHANGED(CLK1,0)}
+     CLOCK2 = {CHANGED(CLK2,0)}
+     CLEAR = { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+     QA = {
+            CASE(
+                 CLOCK1 & TRN_LH, DELAY(-1,8ns,13ns),
+                 CLOCK1 & TRN_HL, DELAY(-1,11ns,17ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,32ns,49ns)
+                )
+            }
+      QB = {
+            CASE(
+                 CLOCK2 & TRN_LH, DELAY(-1,11ns,17ns),
+                 CLOCK2 & TRN_HL, DELAY(-1,17ns,26ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,32ns,49ns)
+                )
+            }
+      QC = {
+            CASE(
+                 CLOCK2 & TRN_LH, DELAY(-1,27ns,41ns),
+                 CLOCK2 & TRN_HL, DELAY(-1,34ns,51ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      QD = {
+            CASE(
+                 CLOCK2 & TRN_LH, DELAY(-1,44ns,66ns),
+                 CLOCK2 & TRN_HL, DELAY(-1,50ns,75ns),
+                 DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 DATA & TRN_HL, DELAY(-1,31ns,46ns),
+                 LOAD & TRN_LH, DELAY(-1,29ns,43ns),
+                 (CLEAR | LOAD) & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,51ns,76ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK1 CLK2 A B C D CLRBAR LOADBAR
+          IO_STD
+
+      FREQ:
+         NODE = CLK1
+         MAXFREQ = 35MEG
+      FREQ:
+         NODE = CLK2
+         MAXFREQ = 17.5MEG
+      WIDTH:
+         NODE = CLK1
+         MIN_HI = 14ns
+      WIDTH:
+         NODE = CLK2
+         MIN_HI = 28ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        HOLDTIME = 25ns
+      SETUP_HOLD:
+        CLOCK HL = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME_HI = 15ns
+        SETUPTIME_LO = 20ns

.ENDS 74177
*
*
* ----------------------------------------------------------- 74178 ------
*  4-Bit Parallel Access Shift Registers
*
*  The TTL Logic Data Book, 1988, TI Pages 2-593 to 2-596
*  jds    5/2/94
*
.SUBCKT 74178  SHIFT LOAD CLK SER A B C D QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74178 LOGICEXP (12,8) DPWR DGND
+      A B C D LOAD SER QA_O QB_O QC_O QD_O SHIFT CLK
+      j0 j1 j2 j3 k0 k1 k2 k3
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      k0 = { ~((SER & SHIFT) | (A & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QA_O) )}
+      j0 = { (~k0) }
+      k1 = { ~((QA_O & SHIFT) | (B & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QB_O) )}
+      j1 = { (~k1) }
+      k2 = { ~((QB_O & SHIFT) | (C & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QC_O) )}
+      j2 = { (~k2) }
+      k3 = { ~((QC_O & SHIFT) | (D & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QD_O) )}
+      j3 = { (~k3) }


uf0  JKff(1)  DPWR DGND
+    $D_HI $D_HI CLK
+    j0 k0 QA_O qabar
+    D0_EFF IO_STD

uf1  JKff(1)  DPWR DGND
+    $D_HI $D_HI CLK
+    j1 k1 QB_O qbbar
+    D0_EFF IO_STD

uf2  JKff(1)  DPWR DGND
+    $D_HI $D_HI CLK
+    j2 k2 QC_O qcbar
+    D0_EFF IO_STD

uf3  JKff(1)  DPWR DGND
+    $D_HI $D_HI CLK
+    j3 k3 QD_O qdbar
+    D0_EFF IO_STD

Udly PINDLY (4,0,1) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLK
+    QA QB QC QD
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+
+    PINDLY:
+     QA QB QC QD  = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                 DELAY(-1,24ns,36ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          SHIFT CLK A B C D SER LOAD
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 30ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(2) = SHIFT LOAD
+        SETUPTIME = 35ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(1) = SER
+        HOLDTIME = 5ns

.ENDS 74178
*
*
* ----------------------------------------------------------- 74179 ------
*  4-Bit Parallel Access Shift Registers
*
*  The TTL Logic Data Book, 1985, TI Pages 3-701 to 3-704
*  jds    5/2/94
*
.SUBCKT 74179  SHIFT LOAD CLK SER A B C D QA QB QC QD CLRBAR QDBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74179 LOGICEXP (12,8) DPWR DGND
+      A B C D LOAD SER QA_O QB_O QC_O QD_O SHIFT CLK
+      j0 j1 j2 j3 k0 k1 k2 k3
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      k0 = { ~((SER & SHIFT) | (A & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QA_O) )}
+      j0 = { (~k0) }
+      k1 = { ~((QA_O & SHIFT) | (B & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QB_O) )}
+      j1 = { (~k1) }
+      k2 = { ~((QB_O & SHIFT) | (C & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QC_O) )}
+      j2 = { (~k2) }
+      k3 = { ~((QC_O & SHIFT) | (D & (~SHIFT) & LOAD) |
+             ((~SHIFT) & (~LOAD) & QD_O) )}
+      j3 = { (~k3) }


uf0  JKff(1)  DPWR DGND
+    $D_HI CLRBAR CLK
+    j0 k0 QA_O qabar
+    D0_EFF IO_STD

uf1  JKff(1)  DPWR DGND
+    $D_HI CLRBAR CLK
+    j1 k1 QB_O qbbar
+    D0_EFF IO_STD

uf2  JKff(1)  DPWR DGND
+    $D_HI CLRBAR CLK
+    j2 k2 QC_O qcbar
+    D0_EFF IO_STD

uf3  JKff(1)  DPWR DGND
+    $D_HI CLRBAR CLK
+    j3 k3 QD_O QDBAR_O
+    D0_EFF IO_STD

Udly PINDLY (5,0,2) DPWR DGND
+    QA_O QB_O QC_O QD_O QDBAR_O
+    CLK CLRBAR
+    QA QB QC QD QDBAR
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = {CHANGED(CLK,0)}
+     CLEAR = {CHANGED(CLRBAR,0)}
+
+    PINDLY:
+     QA QB QC QD  = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                 CLEAR & TRN_HL, DELAY(-1,24ns,36ns),
+                 DELAY(-1,25ns,37ns)
+                )
+            }
+     QDBAR  = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                 CLEAR & TRN_LH, DELAY(-1,15ns,23ns),
+                 DELAY(-1,24ns,36ns)
+                )
+            }

Ucnstr CONSTRAINT(9) DPWR DGND
+          SHIFT CLK A B C D SER LOAD CLRBAR
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 30ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(2) = SHIFT LOAD
+        SETUPTIME = 35ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME = 15ns
+      SETUP_HOLD:
+        CLOCK HL = CLK
+        DATA(1) = SER
+        HOLDTIME = 5ns

.ENDS 74179
*
*
* ----------------------------------------------------------- 74180 ------
*  9-Bit Odd/Even Parity Generators/Checkers
*
*  The TTL Logic Data Book, 1988, TI Pages 2-597 to 2-600
*  jds    5/2/94
*
.SUBCKT 74180  EVEN ODD A B C D E F G H SUM_EVEN SUM_ODD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74180 LOGICEXP (10,2) DPWR DGND
+      EVEN ODD A B C D E F G H
+      SUM_EVEN_O SUM_ODD_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      data = { ~(( (~(A ^ B)) ^ (~(C ^ D))) ^ ((~(E ^ F)) ^ (~(G ^ H))))}
+      SUM_EVEN_O = {~((data & ODD) | ((~data) & EVEN))}
+      SUM_ODD_O = {~((data & EVEN) | ((~data) & ODD))}

Udly PINDLY (2,0,10) DPWR DGND
+    SUM_EVEN_O SUM_ODD_O
+    EVEN ODD A B C D E F G H
+    SUM_EVEN SUM_ODD
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) |
+              CHANGED(E,0) | CHANGED(F,0) | CHANGED(G,0) | CHANGED(H,0) }
+     PARITY = { (CHANGED(EVEN,0) | CHANGED(ODD,0)) }
+     EVEN_ZERO = { EVEN == '0 }
+     ODD_ZERO = { ODD == '0 }
+
+   PINDLY:
+     SUM_EVEN  = {
+            CASE(
+                 PARITY & TRN_LH, DELAY(-1,13ns,20ns),
+                 PARITY & TRN_HL, DELAY(-1,7ns,10ns),
+                 DATA & ODD_ZERO & TRN_LH, DELAY(-1,40ns,60ns),
+                 DATA & ODD_ZERO & TRN_HL, DELAY(-1,45ns,68ns),
+                 DATA & EVEN_ZERO & TRN_LH, DELAY(-1,32ns,48ns),
+                 DATA & EVEN_ZERO & TRN_HL, DELAY(-1,25ns,38ns),
+                 DELAY(-1,46ns,69ns)
+                )
+            }
+     SUM_ODD  = {
+            CASE(
+                 PARITY & TRN_LH, DELAY(-1,13ns,20ns),
+                 PARITY & TRN_HL, DELAY(-1,7ns,10ns),
+                 DATA & ODD_ZERO & TRN_LH, DELAY(-1,32ns,48ns),
+                 DATA & ODD_ZERO & TRN_HL, DELAY(-1,25ns,38ns),
+                 DATA & EVEN_ZERO & TRN_LH, DELAY(-1,40ns,60ns),
+                 DATA & EVEN_ZERO & TRN_HL, DELAY(-1,45ns,68ns),
+                 DELAY(-1,46ns,69ns)
+                )
+            }

.ENDS 74180
*
*
* ----------------------------------------------------------- 74HC180 ------
*  9-Bit Odd/Even Parity Generators/Checkers
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-259 to 2-262
*  jds    5/2/94
*
.SUBCKT 74HC180  EVEN ODD A B C D E F G H SUM_EVEN SUM_ODD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC180 LOGICEXP (10,2) DPWR DGND
+      EVEN ODD A B C D E F G H
+      SUM_EVEN_O SUM_ODD_O
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      data = { ~(( (~(A ^ B)) ^ (~(C ^ D))) ^ ((~(E ^ F)) ^ (~(G ^ H))))}
+      SUM_EVEN_O = {~((data & ODD) | ((~data) & EVEN))}
+      SUM_ODD_O = {~((data & EVEN) | ((~data) & ODD))}

Udly PINDLY (2,0,10) DPWR DGND
+    SUM_EVEN_O SUM_ODD_O
+    EVEN ODD A B C D E F G H
+    SUM_EVEN SUM_ODD
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) |
+              CHANGED(E,0) | CHANGED(F,0) | CHANGED(G,0) | CHANGED(H,0) }
+     PARITY = { (CHANGED(EVEN,0) | CHANGED(ODD,0)) }
+     EVEN_ZERO = { (EVEN == '0) }
+     ODD_ZERO = { (ODD == '0) }
+
+   PINDLY:
+     SUM_EVEN  = {
+            CASE(
+                 PARITY, DELAY(-1,15ns,22ns),
+                 DATA & ODD_ZERO, DELAY(-1,36ns,52ns),
+                 DATA & EVEN_ZERO, DELAY(-1,36ns,52ns),
+                 DELAY(-1,37ns,53ns)
+                )
+            }
+     SUM_ODD  = {
+            CASE(
+                 PARITY, DELAY(-1,15ns,22ns),
+                 DATA & ODD_ZERO, DELAY(-1,33ns,49ns),
+                 DATA & EVEN_ZERO, DELAY(-1,33ns,49ns),
+                 DELAY(-1,34ns,50ns)
+                )
+            }

.ENDS 74HC180
*
*
* ----------------------------------------------------------- 74181 ------
*  Arithmetic Logic Units/Functions Generators
*
*  The TTL Logic Data Book, 1985, TI Pages 3-709 to 3-720
*  jds    5/3/94
*
.SUBCKT 74181 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74181 LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))};avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) | CHANGED(B0BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(B2BAR,0) | CHANGED(B3BAR,0) }
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,12ns,18ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,13ns,19ns),
+                 SUM & DATA & TRN_LH, DELAY(-1,28ns,43ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,27ns,41ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,35ns,50ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,33ns,50ns),
+                 DELAY(-1,36ns,51ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,13ns,19ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,13ns,19ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,17ns,25ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,17ns,25ns),
+                 DELAY(-1,18ns,26ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,13ns,19ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,17ns,25ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,17ns,25ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,17ns,25ns),
+                 DELAY(-1,18ns,26ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATA & TRN_LH, DELAY(-1,35ns,50ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,32ns,48ns),
+                 DELAY(-1,36ns,51ns)
+                )
+            }
+     F0BAR F1BAR F2BAR F3BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,13ns,19ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,12ns,18ns),
+                 SUM & DATA & TRN_LH, DELAY(-1,28ns,42ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,21ns,32ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,32ns,48ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,23ns,34ns),
+                 MODE_HI & TRN_LH, DELAY(-1,32ns,48ns),
+                 MODE_HI & TRN_HL, DELAY(-1,23ns,34ns),
+                 DELAY(-1,33ns,49ns)
+                )
+            }

.ENDS 74181
*
*
*-------------------------------------------------------74ACT181------------
*
* The 74ACT181 Arithmetic Logic Unit/Function Generator
* TI Advanced CMOS Logic Data Book, 1993, pages 2-233 to 2-244
* jat 8/2/95

.SUBCKT 74ACT181
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+ M CN F0BAR F1BAR F2BAR F3BAR CN4 PBAR GBAR AEQUALB
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(14,8) DPWR DGND
+ B0BAR B1BAR B2BAR B3BAR A0BAR A1BAR A2BAR A3BAR S0 S1 S2 S3 M CN
+ F_0BAR F_1BAR F_2BAR F_3BAR A_EQUALB P_BAR G_BAR CN_4
+ D0_GATE IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  B0 = {~B0BAR}
+  B1 = {~B1BAR}
+  B2 = {~B2BAR}
+  B3 = {~B3BAR}
+  MBAR = {~M}
+  NORA0 = {~(A0BAR | (B0BAR & S0) | (S1 & B0))}
+  NORB0 = {~((B0 & S2 & A0BAR) | (A0BAR & S3 & B0BAR))}
+  NORA1 = {~(A1BAR | (B1BAR & S0) | (S1 & B1))}
+  NORB1 = {~((B1 & S2 & A1BAR) | (A1BAR & S3 & B1BAR))}
+  NORA2 = {~(A2BAR | (B2BAR & S0) | (S1 & B2))}
+  NORB2 = {~((B2 & S2 & A2BAR) | (A2BAR & S3 & B2BAR))}
+  NORA3 = {~(A3BAR | (B3BAR & S0) | (S1 & B3))}
+  NORB3 = {~((B3 & S2 & A3BAR) | (A3BAR & S3 & B3BAR))}
+  NAND0 = {~(MBAR & CN)}
+  XNOR0 = {NORA0 ^ NORB0}
+  NOR1  = {~((MBAR & NORA0) | (MBAR & NORB0 & CN))}
+  XNOR1 = {NORA1 ^ NORB1}
+  NOR2  = {~((MBAR & NORA1) | (MBAR & NORA0 & NORB1) |
+           (MBAR & NORB1 & NORB0 & CN))}
+  XNOR2 = {NORA2 ^ NORB2}
+  NOR3  = {~((NORA2 & MBAR) | (MBAR & NORA1 & NORB2) |
+           (MBAR & NORA0 & NORB2 & NORB1) |
+           (MBAR & NORB2 & NORB1 & NORB0 & CN))}
+  XNOR3 = {NORA3 ^ NORB3}
+  F_0BAR = {NAND0 ^ XNOR0}
+  F_1BAR = {NOR1 ^ XNOR1}
+  F_2BAR = {NOR2 ^ XNOR2}
+  F_3BAR = {NOR3 ^ XNOR3}
+  A_EQUALB  = {F_0BAR & F_1BAR & F_2BAR & F_3BAR}
+  P_BAR  = {~(NORB0 & NORB1 & NORB2 & NORB3)}
+  G_BAR  = {~((NORA0 & NORB1 & NORB2 & NORB3) | (NORA1 & NORB2 & NORB3) |
+           (NORA2 & NORB3) | NORA3)}
+  NAND3 = {~(CN & NORB0 & NORB1 & NORB2 & NORB3)}
+  CN_4 = {(~G_BAR) | (~NAND3)}

U2 PINDLY(8,0,14) DPWR DGND
+ F_0BAR F_1BAR F_2BAR F_3BAR A_EQUALB CN_4 G_BAR P_BAR
+ A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+ F0BAR F1BAR F2BAR F3BAR AEQUALB CN4 GBAR PBAR
+ IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    A = {CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | 
+         CHANGED(A2BAR,0) | CHANGED(A3BAR,0)}
+    B = {CHANGED(B0BAR,0) | CHANGED(B1BAR,0) | 
+         CHANGED(B2BAR,0) | CHANGED(B3BAR,0)}
+    S = {CHANGED(S0,0) | CHANGED(S1,0) | 
+         CHANGED(S2,0) | CHANGED(S3,0)}
+    CARRYIN = {CHANGED(CN,0)}
+    MODE = {CHANGED(M,0)}
+ PINDLY:
+    F0BAR F1BAR F2BAR F3BAR = {
+      CASE(
+        MODE & TRN_LH, DELAY(1.5NS,9.5NS,15NS),
+        MODE & TRN_HL, DELAY(1.5NS,10.6NS,16.4NS),
+        S & TRN_LH, DELAY(1.5NS,12.1NS,18.3NS),
+        S & TRN_HL, DELAY(1.5NS,10.6NS,15.8NS),
+        A & TRN_LH, DELAY(1.5NS,10NS,15.9NS),
+        A & TRN_HL, DELAY(1.5NS,11NS,17.4NS),
+        B & TRN_LH, DELAY(1.5NS,12.2NS,18NS),
+        B & TRN_HL, DELAY(1.5NS,11.5NS,18.3NS),
+        CARRYIN & TRN_LH, DELAY(1.5NS,11.2NS,17.1NS),
+        CARRYIN & TRN_HL, DELAY(1.5NS,9.9NS,15.9NS),
+        DELAY(2.5NS,20NS,25NS))}
+    AEQUALB = {
+      CASE(
+        MODE & TRN_LH, DELAY(1.5NS,15.7NS,19.3NS),
+        MODE & TRN_HL, DELAY(1.5NS,14NS,18.7NS),
+        S & TRN_LH, DELAY(1.5NS,18.7NS,22.1NS),
+        S & TRN_HL, DELAY(1.5NS,17.2NS,22.2NS),
+        A & TRN_LH, DELAY(1.5NS,16NS,21.5NS),
+        A & TRN_HL, DELAY(1.5NS,18.5NS,22.7NS),
+        B & TRN_LH, DELAY(1.5NS,18.5NS,22.7NS),
+        B & TRN_HL, DELAY(1.5NS,18.5NS,22NS),
+        DELAY(2.5NS,20NS,25NS))}
+    CN4 = {
+      CASE(
+        S & TRN_LH, DELAY(1.5NS,13.9NS,21.8NS),
+        S & TRN_HL, DELAY(1.5NS,15.3NS,22.3NS),
+        A & TRN_LH, DELAY(1.5NS,12.7NS,20.3NS),
+        A & TRN_HL, DELAY(1.5NS,14NS,19.7NS),
+        B & TRN_LH, DELAY(1.5NS,13.6NS,21.6NS),
+        B & TRN_HL, DELAY(1.5NS,13.6NS,19.7NS),
+        CARRYIN & TRN_LH, DELAY(1.5NS,10.7NS,17.5NS),
+        CARRYIN & TRN_HL, DELAY(1.5NS,11.3NS,16.2NS),
+        DELAY(2.5NS,20NS,25NS))}
+    GBAR = {
+      CASE(
+        S & TRN_LH, DELAY(1.5NS,12.7NS,20.5NS),
+        S & TRN_HL, DELAY(1.5NS,13.5NS,19.7NS),
+        A & TRN_LH, DELAY(1.5NS,12.8NS,2093NS),
+        A & TRN_HL, DELAY(1.5NS,12.7NS,17.8NS),
+        B & TRN_LH, DELAY(1.5NS,12.7NS,20.6NS),
+        B & TRN_HL, DELAY(1.5NS,14.3NS,19.2NS),
+        DELAY(2.5NS,20NS,25NS))}
+    PBAR = {
+      CASE(
+        S & TRN_LH, DELAY(1.5NS,12.4NS,18.6NS),
+        S & TRN_HL, DELAY(1.5NS,11.7NS,17.7NS),
+        A & TRN_LH, DELAY(1.5NS,11.4NS,18.4NS),
+        A & TRN_HL, DELAY(1.5NS,9.6NS,16.6NS),
+        B & TRN_LH, DELAY(1.5NS,11.3NS,18.2NS),
+        B & TRN_HL, DELAY(1.5NS,10.6NS,15.6NS),
+        DELAY(2.5NS,20NS,25NS))}

.ENDS 74ACT181
*
*
* ----------------------------------------------------------- 74AS181A ------
*  Arithmetic Logic Units/Functions Generators
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-187 to 2-208
*  jds    5/3/94
*
.SUBCKT 74AS181A A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS181A LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))} ;avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) | CHANGED(B0BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(B2BAR,0) | CHANGED(B3BAR,0) }
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,5ns,-1),
+                 CARRY_IN & TRN_HL, DELAY(-1,5ns,-1),
+                 SUM & DATA & TRN_LH, DELAY(-1,6ns,-1),
+                 SUM & DATA & TRN_HL, DELAY(-1,6ns,-1),
+                 DIFF & DATA & TRN_LH, DELAY(-1,7ns,-1),
+                 DIFF & DATA & TRN_HL, DELAY(-1,7ns,-1),
+                 DELAY(-1,8ns,-1)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,4ns,-1),
+                 SUM & DATA & TRN_HL, DELAY(-1,4ns,-1),
+                 DIFF & DATA & TRN_LH, DELAY(-1,5ns,-1),
+                 DIFF & DATA & TRN_HL, DELAY(-1,5ns,-1),
+                 DELAY(-1,6ns,-1)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,5ns,-1),
+                 SUM & DATA & TRN_HL, DELAY(-1,5ns,-1),
+                 DIFF & DATA & TRN_LH, DELAY(-1,5ns,-1),
+                 DIFF & DATA & TRN_HL, DELAY(-1,5ns,-1),
+                 DELAY(-1,6ns,-1)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATA & TRN_LH, DELAY(-1,12ns,-1),
+                 DIFF & DATA & TRN_HL, DELAY(-1,12ns,-1),
+                 DELAY(-1,12ns,-1)
+                )
+            }
+     F0BAR F1BAR F2BAR F3BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,5ns,-1),
+                 CARRY_IN & TRN_HL, DELAY(-1,5ns,-1),
+                 SUM & DATA & TRN_LH, DELAY(-1,5ns,-1),
+                 SUM & DATA & TRN_HL, DELAY(-1,5ns,-1),
+                 DIFF & DATA & TRN_LH, DELAY(-1,5ns,-1),
+                 DIFF & DATA & TRN_HL, DELAY(-1,5ns,-1),
+                 MODE_HI & TRN_LH, DELAY(-1,6ns,-1),
+                 MODE_HI & TRN_HL, DELAY(-1,6ns,-1),
+                 DELAY(-1,7ns,-1)
+                )
+            }

.ENDS 74AS181A
*
*
* ----------------------------------------------------------- 74AS181B ------
*  Arithmetic Logic Units/Functions Generators
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-187 to 2-208
*  jds    5/3/94
*
.SUBCKT 74AS181B A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS181B LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))} ; avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) | CHANGED(B0BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(B2BAR,0) | CHANGED(B3BAR,0) }
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,-1,8.5ns),
+                 CARRY_IN & TRN_HL, DELAY(2ns,-1,6.5ns),
+                 SUM & DATA & TRN_LH, DELAY(5ns,-1,12ns),
+                 SUM & DATA & TRN_HL, DELAY(5ns,-1,12ns),
+                 DIFF & DATA & TRN_LH, DELAY(5ns,-1,13ns),
+                 DIFF & DATA & TRN_HL, DELAY(5ns,-1,12.5ns),
+                 DELAY(6ns,-1,14ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(3ns,-1,8ns),
+                 SUM & DATA & TRN_HL, DELAY(2ns,-1,6ns),
+                 DIFF & DATA & TRN_LH, DELAY(3ns,-1,9.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(2ns,-1,7ns),
+                 DELAY(4ns,-1,10.5ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(3ns,-1,7.5ns),
+                 SUM & DATA & TRN_HL, DELAY(2ns,-1,6ns),
+                 DIFF & DATA & TRN_LH, DELAY(3ns,-1,9ns),
+                 DIFF & DATA & TRN_HL, DELAY(3ns,-1,8ns),
+                 DELAY(4ns,-1,10ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATA & TRN_LH, DELAY(4ns,-1,17ns),
+                 DIFF & DATA & TRN_HL, DELAY(5ns,-1,15ns),
+                 DELAY(6ns,-1,18ns)
+                )
+            }
+     F0BAR F1BAR F2BAR F3BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,-1,9ns),
+                 CARRY_IN & TRN_HL, DELAY(3ns,-1,7.5ns),
+                 SUM & DATA & TRN_LH, DELAY(3ns,-1,9.5ns),
+                 SUM & DATA & TRN_HL, DELAY(3ns,-1,7.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(3ns,-1,10.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(3ns,-1,9.5ns),
+                 MODE_HI & TRN_LH, DELAY(3ns,-1,11ns),
+                 MODE_HI & TRN_HL, DELAY(3ns,-1,9.5ns),
+                 DELAY(4ns,-1,12ns)
+                )
+            }

.ENDS 74AS181B
*
*
* ----------------------------------------------------------- 74F181 ------
*  Arithmetic Logic Units/Functions Generators
*
*  The Fast TTL Logic Series, 1992, Philips Pages 244-252
*  jds    5/3/94
*
.SUBCKT 74F181 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F181 LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))} ;avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) | CHANGED(B0BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(B2BAR,0) | CHANGED(B3BAR,0) }
+   ABZERO = { CHANGED(A0BAR,0) | CHANGED(B0BAR,0) }
+   ABONE = { CHANGED(A1BAR,0) | CHANGED(B1BAR,0) }
+   ABTWO = { CHANGED(A2BAR,0) | CHANGED(B2BAR,0) }
+   ABTHREE = { CHANGED(A3BAR,0) | CHANGED(B3BAR,0) }
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,5ns,8ns),
+                 CARRY_IN & TRN_HL, DELAY(2.5ns,5ns,8ns),
+                 SUM & DATA & TRN_LH, DELAY(5ns,9ns,12ns),
+                 SUM & DATA & TRN_HL, DELAY(5ns,8ns,12ns),
+                 DIFF & DATA & TRN_LH, DELAY(5ns,9.5ns,13ns),
+                 DIFF & DATA & TRN_HL, DELAY(5ns,8ns,12ns),
+                 DELAY(6ns,10.5ns,14ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(3ns,5ns,7.5ns),
+                 SUM & DATA & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(3ns,4.5ns,8ns),
+                 DIFF & DATA & TRN_HL, DELAY(3ns,5ns,8.5ns),
+                 DELAY(4ns,6ns,9.5ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(2.5ns,4ns,7ns),
+                 SUM & DATA & TRN_HL, DELAY(3ns,4.5ns,7.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(2.5ns,4ns,7.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(3ns,5ns,8.5ns),
+                 DELAY(4ns,6ns,9.5ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATA & TRN_LH, DELAY(10ns,14ns,19ns),
+                 DIFF & DATA & TRN_HL, DELAY(6ns,8.5ns,12ns),
+                 DELAY(11ns,15ns,20ns)
+                )
+            }
+     F0BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,5ns,8ns),
+                 CARRY_IN & TRN_HL, DELAY(3ns,5ns,8ns),
+                 SUM & ABZERO & TRN_LH, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & ABZERO & TRN_HL, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & DATA & TRN_LH, DELAY(3.5ns,6ns,10ns),
+                 SUM & DATA & TRN_HL, DELAY(3.5ns,5.5ns,9.5ns),
+                 DIFF & ABZERO & TRN_LH, DELAY(3ns,4.5ns,8.5ns),
+                 DIFF & ABZERO & TRN_HL, DELAY(3ns,5ns,8.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(4ns,6.5ns,10.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(4.5ns,7ns,10.5ns),
+                 MODE_HI & TRN_LH, DELAY(3.5ns,5.5ns,9ns),
+                 MODE_HI & TRN_HL, DELAY(3.5ns,5.5ns,10ns),
+                 DELAY(-1,27ns,39ns)
+                )
+            }
+     F1BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,5ns,8ns),
+                 CARRY_IN & TRN_HL, DELAY(3ns,5ns,8ns),
+                 SUM & ABONE & TRN_LH, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & ABONE & TRN_HL, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & DATA & TRN_LH, DELAY(3.5ns,6ns,10ns),
+                 SUM & DATA & TRN_HL, DELAY(3.5ns,5.5ns,9.5ns),
+                 DIFF & ABONE & TRN_LH, DELAY(3ns,4.5ns,8.5ns),
+                 DIFF & ABONE & TRN_HL, DELAY(3ns,5ns,8.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(4ns,6.5ns,10.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(4.5ns,7ns,10.5ns),
+                 MODE_HI & TRN_LH, DELAY(3.5ns,5.5ns,9ns),
+                 MODE_HI & TRN_HL, DELAY(3.5ns,5.5ns,10ns),
+                 DELAY(-1,27ns,39ns)
+                )
+            }
+      F2BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,5ns,8ns),
+                 CARRY_IN & TRN_HL, DELAY(3ns,5ns,8ns),
+                 SUM & ABTWO & TRN_LH, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & ABTWO & TRN_HL, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & DATA & TRN_LH, DELAY(3.5ns,6ns,10ns),
+                 SUM & DATA & TRN_HL, DELAY(3.5ns,5.5ns,9.5ns),
+                 DIFF & ABTWO & TRN_LH, DELAY(3ns,4.5ns,8.5ns),
+                 DIFF & ABTWO & TRN_HL, DELAY(3ns,5ns,8.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(4ns,6.5ns,10.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(4.5ns,7ns,10.5ns),
+                 MODE_HI & TRN_LH, DELAY(3.5ns,5.5ns,9ns),
+                 MODE_HI & TRN_HL, DELAY(3.5ns,5.5ns,10ns),
+                 DELAY(-1,27ns,39ns)
+                )
+            }
+     F3BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(3ns,5ns,8ns),
+                 CARRY_IN & TRN_HL, DELAY(3ns,5ns,8ns),
+                 SUM & ABTHREE & TRN_LH, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & ABTHREE & TRN_HL, DELAY(3ns,4.5ns,7.5ns),
+                 SUM & DATA & TRN_LH, DELAY(3.5ns,6ns,10ns),
+                 SUM & DATA & TRN_HL, DELAY(3.5ns,5.5ns,9.5ns),
+                 DIFF & ABTHREE & TRN_LH, DELAY(3ns,4.5ns,8.5ns),
+                 DIFF & ABTHREE & TRN_HL, DELAY(3ns,5ns,8.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(4ns,6.5ns,10.5ns),
+                 DIFF & DATA & TRN_HL, DELAY(4.5ns,7ns,10.5ns),
+                 MODE_HI & TRN_LH, DELAY(3.5ns,5.5ns,9ns),
+                 MODE_HI & TRN_HL, DELAY(3.5ns,5.5ns,10ns),
+                 DELAY(-1,27ns,39ns)
+                )
+            }

.ENDS 74F181
*
*
* ----------------------------------------------------------- 74HC181 ------
*  Arithmetic Logic Units/Functions Generators
*
*  The High Speed CMOS Logic Series, 1994, Philips Pages 387-399
*  jds    5/3/94
*
.SUBCKT 74HC181 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC181 LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))};avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) }
+   DATAB = { CHANGED(B0BAR,0) | CHANGED(B1BAR,0) | CHANGED(B2BAR,0) |
+            CHANGED(B3BAR,0) }
+   AZERO = { CHANGED(A0BAR,0) }
+   AONE = { CHANGED(A1BAR,0) }
+   ATWO = { CHANGED(A2BAR,0) }
+   ATHREE = { CHANGED(A3BAR,0)}
+   BZERO = { CHANGED(B0BAR,0) }
+   BONE = { CHANGED(B1BAR,0) }
+   BTWO = { CHANGED(B2BAR,0) }
+   BTHREE = { CHANGED(B3BAR,0)}
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN, DELAY(-1,20ns,33ns),
+                 SUM & DATAA, DELAY(-1,29ns,47ns),
+                 SUM & DATAB, DELAY(-1,29ns,47ns),
+                 DIFF & DATAA, DELAY(-1,28ns,47ns),
+                 DIFF & DATAB, DELAY(-1,31ns,51ns),
+                 DELAY(-1,32ns,52ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATAA, DELAY(-1,26ns,42ns),
+                 SUM & DATAB, DELAY(-1,28ns,46ns),
+                 DIFF & DATAA, DELAY(-1,26ns,43ns),
+                 DIFF & DATAB, DELAY(-1,28ns,48ns),
+                 DELAY(-1,29ns,49ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATAA, DELAY(-1,22ns,37ns),
+                 SUM & DATAB, DELAY(-1,23ns,39ns),
+                 DIFF & DATAA, DELAY(-1,20ns,34ns),
+                 DIFF & DATAB, DELAY(-1,23ns,39ns),
+                 DELAY(-1,24ns,40ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATAA, DELAY(-1,29ns,49ns),
+                 DIFF & DATAB, DELAY(-1,32ns,54ns),
+                 DELAY(-1,33ns,55ns)
+                )
+            }
+     F0BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,25ns,40ns),
+                 SUM & AZERO, DELAY(-1,28ns,46ns),
+                 SUM & BZERO, DELAY(-1,31ns,51ns),
+                 SUM & DATAA, DELAY(-1,30ns,51ns),
+                 SUM & DATAB, DELAY(-1,31ns,53ns),
+                 DIFF & AZERO, DELAY(-1,28ns,47ns),
+                 DIFF & BZERO, DELAY(-1,31ns,51ns),
+                 DIFF & DATAA, DELAY(-1,28ns,48ns),
+                 DIFF & DATAB, DELAY(-1,32ns,55ns),
+                 MODE_HI & DATAA, DELAY(-1,27ns,46ns),
+                 MODE_HI & DATAB, DELAY(-1,30ns,51ns),
+                 DELAY(-1,32ns,56ns)
+                )
+            }
+     F1BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,25ns,40ns),
+                 SUM & AONE, DELAY(-1,28ns,46ns),
+                 SUM & BONE, DELAY(-1,31ns,51ns),
+                 SUM & DATAA, DELAY(-1,30ns,51ns),
+                 SUM & DATAB, DELAY(-1,31ns,53ns),
+                 DIFF & AONE, DELAY(-1,28ns,47ns),
+                 DIFF & BONE, DELAY(-1,31ns,51ns),
+                 DIFF & DATAA, DELAY(-1,28ns,48ns),
+                 DIFF & DATAB, DELAY(-1,32ns,55ns),
+                 MODE_HI & DATAA, DELAY(-1,27ns,46ns),
+                 MODE_HI & DATAB, DELAY(-1,30ns,51ns),
+                 DELAY(-1,32ns,56ns)
+                )
+            }
+      F2BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,25ns,40ns),
+                 SUM & ATWO, DELAY(-1,28ns,46ns),
+                 SUM & BTWO, DELAY(-1,31ns,51ns),
+                 SUM & DATAA, DELAY(-1,30ns,51ns),
+                 SUM & DATAB, DELAY(-1,31ns,53ns),
+                 DIFF & ATWO, DELAY(-1,28ns,47ns),
+                 DIFF & BTWO, DELAY(-1,31ns,51ns),
+                 DIFF & DATAA, DELAY(-1,28ns,48ns),
+                 DIFF & DATAB, DELAY(-1,32ns,55ns),
+                 MODE_HI & DATAA, DELAY(-1,27ns,46ns),
+                 MODE_HI & DATAB, DELAY(-1,30ns,51ns),
+                 DELAY(-1,32ns,56ns)
+                )
+            }
+     F3BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,25ns,40ns),
+                 SUM & ATHREE, DELAY(-1,28ns,46ns),
+                 SUM & BTHREE, DELAY(-1,31ns,51ns),
+                 SUM & DATAA, DELAY(-1,30ns,51ns),
+                 SUM & DATAB, DELAY(-1,31ns,53ns),
+                 DIFF & ATHREE, DELAY(-1,28ns,47ns),
+                 DIFF & BTHREE, DELAY(-1,31ns,51ns),
+                 DIFF & DATAA, DELAY(-1,28ns,48ns),
+                 DIFF & DATAB, DELAY(-1,32ns,55ns),
+                 MODE_HI & DATAA, DELAY(-1,27ns,46ns),
+                 MODE_HI & DATAB, DELAY(-1,30ns,51ns),
+                 DELAY(-1,32ns,56ns)
+                )
+            }

.ENDS 74HC181
*
*
* ----------------------------------------------------------- 74HCT181 ------
*  Arithmetic Logic Units/Functions Generators
*
*  The High Speed CMOS Logic Series, 1994, Philips Pages 387-399
*  jds    5/3/94
*
.SUBCKT 74HCT181 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT181 LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))};avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATAA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) }
+   DATAB = { CHANGED(B0BAR,0) | CHANGED(B1BAR,0) | CHANGED(B2BAR,0) |
+            CHANGED(B3BAR,0) }
+   AZERO = { CHANGED(A0BAR,0) }
+   AONE = { CHANGED(A1BAR,0) }
+   ATWO = { CHANGED(A2BAR,0) }
+   ATHREE = { CHANGED(A3BAR,0)}
+   BZERO = { CHANGED(B0BAR,0) }
+   BONE = { CHANGED(B1BAR,0) }
+   BTWO = { CHANGED(B2BAR,0) }
+   BTHREE = { CHANGED(B3BAR,0)}
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN, DELAY(-1,25ns,42ns),
+                 SUM & DATAA, DELAY(-1,30ns,53ns),
+                 SUM & DATAB, DELAY(-1,31ns,53ns),
+                 DIFF & DATAA, DELAY(-1,30ns,55ns),
+                 DIFF & DATAB, DELAY(-1,34ns,55ns),
+                 DELAY(-1,35ns,56ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATAA, DELAY(-1,31ns,54ns),
+                 SUM & DATAB, DELAY(-1,32ns,54ns),
+                 DIFF & DATAA, DELAY(-1,31ns,54ns),
+                 DIFF & DATAB, DELAY(-1,31ns,54ns),
+                 DELAY(-1,33ns,55ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATAA, DELAY(-1,23ns,41ns),
+                 SUM & DATAB, DELAY(-1,24ns,41ns),
+                 DIFF & DATAA, DELAY(-1,23ns,40ns),
+                 DIFF & DATAB, DELAY(-1,23ns,40ns),
+                 DELAY(-1,25ns,42ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATAA, DELAY(-1,34ns,60ns),
+                 DIFF & DATAB, DELAY(-1,35ns,60ns),
+                 DELAY(-1,36ns,61ns)
+                )
+            }
+     F0BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,28ns,48ns),
+                 SUM & AZERO, DELAY(-1,33ns,58ns),
+                 SUM & BZERO, DELAY(-1,34ns,58ns),
+                 SUM & DATAA, DELAY(-1,33ns,56ns),
+                 SUM & DATAB, DELAY(-1,33ns,56ns),
+                 DIFF & AZERO, DELAY(-1,33ns,57ns),
+                 DIFF & BZERO, DELAY(-1,33ns,57ns),
+                 DIFF & DATAA, DELAY(-1,32ns,56ns),
+                 DIFF & DATAB, DELAY(-1,33ns,56ns),
+                 MODE_HI & DATAA, DELAY(-1,29ns,54ns),
+                 MODE_HI & DATAB, DELAY(-1,33ns,54ns),
+                 DELAY(-1,35ns,59ns)
+                )
+            }
+     F1BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,28ns,48ns),
+                 SUM & AONE, DELAY(-1,33ns,58ns),
+                 SUM & BONE, DELAY(-1,34ns,58ns),
+                 SUM & DATAA, DELAY(-1,33ns,56ns),
+                 SUM & DATAB, DELAY(-1,33ns,56ns),
+                 DIFF & AONE, DELAY(-1,33ns,57ns),
+                 DIFF & BONE, DELAY(-1,33ns,57ns),
+                 DIFF & DATAA, DELAY(-1,32ns,56ns),
+                 DIFF & DATAB, DELAY(-1,33ns,56ns),
+                 MODE_HI & DATAA, DELAY(-1,29ns,54ns),
+                 MODE_HI & DATAB, DELAY(-1,33ns,54ns),
+                 DELAY(-1,35ns,59ns)
+                )
+            }
+      F2BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,28ns,48ns),
+                 SUM & ATWO, DELAY(-1,33ns,58ns),
+                 SUM & BTWO, DELAY(-1,34ns,58ns),
+                 SUM & DATAA, DELAY(-1,33ns,56ns),
+                 SUM & DATAB, DELAY(-1,33ns,56ns),
+                 DIFF & ATWO, DELAY(-1,33ns,57ns),
+                 DIFF & BTWO, DELAY(-1,33ns,57ns),
+                 DIFF & DATAA, DELAY(-1,32ns,56ns),
+                 DIFF & DATAB, DELAY(-1,33ns,56ns),
+                 MODE_HI & DATAA, DELAY(-1,29ns,54ns),
+                 MODE_HI & DATAB, DELAY(-1,33ns,54ns),
+                 DELAY(-1,35ns,59ns)
+                )
+            }
+     F3BAR = {
+            CASE(
+                 CARRY_IN, DELAY(-1,28ns,48ns),
+                 SUM & ATHREE, DELAY(-1,33ns,58ns),
+                 SUM & BTHREE, DELAY(-1,34ns,58ns),
+                 SUM & DATAA, DELAY(-1,33ns,56ns),
+                 SUM & DATAB, DELAY(-1,33ns,56ns),
+                 DIFF & ATHREE, DELAY(-1,33ns,57ns),
+                 DIFF & BTHREE, DELAY(-1,33ns,57ns),
+                 DIFF & DATAA, DELAY(-1,32ns,56ns),
+                 DIFF & DATAB, DELAY(-1,33ns,56ns),
+                 MODE_HI & DATAA, DELAY(-1,29ns,54ns),
+                 MODE_HI & DATAB, DELAY(-1,33ns,54ns),
+                 DELAY(-1,35ns,59ns)
+                )
+            }

.ENDS 74HCT181
*
*
* ----------------------------------------------------------- 74LS181 ------
*  Arithmetic Logic Units/Functions Generators
*
*  The TTL Logic Data Book, 1988, TI Pages 2-601 to 2-610
*  jds    5/3/94
*
.SUBCKT 74LS181 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS181 LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))};avt
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) | CHANGED(B0BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(B2BAR,0) | CHANGED(B3BAR,0) }
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,18ns,27ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,13ns,20ns),
+                 SUM & DATA & TRN_LH, DELAY(-1,25ns,38ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,25ns,38ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,27ns,41ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,27ns,41ns),
+                 DELAY(-1,28ns,42ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,19ns,29ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,15ns,23ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,21ns,32ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,21ns,32ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,20ns,30ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,20ns,30ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,20ns,30ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,22ns,33ns),
+                 DELAY(-1,23ns,34ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATA & TRN_LH, DELAY(-1,33ns,50ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,41ns,62ns),
+                 DELAY(-1,42ns,63ns)
+                )
+            }
+     F0BAR F1BAR F2BAR F3BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,17ns,26ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,13ns,20ns),
+                 SUM & DATA & TRN_LH, DELAY(-1,21ns,32ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,13ns,20ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,21ns,32ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,21ns,32ns),
+                 MODE_HI & TRN_LH, DELAY(-1,22ns,33ns),
+                 MODE_HI & TRN_HL, DELAY(-1,26ns,38ns),
+                 DELAY(-1,27ns,39ns)
+                )
+            }

.ENDS 74LS181
*
*
* ----------------------------------------------------------- 74S181 ------
*  Arithmetic Logic Units/Functions Generators
*
*  The TTL Logic Data Book, 1988, TI Pages 2-601 to 2-610
*  jds    5/3/94
*
.SUBCKT 74S181 A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+             CN M F0BAR F1BAR F2BAR F3BAR GBAR CN4 PBAR AEQUALB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S181 LOGICEXP (14,8) DPWR DGND
+      A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3
+      CN M F0BAR_O F1BAR_O F2BAR_O F3BAR_O GBAR_O CN4_O PBAR_O AEQUALB_O
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = { ~((S3 & A3BAR & B3BAR) | (S2 & A3BAR & (~B3BAR))) }
+      i2 = { ~( (S1 & (~B3BAR))  | (S0 & B3BAR) | A3BAR) }
+      i3 = { ~((S3 & A2BAR & B2BAR) | (S2 & A2BAR & (~B2BAR))) }
+      i4 = { ~( (S1 & (~B2BAR))  | (S0 & B2BAR) | A2BAR) }
+      i5 = { ~((S3 & A1BAR & B1BAR) | (S2 & A1BAR & (~B1BAR))) }
+      i6 = { ~( (S1 & (~B1BAR))  | (S0 & B1BAR) | A1BAR) }
+      i7 = { ~((S3 & A0BAR & B0BAR) | (S2 & A0BAR & (~B0BAR))) }
+      i8 = { ~( (S1 & (~B0BAR))  | (S0 & B0BAR) | A0BAR) }
+      GBAR_O = {~(i2 | (i1 & i4) | (i1 & i3 & i6) | (i1 & i3 & i5 & i8))}
+      CN4_O = {~(GBAR_O & (~(i1 & i3 & i5 & i7 & CN)) )}
+      PBAR_O = { ~(i1 & i3 & i5 & i7)}
+      F3BAR_O = { ((i1 ^ i2)^ (~((CN & i7 & i5 & i3 & (~M)) |
+                ( i3 & i5 & i8 & (~M)) |
+                ( i3 & i6 & (~M)) |
+                ( i4 & (~M))))) }
+      F2BAR_O = { ((i3 ^ i4)^(~((CN & i7 & i5 & (~M)) |
+                (i5 & i8 & (~M)) |
+                (i6 & (~M))))) }
+      F1BAR_O = { ((i6 ^ i5) ^ (~((CN & (~M) & i7) |
+                (i8 & (~M)))))};AVT
+      F0BAR_O = { ((i8 ^ i7) ^ (~((~M) & CN))) }
+      AEQUALB_O = { (F3BAR_O & F2BAR_O & F1BAR_O & F0BAR_O) }

Udly PINDLY (8,0,14) DPWR DGND
+    GBAR_O CN4_O PBAR_O F3BAR_O F2BAR_O F1BAR_O F0BAR_O AEQUALB_O
+    A0BAR A1BAR A2BAR A3BAR B0BAR B1BAR B2BAR B3BAR S0 S1 S2 S3 CN M
+    GBAR CN4 PBAR F3BAR F2BAR F1BAR F0BAR AEQUALB
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+ BOOLEAN:
+   DATA = { CHANGED(A0BAR,0) | CHANGED(A1BAR,0) | CHANGED(A2BAR,0) |
+            CHANGED(A3BAR,0) | CHANGED(B0BAR,0) | CHANGED(B1BAR,0) |
+            CHANGED(B2BAR,0) | CHANGED(B3BAR,0) }
+   SUM = {(S1 == '0) & (S2 == '0) & (S0 == '1) & (S3 == '1) & (M == '0)}
+   DIFF = {(S1 == '1) & (S2 == '1) & (S0 == '0) & (S3 == '0) & (M == '0)}
+   MODE_HI = { (M == '1) }
+   CARRY_IN = { CHANGED(CN,0) }
+
+   PINDLY:
+     CN4  = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,7ns,10.5ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,7ns,10.5ns),
+                 SUM & DATA & TRN_LH, DELAY(-1,12.5ns,18.5ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,12.5ns,18.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,15.5ns,23ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,15.5ns,23ns),
+                 DELAY(-1,16.5ns,24ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,8ns,12ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,7.5ns,12ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,10.5ns,15ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,10.5ns,15ns),
+                 DELAY(-1,11.5ns,16ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 SUM & DATA & TRN_LH, DELAY(-1,7.5ns,12ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,7.5ns,12ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,10.5ns,15ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,10.5ns,15ns),
+                 DELAY(-1,11.5ns,16ns)
+                )
+            }
+     AEQUALB  = {
+            CASE(
+                 DIFF & DATA & TRN_LH, DELAY(-1,15ns,23ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,21ns,31ns)
+                )
+            }
+     F0BAR F1BAR F2BAR F3BAR = {
+            CASE(
+                 CARRY_IN & TRN_LH, DELAY(-1,7ns,12ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,7ns,12ns),
+                 SUM & DATA & TRN_LH, DELAY(-1,11ns,16.5ns),
+                 SUM & DATA & TRN_HL, DELAY(-1,11ns,16.5ns),
+                 DIFF & DATA & TRN_LH, DELAY(-1,14ns,20ns),
+                 DIFF & DATA & TRN_HL, DELAY(-1,14ns,22ns),
+                 MODE_HI & TRN_LH, DELAY(-1,14ns,20ns),
+                 MODE_HI & TRN_HL, DELAY(-1,14ns,22ns),
+                 DELAY(-1,15ns,23ns)
+                )
+            }

.ENDS 74S181
*
*
* ----------------------------------------------------------- 74182 ------
*  Look Ahead Carry Generator
*
*  The Standard TTL Logic Data Book, 1985, TI Pages 3-721 to 3-726
*  jds    5/3/94
*
.SUBCKT 74182  CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+              CNX CNY CNZ PBAR GBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74182 LOGICEXP (9,5) DPWR DGND
+      CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+      CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      PBAR_O = { (P0BAR | P1BAR | P2BAR | P3BAR) }
+      g0 = { (G0BAR & G1BAR & G2BAR & G3BAR) }
+      g1 = { (P1BAR & G1BAR & G2BAR & G3BAR) }
+      g2 = { (P2BAR & G2BAR & G3BAR) }
+      g3 = { (P3BAR & G3BAR) }
+      GBAR_O = { (g0 | g1 | g2 | g3) }
+      cnz0 = { (G0BAR & G1BAR & G2BAR & (~CN)) }
+      cnz1 = { (G0BAR & G1BAR & G2BAR & P0BAR) }
+      cnz2 = { (G1BAR & G2BAR & P1BAR) }
+      cnz3 = { (G2BAR & P2BAR) }
+      CNZ_O = { ~(cnz0 | cnz1 | cnz2 | cnz3) }
+      cny0 = { (G0BAR & G1BAR & (~CN)) }
+      cny1 = { (P0BAR & G0BAR & G1BAR) }
+      cny2 = { (G1BAR & P1BAR) }
+      CNY_O = { ~(cny0 | cny1 | cny2) }
+      cnx0 = { (G0BAR & (~CN)) }
+      cnx1 = { (P0BAR & G0BAR) }
+      CNX_O = { ~(cnx0 | cnx1) }



Udly PINDLY (5,0,9) DPWR DGND
+    CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+    CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+    CNX CNY CNZ PBAR GBAR
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   PINDLY:
+     CNX CNY CNZ  GBAR PBAR= {
+            CASE(
+                 TRN_LH, DELAY(-1,11ns,17ns),
+                 TRN_HL, DELAY(-1,15ns,22ns),
+                 DELAY(-1,16ns,23ns)
+                )
+            }

.ENDS 74182
*
*
* ----------------------------------------------------------- 74AS182 ------
*  Look Ahead Carry Generator
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-209 to2-212
*  jds    5/3/94
*
.SUBCKT 74AS182  CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+              CNX CNY CNZ PBAR GBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS182 LOGICEXP (9,5) DPWR DGND
+      CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+      CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      PBAR_O = { (P0BAR | P1BAR | P2BAR | P3BAR) }
+      g0 = { (G0BAR & G1BAR & G2BAR & G3BAR) }
+      g1 = { (P1BAR & G1BAR & G2BAR & G3BAR) }
+      g2 = { (P2BAR & G2BAR & G3BAR) }
+      g3 = { (P3BAR & G3BAR) }
+      GBAR_O = { (g0 | g1 | g2 | g3) }
+      cnz0 = { (G0BAR & G1BAR & G2BAR & (~CN)) }
+      cnz1 = { (G0BAR & G1BAR & G2BAR & P0BAR) }
+      cnz2 = { (G1BAR & G2BAR & P1BAR) }
+      cnz3 = { (G2BAR & P2BAR) }
+      CNZ_O = { ~(cnz0 | cnz1 | cnz2 | cnz3) }
+      cny0 = { (G0BAR & G1BAR & (~CN)) }
+      cny1 = { (P0BAR & G0BAR & G1BAR) }
+      cny2 = { (G1BAR & P1BAR) }
+      CNY_O = { ~(cny0 | cny1 | cny2) }
+      cnx0 = { (G0BAR & (~CN)) }
+      cnx1 = { (P0BAR & G0BAR) }
+      CNX_O = { ~(cnx0 | cnx1) }



Udly PINDLY (5,0,9) DPWR DGND
+    CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+    CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+    CNX CNY CNZ PBAR GBAR
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     PDATA = { CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0) |
+              CHANGED(P3BAR,0) }
+     GDATA = { CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0) |
+              CHANGED(G3BAR,0) }
+     CARRY_IN = { (CHANGED(CN,0)) }
+
+   PINDLY:
+     CNX CNY CNZ  = {
+            CASE(
+                 (PDATA | GDATA) & TRN_LH, DELAY(-1,5ns,-1),
+                 (PDATA | GDATA) & TRN_HL, DELAY(-1,5ns,-1),
+                 CARRY_IN & TRN_LH, DELAY(-1,5ns,-1),
+                 CARRY_IN & TRN_HL, DELAY(-1,5ns,-1),
+                 DELAY(-1,6ns,-1)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 (PDATA | GDATA) & TRN_LH, DELAY(-1,6ns,-1),
+                 (PDATA | GDATA) & TRN_HL, DELAY(-1,5ns,-1),
+                 DELAY(-1,7ns,-1)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 PDATA & TRN_LH, DELAY(-1,5ns,-1),
+                 PDATA & TRN_HL, DELAY(-1,5ns,-1),
+                 DELAY(-1,6ns,-1)
+                )
+            }

.ENDS 74AS182
*
*
* ----------------------------------------------------------- 74F182 ------
*  Look Ahead Carry Generator
*
*  The Fast TTL Logic Series, 1992, Philips Pages 252-257
*  jds    5/5/94
*
.SUBCKT 74F182  CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+              CNX CNY CNZ PBAR GBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F182 LOGICEXP (9,5) DPWR DGND
+      CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+      CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      PBAR_O = { (P0BAR | P1BAR | P2BAR | P3BAR) }
+      g0 = { (G0BAR & G1BAR & G2BAR & G3BAR) }
+      g1 = { (P1BAR & G1BAR & G2BAR & G3BAR) }
+      g2 = { (P2BAR & G2BAR & G3BAR) }
+      g3 = { (P3BAR & G3BAR) }
+      GBAR_O = { (g0 | g1 | g2 | g3) }
+      cnz0 = { (G0BAR & G1BAR & G2BAR & (~CN)) }
+      cnz1 = { (G0BAR & G1BAR & G2BAR & P0BAR) }
+      cnz2 = { (G1BAR & G2BAR & P1BAR) }
+      cnz3 = { (G2BAR & P2BAR) }
+      CNZ_O = { ~(cnz0 | cnz1 | cnz2 | cnz3) }
+      cny0 = { (G0BAR & G1BAR & (~CN)) }
+      cny1 = { (P0BAR & G0BAR & G1BAR) }
+      cny2 = { (G1BAR & P1BAR) }
+      CNY_O = { ~(cny0 | cny1 | cny2) }
+      cnx0 = { (G0BAR & (~CN)) }
+      cnx1 = { (P0BAR & G0BAR) }
+      CNX_O = { ~(cnx0 | cnx1) }



Udly PINDLY (5,0,9) DPWR DGND
+    CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+    CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+    CNX CNY CNZ PBAR GBAR
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     PDATA = { CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0) |
+              CHANGED(P3BAR,0) }
+     GDATA = { CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0) | 
+               CHANGED(G3BAR,0) }
+     CARRY_IN = { (CHANGED(CN,0)) }
+
+   PINDLY:
+     CNX CNY CNZ  = {
+            CASE(
+                 PDATA & TRN_LH, DELAY(2ns,5ns,7ns),
+                 PDATA & TRN_HL, DELAY(1.5ns,3.5ns,5ns),
+                 GDATA & TRN_LH, DELAY(1.5ns,4ns,7.5ns),
+                 GDATA & TRN_HL, DELAY(1.5ns,3ns,5ns),
+                 CARRY_IN & TRN_LH, DELAY(2.5ns,5ns,8ns),
+                 CARRY_IN & TRN_HL, DELAY(2.5ns,5ns,7.5ns),
+                 DELAY(3.5ns,6ns,9ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 PDATA & TRN_LH, DELAY(2ns,7ns,10ns),
+                 PDATA & TRN_HL, DELAY(3ns,5ns,7ns),
+                 GDATA & TRN_LH, DELAY(1.5ns,5ns,7ns),
+                 GDATA & TRN_HL, DELAY(3ns,5ns,7ns),
+                 DELAY(4ns,8ns,11ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 PDATA & TRN_LH, DELAY(1.5ns,3.5ns,6ns),
+                 PDATA & TRN_HL, DELAY(2.5ns,4ns,6ns),
+                 DELAY(3.5ns,5ns,7ns)
+                )
+            }

.ENDS 74F182
*
*
* ----------------------------------------------------------- 74HC182 ------
*  Look Ahead Carry Generator
*
*  The High Speed Logic Family Data Book, 1994, Philips Pages 401-407
*  jds    5/3/94
*
.SUBCKT 74HC182  CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+              CNX CNY CNZ PBAR GBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC182 LOGICEXP (9,5) DPWR DGND
+      CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+      CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      PBAR_O = { (P0BAR | P1BAR | P2BAR | P3BAR) }
+      g0 = { (G0BAR & G1BAR & G2BAR & G3BAR) }
+      g1 = { (P1BAR & G1BAR & G2BAR & G3BAR) }
+      g2 = { (P2BAR & G2BAR & G3BAR) }
+      g3 = { (P3BAR & G3BAR) }
+      GBAR_O = { (g0 | g1 | g2 | g3) }
+      cnz0 = { (G0BAR & G1BAR & G2BAR & (~CN)) }
+      cnz1 = { (G0BAR & G1BAR & G2BAR & P0BAR) }
+      cnz2 = { (G1BAR & G2BAR & P1BAR) }
+      cnz3 = { (G2BAR & P2BAR) }
+      CNZ_O = { ~(cnz0 | cnz1 | cnz2 | cnz3) }
+      cny0 = { (G0BAR & G1BAR & (~CN)) }
+      cny1 = { (P0BAR & G0BAR & G1BAR) }
+      cny2 = { (G1BAR & P1BAR) }
+      CNY_O = { ~(cny0 | cny1 | cny2) }
+      cnx0 = { (G0BAR & (~CN)) }
+      cnx1 = { (P0BAR & G0BAR) }
+      CNX_O = { ~(cnx0 | cnx1) }



Udly PINDLY (5,0,9) DPWR DGND
+    CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+    CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+    CNX CNY CNZ PBAR GBAR
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     PDATA = { CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0) |
+              CHANGED(P3BAR,0) }
+     GDATA = { CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0) |
+              CHANGED(G3BAR,0) }
+     CARRY_IN = { (CHANGED(CN,0)) }
+
+   PINDLY:
+     CNX CNY CNZ  = {
+            CASE(
+                 PDATA, DELAY(-1,17ns,29ns),
+                 GDATA, DELAY(-1,16ns,27ns),
+                 CARRY_IN, DELAY(-1,20ns,34ns),
+                 DELAY(-1,21ns,35ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 PDATA, DELAY(-1,17ns,29ns),
+                 GDATA, DELAY(-1,15ns,27ns),
+                 DELAY(-1,18ns,30ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 PDATA, DELAY(-1,14ns,24ns),
+                 DELAY(-1,15ns,25ns)
+                )
+            }

.ENDS 74HC182
*
*
* ----------------------------------------------------------- 74HCT182 ------
*  Look Ahead Carry Generator
*
*  The High Speed Logic Family Data Book, 1994, Philips Pages 401-407
*  jds    5/3/94
*
.SUBCKT 74HCT182  CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+              CNX CNY CNZ PBAR GBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT182 LOGICEXP (9,5) DPWR DGND
+      CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+      CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+      D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      PBAR_O = { (P0BAR | P1BAR | P2BAR | P3BAR) }
+      g0 = { (G0BAR & G1BAR & G2BAR & G3BAR) }
+      g1 = { (P1BAR & G1BAR & G2BAR & G3BAR) }
+      g2 = { (P2BAR & G2BAR & G3BAR) }
+      g3 = { (P3BAR & G3BAR) }
+      GBAR_O = { (g0 | g1 | g2 | g3) }
+      cnz0 = { (G0BAR & G1BAR & G2BAR & (~CN)) }
+      cnz1 = { (G0BAR & G1BAR & G2BAR & P0BAR) }
+      cnz2 = { (G1BAR & G2BAR & P1BAR) }
+      cnz3 = { (G2BAR & P2BAR) }
+      CNZ_O = { ~(cnz0 | cnz1 | cnz2 | cnz3) }
+      cny0 = { (G0BAR & G1BAR & (~CN)) }
+      cny1 = { (P0BAR & G0BAR & G1BAR) }
+      cny2 = { (G1BAR & P1BAR) }
+      CNY_O = { ~(cny0 | cny1 | cny2) }
+      cnx0 = { (G0BAR & (~CN)) }
+      cnx1 = { (P0BAR & G0BAR) }
+      CNX_O = { ~(cnx0 | cnx1) }



Udly PINDLY (5,0,9) DPWR DGND
+    CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+    CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+    CNX CNY CNZ PBAR GBAR
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     PDATA = { CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0) |
+              CHANGED(P3BAR,0) }
+     GDATA = { CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0) |
+              CHANGED(G3BAR,0) }
+     CARRY_IN = { (CHANGED(CN,0)) }
+
+   PINDLY:
+     CNX CNY CNZ  = {
+            CASE(
+                 PDATA, DELAY(-1,20ns,33ns),
+                 GDATA, DELAY(-1,18ns,32ns),
+                 CARRY_IN, DELAY(-1,26ns,43ns),
+                 DELAY(-1,27ns,44ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 PDATA, DELAY(-1,20ns,33ns),
+                 GDATA, DELAY(-1,18ns,32ns),
+                 DELAY(-1,21ns,34ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 PDATA, DELAY(-1,17ns,28ns),
+                 DELAY(-1,16ns,29ns)
+                )
+            }

.ENDS 74HCT182

*------------------------------------------------------------74LS182-----

* Carry Lookahead Generator
* Motorola Schottky TTL Logic Databook, 1983, pages 4-173 to 4-176
* jat 8/7/96

.SUBCKT 74LS182 G0BAR G1BAR G2BAR G3BAR P0BAR P1BAR P2BAR P3BAR
+ CN CNX CNY CNZ GBAR PBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(9,5) DPWR DGND
+ G0BAR G1BAR G2BAR G3BAR P0BAR P1BAR P2BAR P3BAR CN
+ CNXO CNYO CNZO GBARO PBARO
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CNXO = {~((G0BAR & P0BAR) | (~CN & G0BAR))}
+   CNYO = {~((G1BAR & P1BAR) | (G0BAR & G1BAR & P1BAR) | (~CN & G0BAR & G1BAR))}
+   CNZO = {~((G2BAR & P2BAR) | (G1BAR & P1BAR & G2BAR) | (G0BAR & G1BAR & G2BAR & P0BAR) |
+             (~CN & G0BAR & G1BAR & G2BAR))}
+   GBARO = {(G3BAR & P3BAR) | (G2BAR & P2BAR & G3BAR) | (G1BAR & G2BAR & G3BAR & P1BAR) |
+            (G0BAR & G1BAR & G2BAR & G3BAR)}
+   PBARO = {P0BAR | P1BAR | P2BAR  | P3BAR}

U2 PINDLY(5,0,9) DPWR DGND
+ CNXO CNYO CNZO GBARO PBARO
+ CN G0BAR G1BAR G2BAR G3BAR P0BAR P1BAR P2BAR P3BAR
+ CNX CNY CNZ GBAR PBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  CARRY = {CHANGED(CN,0)}
+  P02 = {CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0)}
+  G02 = {CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0)}
+  P03 = {CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0) | CHANGED(P3BAR,0)}
+  G03 = {CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0) | CHANGED(G3BAR,0)}
+  P13 = {CHANGED(P1BAR,0) | CHANGED(P2BAR,0) | CHANGED(P3BAR,0)}
+ PINDLY:
+   CNX CNY CNZ = {
+     CASE(
+       (G02 | P02) & TRN_LH, DELAY(-1,9NS,21NS),
+       (G02 | P02) & TRN_HL, DELAY(-1,10NS,22NS),
+       CARRY & TRN_LH, DELAY(-1,12NS,25NS),
+       CARRY & TRN_HL, DELAY(-1,17NS,30NS),
+       DELAY(-1,18NS,31NS))}
+   GBAR = {
+     CASE(
+       G03 & TRN_LH, DELAY(-1,13NS,25NS),
+       G03 & TRN_HL, DELAY(-1,8NS,20NS),
+       P13 & TRN_LH, DELAY(-1,12NS,24NS),
+       P13 & TRN_HL, DELAY(-1,8NS,20NS),
+       DELAY(-1,14NS,26NS))}
+   PBAR = {
+     CASE(
+       P03 & TRN_LH, DELAY(-1,12NS,24NS),
+       P03 & TRN_HL, DELAY(-1,8NS,20NS),
+       DELAY(-1,13NS,25NS))}

.ENDS 74LS182

* ----------------------------------------------------------- 74S182 ------
*  Look Ahead Carry Generator
*
*  The Standard TTL Logic Data Book, 1988, TI Pages 2-611 to 2-616
*  jds    5/3/94
*
.SUBCKT 74S182  CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+              CNX CNY CNZ PBAR GBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S182 LOGICEXP (9,5) DPWR DGND
+      CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+      CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      PBAR_O = { (P0BAR | P1BAR | P2BAR | P3BAR) }
+      g0 = { (G0BAR & G1BAR & G2BAR & G3BAR) }
+      g1 = { (P1BAR & G1BAR & G2BAR & G3BAR) }
+      g2 = { (P2BAR & G2BAR & G3BAR) }
+      g3 = { (P3BAR & G3BAR) }
+      GBAR_O = { (g0 | g1 | g2 | g3) }
+      cnz0 = { (G0BAR & G1BAR & G2BAR & (~CN)) }
+      cnz1 = { (G0BAR & G1BAR & G2BAR & P0BAR) }
+      cnz2 = { (G1BAR & G2BAR & P1BAR) }
+      cnz3 = { (G2BAR & P2BAR) }
+      CNZ_O = { ~(cnz0 | cnz1 | cnz2 | cnz3) }
+      cny0 = { (G0BAR & G1BAR & (~CN)) }
+      cny1 = { (P0BAR & G0BAR & G1BAR) }
+      cny2 = { (G1BAR & P1BAR) }
+      CNY_O = { ~(cny0 | cny1 | cny2) }
+      cnx0 = { (G0BAR & (~CN)) }
+      cnx1 = { (P0BAR & G0BAR) }
+      CNX_O = { ~(cnx0 | cnx1) }



Udly PINDLY (5,0,9) DPWR DGND
+    CNX_O CNY_O CNZ_O PBAR_O GBAR_O
+    CN P0BAR P1BAR P2BAR P3BAR G0BAR G1BAR G2BAR G3BAR
+    CNX CNY CNZ PBAR GBAR
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+     PDATA = { CHANGED(P0BAR,0) | CHANGED(P1BAR,0) | CHANGED(P2BAR,0) |
+              CHANGED(P3BAR,0) }
+     GDATA = { CHANGED(G0BAR,0) | CHANGED(G1BAR,0) | CHANGED(G2BAR,0) |
+              CHANGED(G3BAR,0) }
+     CARRY_IN = { (CHANGED(CN,0)) }
+
+   PINDLY:
+     CNX CNY CNZ  = {
+            CASE(
+                 (PDATA | GDATA) & TRN_LH, DELAY(-1,4.5ns,7ns),
+                 (PDATA | GDATA) & TRN_HL, DELAY(-1,4.5ns,7ns),
+                 CARRY_IN & TRN_LH, DELAY(-1,6.5ns,10ns),
+                 CARRY_IN & TRN_HL, DELAY(-1,7ns,10.5ns),
+                 DELAY(-1,7.5ns,11.5ns)
+                )
+            }
+     GBAR  = {
+            CASE(
+                 (PDATA | GDATA) & TRN_LH, DELAY(-1,5ns,7.5ns),
+                 (PDATA | GDATA) & TRN_HL, DELAY(-1,7ns,10.5ns),
+                 DELAY(-1,7.5ns,11.5ns)
+                )
+            }
+     PBAR  = {
+            CASE(
+                 PDATA & TRN_LH, DELAY(-1,4.5ns,6.5ns),
+                 PDATA & TRN_HL, DELAY(-1,6.5ns,10ns),
+                 DELAY(-1,7.5ns,11ns)
+                )
+            }

.ENDS 74S182
*
*
* ----------------------------------------------------------- 74H183 ------
*  Dual Carry-Save Full Adder
*
*  The Standard TTL Logic Data Book, 1985, TI Pages 3-727 to 3-730
*  jds    5/4/94
*
.SUBCKT 74H183  1A 1B 1CN 1SUM 1CN1 2A 2B 2CN 2SUM 2CN1
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74H183 LOGICEXP (6,4) DPWR DGND
+      1A 1B 1CN 2A 2B 2CN
+      1SUM_O 1CN1_O 2SUM_O 2CN1_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      c1a = {(~1CN & ~1B)}
+      c2a = {(~1B & ~1A)}
+      c3a = {(~1CN & ~1A)}
+      1CN1_O = { ~(c1a | c2a | c3a) }
+      s1a = {(1CN & ~1B & 1A)}
+      s2a = {(~1CN & 1B & 1A)}
+      s3a = {(~1CN & ~1B & ~1A)}
+      s4a = {(1CN & 1B & ~1A)}
+      1SUM_O = { ~(s1a | s2a | s3a | s4a) }
+      c1b = {(~2CN & ~2B)}
+      c2b = {(~2B & ~2A)}
+      c3b = {(~2CN & ~2A)}
+      2CN1_O = { ~(c1b | c2b | c3b) }
+      s1b = {(2CN & ~2B & 2A)}
+      s2b = {(~2CN & 2B & 2A)}
+      s3b = {(~2CN & ~2B & ~2A)}
+      s4b = {(2CN & 2B & ~2A)}
+      2SUM_O = { ~(s1b | s2b | s3b | s4b) }

Udly PINDLY (4,0,6) DPWR DGND
+      1SUM_O 1CN1_O 2SUM_O 2CN1_O
+      1A 1B 1CN 2A 2B 2CN
+      1SUM 1CN1 2SUM 2CN1
+      IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   PINDLY:
+     1SUM 1CN1 2SUM 2CN1  = {
+            CASE(
+                 TRN_LH, DELAY(-1,10ns,15ns),
+                 TRN_HL, DELAY(-1,12ns,18ns),
+                 DELAY(-1,11ns,19ns)
+                )
+            }

.ENDS 74H183
*
*
* ----------------------------------------------------------- 74LS183 ------
*  Dual Carry-Save Full Adder
*
*  The Standard TTL Logic Data Book, 1985, TI Pages 3-727 to 3-730
*  jds    5/4/94
*
.SUBCKT 74LS183  1A 1B 1CN 1SUM 1CN1 2A 2B 2CN 2SUM 2CN1
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS183 LOGICEXP (6,4) DPWR DGND
+      1A 1B 1CN 2A 2B 2CN
+      1SUM_O 1CN1_O 2SUM_O 2CN1_O
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      c1a = {(~1CN & ~1B)}
+      c2a = {(~1B & ~1A)}
+      c3a = {(~1CN & ~1A)}
+      1CN1_O = { ~(c1a | c2a | c3a) }
+      s1a = {(1CN & ~1B & 1A)}
+      s2a = {(~1CN & 1B & 1A)}
+      s3a = {(~1CN & ~1B & ~1A)}
+      s4a = {(1CN & 1B & ~1A)}
+      1SUM_O = { ~(s1a | s2a | s3a | s4a) }
+      c1b = {(~2CN & ~2B)}
+      c2b = {(~2B & ~2A)}
+      c3b = {(~2CN & ~2A)}
+      2CN1_O = { ~(c1b | c2b | c3b) }
+      s1b = {(2CN & ~2B & 2A)}
+      s2b = {(~2CN & 2B & 2A)}
+      s3b = {(~2CN & ~2B & ~2A)}
+      s4b = {(2CN & 2B & ~2A)}
+      2SUM_O = { ~(s1b | s2b | s3b | s4b) }

Udly PINDLY (4,0,6) DPWR DGND
+      1SUM_O 1CN1_O 2SUM_O 2CN1_O
+      1A 1B 1CN 2A 2B 2CN
+      1SUM 1CN1 2SUM 2CN1
+      IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   PINDLY:
+     1SUM 1CN1 2SUM 2CN1  = {
+            CASE(
+                 TRN_LH, DELAY(-1,9ns,15ns),
+                 TRN_HL, DELAY(-1,20ns,33ns),
+                 DELAY(-1,21ns,34ns)
+                )
+            }

.ENDS 74LS183
*
*
* ----------------------------------------------------------- 74184 ------
*  BCD-to-Binary Converter
*
*  The Standard TTL Logic Data Book, 1985, TI Pages 3-731 to 3-740
*  jds    5/4/94
*
.SUBCKT 74184  A B C D E GBAR Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74184 LOGICEXP (6,8) DPWR DGND
+      A B C D E GBAR
+      Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = {(A & ~C & ~D) | (~A & ~C & D) | (~A & ~B & D) | (C & A) | (C & B)}
+      i2 = {(~A & ~B & E) | (~B & ~C & ~D & E) | (B & ~C & ~D & ~E) |
+            (~A & B & ~C & ~E) | (A & ~B & ~C & D & ~E) |
+            (A & B & ~C & D & E) | (C & B) | (C & A)}
+      i3 = {(~A & ~B & C & ~D) |
+            (A & ~B & ~C & D & ~E) |
+            (B & ~C & ~D & E) |
+            (~A & ~B & ~C & D) |
+            (~A & ~C & D & ~E) | (C & B) | (C & A)}
+      i4 = {(~C & ~D & E) |
+            (~A & ~B & ~C & E) |
+            (~A & ~B & ~D & E) |
+            (~A & ~B & C & D & ~E) |
+            (A & B & ~C & D & ~E) | (C & B) | (C & A)}
+      i5 = {(B & ~C & D & E) |
+            (A & ~C & D & E) |
+            (~A & ~B & C & D & E) | (C & B) | (C & A)}
+      i6 = {(~A & ~B & ~C & ~E) | (~A & ~B & ~C & D & E) |
+            (~A & ~D & ~E) |
+            (A & B & ~D & E) |
+            (~A & ~B & C & ~D) | (D & B) | (D & C)}
+      i7 = {(~B & C & ~D) |
+            (B & ~C & ~D & ~E) |
+            (~A & C & ~D & E) |
+            (A & B & ~C & ~D) | (D & B) | (D & C)}
+      i8 = {(~B & ~C & ~D & ~E) |
+            (A & ~B & ~C & ~D) |
+            (~A & B & ~C & E) | (D & B) | (D & C)}
+      Y1_O = { (i1 | GBAR) }
+      Y2_O = { (i2 | GBAR) }
+      Y3_O = { (i3 | GBAR) }
+      Y4_O = { (i4 | GBAR) }
+      Y5_O = { (i5 | GBAR) }
+      Y6_O = { (i6 | GBAR) }
+      Y7_O = { (i7 | GBAR) }
+      Y8_O = { (i8 | GBAR) }

Udly PINDLY (8,0,6) DPWR DGND
+      Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O
+      A B C D E GBAR
+      Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+      IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+      DATA= {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) |
+             CHANGED(E,0) }
+      EN = {CHANGED(GBAR,0)}
+
+   PINDLY:
+     Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8   = {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,27ns,40ns),
+                 DATA & TRN_HL, DELAY(-1,23ns,40ns),
+                 EN & TRN_LH, DELAY(-1,19ns,30ns),
+                 EN & TRN_HL, DELAY(-1,22ns,35ns),
+                 DELAY(-1,28ns,41ns)
+                )
+            }

.ENDS 74184
*
*
* ----------------------------------------------------------- 74185A ------
*  BCD-to-Binary Converter
*
*  The Standard TTL Logic Data Book, 1985, TI Pages 3-731 to 3-740
*  jds    5/4/94
*
.SUBCKT 74185A  A B C D E GBAR Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74185A LOGICEXP (6,8) DPWR DGND
+      A B C D E GBAR
+      Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      i1 = {(~A & B & ~C & E) |
+            (~A & ~C & ~D & E) |
+            (A & ~C & ~D & ~E) |
+            (A & C & ~D & E) |
+            (A & B & C & E)  |
+            (A & B & ~C & ~E) |
+            (~A & B & C & ~D & ~E) |
+            (A & ~B & C & D & ~E) |
+            (~A & ~B & C & D & E) |
+            (~A & ~B & ~C & D & ~E) }
+      i2 = {(B & ~C & ~D & ~E) |
+            (A & B & C & ~D) |
+            (~A & B & ~D & E) |
+            (~A & ~B & C & D) |
+            (~B & C & D & ~E) |
+            (~A & ~B & D & ~E) |
+            (A & B & ~C & D & E) |
+            (A & ~B & ~C & ~D & E) }
+      i3 = {(~A & ~B & C & ~D & ~E) |
+            (A & ~B & ~C & D & ~E) |
+            (~A & B & C & D & ~E) |
+            (~A & ~B & ~C & D & E) |
+            (A & ~B & C & D & E) |
+            (A & B & ~C & ~D & E) }
+      i4 = {(~C & ~D & E) |
+            (B & ~C & E) |
+            (~B & C & D & E) |
+            (A & ~C & E) |
+            (~B & ~C & D & ~E) |
+            (A & C & ~D & ~E) |
+            (B & C & ~D & ~E) |
+            (A & B & C & ~E) }
+      i5 = {(~C & ~D & E) |
+            (C & D & ~E) |
+            (B & D & ~E) |
+            (B & C & D) }
+      i6 = {((C & E) | (D & E))}
+      i7 = { (GBAR | ~GBAR) }
+      i8 = { (i7) }
+      Y1_O = { (i1 | GBAR) }
+      Y2_O = { (i2 | GBAR) }
+      Y3_O = { (i3 | GBAR) }
+      Y4_O = { (i4 | GBAR) }
+      Y5_O = { (i5 | GBAR) }
+      Y6_O = { (i6 | GBAR) }
+      Y7_O = { (i7 | GBAR) }
+      Y8_O = { (i8 | GBAR) }

Udly PINDLY (8,0,6) DPWR DGND
+      Y1_O Y2_O Y3_O Y4_O Y5_O Y6_O Y7_O Y8_O
+      A B C D E GBAR
+      Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8
+      IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+   BOOLEAN:
+      DATA= {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) |
+             CHANGED(E,0) }
+      EN = {CHANGED(GBAR,0)}
+
+   PINDLY:
+     Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8   = {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,27ns,40ns),
+                 DATA & TRN_HL, DELAY(-1,23ns,40ns),
+                 EN & TRN_LH, DELAY(-1,19ns,30ns),
+                 EN & TRN_HL, DELAY(-1,22ns,35ns),
+                 DELAY(-1,28ns,41ns)
+                )
+            }

.ENDS 74185A
*
*
* ----------------------------------------------------------- 74190 ------
*  Synchronous Up/Down Decade Counter with Down/Up Mode Control
*
*  The Standard TTL Data Book, 1988, TI Pages 2-619 to 2-631
*  jds    5/4/94
*
.SUBCKT 74190 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR 
+  QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74190 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR 
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      i3 = { (~(qbbar & qcbar & qdbar)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & i3 & qabar) | (QA_O & i1 & qdbar)}
+      jkc = { (i2 & i3 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QD_O & i1) |
+              (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_STD

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_STD

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_STD

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_STD

Udly PINDLY (6,0,7) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,13ns,20ns),
+                 CLOCK & TRN_HL, DELAY(-1,16ns,24ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,30ns,45ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,31ns,46ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(-1,22ns,33ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,33ns,50ns),
+                 DATA & TRN_LH, DELAY(-1,14ns,22ns),
+                 DATA & TRN_HL, DELAY(-1,35ns,50ns),
+                 CLOCK & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLOCK & TRN_HL, DELAY(-1,24ns,36ns),
+                 DELAY(-1,36ns,51ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,28ns,42ns),
+                 CLOCK & TRN_HL, DELAY(-1,37ns,52ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,21ns,33ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,22ns,33ns),
+                 DELAY(-1,38ns,53ns)
+                )
+            }

Ucnstr CONSTRAINT(7) DPWR DGND
+          CLK CTENBAR LOADBAR A B C D
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 35ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CTENBAR
+        SETUPTIME = 20ns


.ENDS 74190

*-------------------------------------------------------------74AC190------

* Up/Down Counter with Preset and Ripple Clock
* Motorola FACT Data, 1993, pages 5-144 to 5-150
* jat 8/27/96

.SUBCKT 74AC190
+ UBAR/D CEBAR CP PLBAR P0 P1 P2 P3 Q0 Q1 Q2 Q3 RCBAR TC
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,15) DPWR DGND
+ CP UBAR/D CEBAR P0 P1 P2 P3 PLBAR Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ CPBAR TCO RCBARO JK0 JK1 JK2 JK3 S0 S1 S2 S3 R0 R1 R2 R3
+ D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  NOR1 = {~UBAR/D & (~CEBAR)}
+  NOR2 = {UBAR/D & (~CEBAR)}
+  S0 = {~(P0 & ~PLBAR)}
+  R0 = {~(S0 & ~PLBAR)}
+  S1 = {~(P1 & ~PLBAR)}
+  R1 = {~(S1 & ~PLBAR)}
+  S2 = {~(P2 & ~PLBAR)}
+  R2 = {~(S2 & ~PLBAR)}
+  S3 = {~(P3 & ~PLBAR)}
+  R3 = {~(S3 & ~PLBAR)}
+  X = {~(Q3BARO & Q2BARO & Q1BARO)}
+  JK0 = {~CEBAR}
+  JK1 = {(NOR2 & Q0BARO & X) | (Q0O & Q3BARO & NOR1)}
+  JK2 = {(X & NOR2 & Q0BARO & Q1BARO) | (NOR1 & Q0O & Q1O)}
+  JK3 = {(NOR2 & Q0BARO & Q1BARO & Q2BARO) | (NOR1 & Q0O & Q3O) | (NOR1 & Q0O & Q1O & Q2O)}
+  CPBAR = {~CP}
+  TCO = {(~UBAR/D & Q0O & Q3O) | (UBAR/D & Q0BARO & Q1BARO & Q2BARO & Q3BARO)}
+  RCBARO = {~(TCO & ~CEBAR & ~CP)}

U2 JKFF(1) DPWR DGND
+ S0 R0 CPBAR
+ JK0 JK0 Q0O Q0BARO
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U3 JKFF(1) DPWR DGND
+ S1 R1 CPBAR
+ JK1 JK1 Q1O Q1BARO
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U4 JKFF(1) DPWR DGND
+ S2 R2 CPBAR
+ JK2 JK2 Q2O Q2BARO
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U5 JKFF(1) DPWR DGND
+ S3 R3 CPBAR
+ JK3 JK3 Q3O Q3BARO
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U6 PINDLY(6,0,8) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO RCBARO
+ CP P0 P1 P2 P3 PLBAR CEBAR UBAR/D
+ Q0 Q1 Q2 Q3 TC RCBAR
+ IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED(CP,0)}
+   DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED(CEBAR,0)}
+   UPDOWN = {CHANGED(UBAR/D,0)}
+ PINDLY:
+   Q0 Q1 Q2 Q3 = {
+    CASE(
+     LOAD & TRN_LH, DELAY(3NS,-1,10.5NS),
+     LOAD & TRN_HL, DELAY(2NS,-1,10.5NS),
+     DATA & TRN_LH, DELAY(2NS,-1,10NS),
+     DATA & TRN_HL, DELAY(2NS,-1,9.5NS),
+     EDGE & TRN_LH, DELAY(1.5NS,-1,9.5NS),
+     EDGE & TRN_HL, DELAY(1.5NS,-1,10NS),
+     DELAY(4NS,-1,11.5NS))}
+   TC = {
+    CASE(
+     UPDOWN & TRN_LH, DELAY(3NS,-1,8NS),
+     UPDOWN & TRN_HL, DELAY(3NS,-1,8NS),
+     EDGE & TRN_LH, DELAY(2.5NS,-1,11.5NS),
+     EDGE & TRN_HL, DELAY(2.5NS,-1,12.5NS),
+     DELAY(4NS,-1,13.5NS))}
+   RCBAR = {
+    CASE(
+     UPDOWN & TRN_LH, DELAY(1.5NS,-1,8.5NS),
+     UPDOWN & TRN_HL, DELAY(2.5NS,-1,8.5NS),
+     COUNT & TRN_LH, DELAY(1.5NS,-1,8NS),
+     COUNT & TRN_HL, DELAY(1.5NS,-1,8NS),
+     EDGE & TRN_LH, DELAY(2NS,-1,7.5NS),
+     EDGE & TRN_HL, DELAY(1.5NS,-1,8NS),
+     DELAY(3.5NS,-1,9.5NS))}

U7 CONSTRAINT(4) DPWR DGND
+ CP PLBAR CEBAR UBAR/D
+ IO_AC IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 110MEG
+ WIDTH:
+   NODE = PLBAR
+   MIN_LO = 3.5NS
+ WIDTH:
+   NODE = CP
+   MIN_LO = 3.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = CEBAR
+   SETUPTIME_LO = 4.5NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = UBAR/D
+   SETUPTIME = 5NS

.ENDS 74AC190

* ----------------------------------------------------------- 74ALS190 ------
*  Synchronous Up/Down Decade Counter with Down/Up Mode Control
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-213 to 2-220
*  jds    5/4/94
*
.SUBCKT 74ALS190 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS190 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR 
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      i3 = { (~(qbbar & qcbar & qdbar)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & i3 & qabar) | (QA_O & i1 & qdbar)}
+      jkc = { (i2 & i3 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QD_O & i1) |
+              (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_ALS00

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_ALS00

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_ALS00

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_ALS00

Udly PINDLY (6,0,8) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D CTENBAR LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     EN = { CHANGED(CTENBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(5ns,-1,20ns),
+                 CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                 UP/DOWN & TRN_LH, DELAY(15ns,-1,37ns),
+                 UP/DOWN & TRN_HL, DELAY(10ns,-1,28ns),
+                 EN & TRN_LH, DELAY(4ns,-1,18ns),
+                 EN & TRN_HL, DELAY(4ns,-1,18ns),
+                 DELAY(16ns,-1,38ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(8ns,-1,30ns),
+                 LOAD_DAT & TRN_HL, DELAY(8ns,-1,30ns),
+                 DATA & TRN_LH, DELAY(4ns,-1,21ns),
+                 DATA & TRN_HL, DELAY(4ns,-1,21ns),
+                 CLOCK & TRN_LH, DELAY(3ns,-1,18ns),
+                 CLOCK & TRN_HL, DELAY(3ns,-1,18ns),
+                 DELAY(9ns,-1,31ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(8ns,-1,31ns),
+                 CLOCK & TRN_HL, DELAY(8ns,-1,31ns),
+                 UP/DOWN & TRN_LH, DELAY(8ns,-1,25ns),
+                 UP/DOWN & TRN_HL, DELAY(8ns,-1,25ns),
+                 DELAY(9ns,-1,32ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK CTENBAR LOADBAR D/UBAR A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK 
+        DATA(1) = CTENBAR
+        SETUPTIME = 20ns
+        WHEN = { LOADBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CLK 
+        DATA(1) = D/UBAR
+        SETUPTIME = 20ns
+        WHEN = { (LOADBAR != '0) & ((CTENBAR != '1) ^ CHANGED(CTENBAR,0)) }

.ENDS 74ALS190
*
*
* ----------------------------------------------------------- 74F190 ------
*  Synchronous Up/Down Decade Counter with Down/Up Mode Control
*
*  The Fast TTL Logic Series Book, 1992, Philips Pages 263-270
*  jds    5/5/94
*
.SUBCKT 74F190 UBAR/D CP D0 D1 D2 D3 TC PLBAR CEBAR Q0 Q1 Q2 Q3 RCBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F190 LOGICEXP (16,15) DPWR DGND
+      UBAR/D CP D0 D1 D2 D3 PLBAR CEBAR 
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      RCBAR_O TC_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CP) }
+      load = {(~PLBAR)}
+      cten = {(~CEBAR)}
+      dbar/u = {(~UBAR/D)}
+      sa = { ~(D0 & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(D1 & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(D2 & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D3 & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(UBAR/D | CEBAR)) }
+      i2 = { (~(dbar/u | CEBAR)) }
+      i3 = { (~(q1bar & q2bar & q3bar)) }
+      TC_O = { (dbar/u & Q0_O & Q3_O) |
+                    (UBAR/D & q0bar & q1bar & q2bar & q3bar)}
+      RCBAR_O =  { ~(TC_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & i3 & q0bar) | (Q0_O & i1 & q3bar)}
+      jkc = { (i2 & i3 & q0bar & q1bar) | (Q0_O & Q1_O & i1)}
+      jkd = { (i2 & q0bar & q1bar & q2bar) | (Q0_O & Q3_O & i1) |
+              (Q0_O & Q1_O & Q2_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka Q0_O q0bar
+ D0_EFF IO_F

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb Q1_O q1bar
+ D0_EFF IO_F

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc Q2_O q2bar
+ D0_EFF IO_F

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd Q3_O q3bar
+ D0_EFF IO_F

Udly PINDLY (6,0,8) DPWR DGND
+    RCBAR_O Q0_O Q1_O Q2_O Q3_O TC_O
+    UBAR/D CP D0 D1 D2 D3 CEBAR PLBAR
+    RCBAR Q0 Q1 Q2 Q3 TC
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CP,0) }
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     UP/DOWN = { CHANGED(UBAR/D,0) }
+     EN = { CHANGED(CEBAR,0) }
+     DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)}
+
+    PINDLY:
+       RCBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2.5ns,4.5ns,7.5ns),
+                 CLOCK & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 UP/DOWN & TRN_LH, DELAY(8ns,11ns,16ns),
+                 UP/DOWN & TRN_HL, DELAY(4.5ns,7.5ns,10.5ns),
+                 EN & TRN_LH, DELAY(2ns,4ns,7ns),
+                 EN & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 DELAY(9ns,12ns,17ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(4.5ns,6.5ns,9.5ns),
+                 LOAD_DAT & TRN_HL, DELAY(5.5ns,8ns,11.5ns),
+                 DATA & TRN_LH, DELAY(2ns,4ns,7ns),
+                 DATA & TRN_HL, DELAY(6.5ns,9ns,12ns),
+                 CLOCK & TRN_LH, DELAY(2.5ns,4.5ns,8ns),
+                 CLOCK & TRN_HL, DELAY(5ns,7.5ns,11.5ns),
+                 DELAY(7.5ns,10ns,13ns)
+                )
+            }
+       TC = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(6.5ns,9ns,12.5ns),
+                 CLOCK & TRN_HL, DELAY(6ns,8ns,11ns),
+                 UP/DOWN & TRN_LH, DELAY(4ns,6.5ns,9.5ns),
+                 UP/DOWN & TRN_HL, DELAY(3ns,6ns,9.5ns),
+                 DELAY(7ns,9ns,13.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CP CEBAR PLBAR UBAR/D D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 95MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 3.5ns
+         MIN_LO = 6ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 6ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 4.5ns
+        HOLDTIME = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = CEBAR
+        SETUPTIME = 10ns
+        WHEN = { PLBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = PLBAR
+        RELEASETIME = 6ns
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = UBAR/D
+        SETUPTIME = 12ns
+        WHEN = { (PLBAR != '0) & ((CEBAR != '1) ^ CHANGED(CEBAR,0)) }

.ENDS 74F190
*
*
* ----------------------------------------------------------- 74F190A ------
*  Synchronous 4-Bit Up/Down Decade Counter with Reset And Ripple Clock
*
*  The F Data Book, 1994, TI Pages 2-145 to 2-150
*  bss    12/11/95
*
.SUBCKT 74F190A D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR 
+  QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

UF190A LOGICEXP(12,14) DPWR DGND
+  CTENBAR D/UBAR CLK LOADBAR A B C D qabar qbbar qcbar qdbar
+  MAX/MINO RCOBARO da db dc dd prea preb prec pred clra clrb clrc clrd
+  D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  LOGIC:
+     abar = {~A}
+     bbar = {~B}
+     cbar = {~C}
+     dbar = {~D}
+     clkbar = {~CLK}
+     dbaru = {~D/UBAR}
+     prea = {LOADBAR | abar}
+     preb = {LOADBAR | bbar}
+     prec = {LOADBAR | cbar}
+     pred = {LOADBAR | dbar}
+     clra = {LOADBAR | A}
+     clrb = {LOADBAR | B}
+     clrc = {LOADBAR | C}
+     clrd = {LOADBAR | D}
+     qain = {~qabar}
+     qbin = {~qbbar}
+     qcin = {~qcbar}
+     qdin = {~qdbar}
+     cten = {~CTENBAR}
+     da = {qain ^ cten}
+     MAX/MINO = {(qain & qdin & dbaru) | (qabar & qbbar & qcbar & qdbar & D/UBAR)}
+     RCOBARO = {~(MAX/MINO & cten & clkbar)}
+     nor1 = {~(CTENBAR | D/UBAR)}
+     nor2 = {~(CTENBAR | dbaru)}
+     nand1 = {~(qbbar & qcbar & qdbar)}
+     xorb1 = {(qain & qdbar) ^ qbin}
+     xorb2 = {(qabar & nand1) ^ qbin}
+     xorc1 = {(qain & qbin) ^ qcin}
+     xorc2 = {(nand1 & qabar & qbbar) ^ qcin}
+     xord1 = {(qabar & qdin) ^ (qain & qbin & qcin & qdbar)}
+     xord2 = {(qabar & qbbar & qcbar) ^ qdin}
+     db = {(xorb1 & nor1) | (CTENBAR & qbin) | (xorb2 & nor2)}
+     dc = {(xorc1 & nor1) | (CTENBAR & qcin) | (xorc2 & nor2)}
+     dd = {(xord1 & nor1) | (CTENBAR & qdin) | (xord2 & nor2)}

U2 DFF(1) DPWR DGND
+  prea clra CLK da QA_O qabar
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+  preb clrb CLK db QB_O qbbar
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+  prec clrc CLK dc QC_O qcbar
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+  pred clrd CLK dd QD_O qdbar
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(6,0,8) DPWR DGND
+ MAX/MINO RCOBARO QA_O QB_O QC_O QD_O
+ CLK CTENBAR D/UBAR A B C D LOADBAR
+ MAX/MIN RCOBAR QA QB QC QD
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED(CLK,0)}
+    ENABLE = {CHANGED(CTENBAR,0)}
+    UPDOWN = {CHANGED(D/UBAR,0)}
+    DATA = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0)}
+    LOAD = {CHANGED(LOADBAR,0)}
+ PINDLY:
+    QA QB QC QD = {
+       CASE(
+          LOAD & TRN_LH, DELAY(4.5NS,7.7NS,9.8NS),
+          LOAD & TRN_HL, DELAY(5.5NS,9.9NS,12.1NS),
+          DATA & TRN_LH, DELAY(2NS,4.7NS,4NS),
+          DATA & TRN_HL, DELAY(6.5NS,8.9NS,12NS),
+          EDGE & TRN_LH, DELAY(2.5NS,4.8NS,8NS),
+          EDGE & TRN_HL, DELAY(5NS,7NS,11.5NS),
+          DELAY(7.5NS,10.9NS,13.1NS))}
+    MAX/MIN = {
+        CASE(
+          LOAD & TRN_LH, DELAY(5.5NS,12.3NS,15.2NS),
+          LOAD & TRN_HL, DELAY(6NS,11.7NS,14NS),
+          UPDOWN & TRN_LH, DELAY(4NS,7.9NS,9.8NS),
+          UPDOWN & TRN_HL, DELAY(3NS,7.5NS,9.5NS),
+          DATA & TRN_LH, DELAY(5.5NS,10.5NS,13.6NS),
+          DATA & TRN_HL, DELAY(6.5NS,10NS,13NS),
+          EDGE & TRN_LH, DELAY(6.5NS,9.4NS,12.5NS),
+          EDGE & TRN_HL, DELAY(6NS,8.9NS,11NS),
+          DELAY(7.5NS,13.3NS,16.2NS))}
+    RCOBAR = {
+        CASE(
+          ENABLE & TRN_LH, DELAY(2NS,5.7NS,7NS),
+          ENABLE & TRN_HL, DELAY(3NS,5NS,7.5NS),
+          LOAD & TRN_LH, DELAY(8.5NS,16.8NS,19.9NS),
+          LOAD & TRN_HL, DELAY(7.5NS,11.6NS,14NS),
+          UPDOWN & TRN_LH, DELAY(8NS,13NS,16NS),
+          UPDOWN & TRN_HL, DELAY(4.5NS,8.1NS,10.5NS),
+          DATA & TRN_LH, DELAY(6NS,15NS,18.6NS),
+          DATA & TRN_HL, DELAY(6NS,9.5NS,13.5NS),
+          EDGE & TRN_LH, DELAY(2.5NS,5.2NS,7.5NS),
+          EDGE & TRN_HL, DELAY(3NS,4.8NS,7.5NS),
+          DELAY(9.5NS,17.8NS,20.9NS))}

U7 CONSTRAINT(8) DPWR DGND
+ LOADBAR CLK CTENBAR D/UBAR A B C D
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = CLK
+    MAXFREQ = 90MEG
+ WIDTH:
+    NODE =  LOADBAR
+    MIN_LO = 6NS
+ WIDTH:
+    NODE =  CLK
+    MIN_LO = 7NS
+    MIN_HI = 4NS
+ SETUP_HOLD:
+   CLOCK LH = LOADBAR
+   DATA(4) = A B C D
+   SETUPTIME = 4NS
+   HOLDTIME = 2NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = CTENBAR
+   SETUPTIME = 6.5NS
+   HOLDTIME = 1NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = D/UBAR
+   SETUPTIME = 15NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = LOADBAR
+   SETUPTIME_HI = 10NS

.ENDS 74F190A

* ----------------------------------------------------------- 74HC190 ------
*  Synchronous Up/Down Decade Counter with Down/Up Mode Control
*
*  High Speed CMOS Logic Data Book 1989, TI Pages 2-263 to 2-270
*  jds    5/5/94
*
.SUBCKT 74HC190 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC190 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR 
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      i3 = { (~(qbbar & qcbar & qdbar)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & i3 & qabar) | (QA_O & i1 & qdbar)}
+      jkc = { (i2 & i3 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QD_O & i1) |
+              (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_HC

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_HC

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_HC

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_HC

Udly PINDLY (6,0,7) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,17ns,24ns),
+                 CLOCK & TRN_HL, DELAY(-1,17ns,24ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,29ns,46ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,29ns,46ns),
+                 DELAY(-1,30ns,47ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(-1,40ns,53ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,40ns,53ns),
+                 DATA & TRN_LH, DELAY(-1,36ns,48ns),
+                 DATA & TRN_HL, DELAY(-1,36ns,48ns),
+                 CLOCK & TRN_LH, DELAY(-1,31ns,38ns),
+                 CLOCK & TRN_HL, DELAY(-1,31ns,38ns),
+                 DELAY(-1,41ns,54ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,39ns,50ns),
+                 CLOCK & TRN_HL, DELAY(-1,39ns,50ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,24ns,38ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,24ns,38ns),
+                 DELAY(-1,40ns,51ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK CTENBAR LOADBAR A B C D D/UBAR
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 21MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 24ns
+         MIN_LO = 24ns    
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 24ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 30ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CTENBAR
+        SETUPTIME = 41ns
+        HOLDTIME = 5ns 
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = D/UBAR
+        SETUPTIME = 41ns
+        HOLDTIME = 5ns

.ENDS 74HC190

*-------------------------------------------------------------74HCT190------

* Presettable Synchronous BCD Decade Up/Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 409 to 418
* jat 9/10/96

.SUBCKT 74HCT190
+ UBAR/D CEBAR CP PLBAR D0 D1 D2 D3 Q0 Q1 Q2 Q3 RCBAR TC
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,15) DPWR DGND
+ CP UBAR/D CEBAR D0 D1 D2 D3 PLBAR Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ CPBAR TCO RCBARO JK0 JK1 JK2 JK3 S0 S1 S2 S3 R0 R1 R2 R3
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  NOR1 = {~UBAR/D & (~CEBAR)}
+  NOR2 = {UBAR/D & (~CEBAR)}
+  S0 = {~(D0 & ~PLBAR)}
+  R0 = {~(S0 & ~PLBAR)}
+  S1 = {~(D1 & ~PLBAR)}
+  R1 = {~(S1 & ~PLBAR)}
+  S2 = {~(D2 & ~PLBAR)}
+  R2 = {~(S2 & ~PLBAR)}
+  S3 = {~(D3 & ~PLBAR)}
+  R3 = {~(S3 & ~PLBAR)}
+  X = {~(Q3BARO & Q2BARO & Q1BARO)}
+  JK0 = {~CEBAR}
+  JK1 = {(NOR2 & Q0BARO & X) | (Q0O & Q3BARO & NOR1)}
+  JK2 = {(X & NOR2 & Q0BARO & Q1BARO) | (NOR1 & Q0O & Q1O)}
+  JK3 = {(NOR2 & Q0BARO & Q1BARO & Q2BARO) | (NOR1 & Q0O & Q3O) | (NOR1 & Q0O & Q1O & Q2O)}
+  CPBAR = {~CP}
+  TCO = {(~UBAR/D & Q0O & Q3O) | (UBAR/D & Q0BARO & Q1BARO & Q2BARO & Q3BARO)}
+  RCBARO = {~(TCO & ~CEBAR & ~CP)}

U2 JKFF(1) DPWR DGND
+ S0 R0 CPBAR
+ JK0 JK0 Q0O Q0BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U3 JKFF(1) DPWR DGND
+ S1 R1 CPBAR
+ JK1 JK1 Q1O Q1BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U4 JKFF(1) DPWR DGND
+ S2 R2 CPBAR
+ JK2 JK2 Q2O Q2BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U5 JKFF(1) DPWR DGND
+ S3 R3 CPBAR
+ JK3 JK3 Q3O Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U6 PINDLY(6,0,8) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO RCBARO
+ CP D0 D1 D2 D3 PLBAR CEBAR UBAR/D
+ Q0 Q1 Q2 Q3 TC RCBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED(CP,0)}
+   DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED(CEBAR,0)}
+   UPDOWN = {CHANGED(UBAR/D,0)}
+ PINDLY:
+   Q0 Q1 Q2 Q3 = {
+    CASE(
+     LOAD & TRN_LH, DELAY(-1,29NS,49NS),
+     LOAD & TRN_HL, DELAY(-1,29NS,49NS),
+     DATA & TRN_LH, DELAY(-1,24NS,44NS),
+     DATA & TRN_HL, DELAY(-1,24NS,44NS),
+     EDGE & TRN_LH, DELAY(-1,28NS,48NS),
+     EDGE & TRN_HL, DELAY(-1,28NS,48NS),
+     DELAY(-1,30NS,50NS))}
+   TC = {
+    CASE(
+     UPDOWN & TRN_LH, DELAY(-1,24NS,45NS),
+     UPDOWN & TRN_HL, DELAY(-1,24NS,45NS),
+     EDGE & TRN_LH, DELAY(-1,34NS,58NS),
+     EDGE & TRN_HL, DELAY(-1,34NS,58NS),
+     DELAY(-1,35NS,59NS))}
+   RCBAR = {
+    CASE(
+     UPDOWN & TRN_LH, DELAY(-1,26NS,45NS),
+     UPDOWN & TRN_HL, DELAY(-1,26NS,45NS),
+     COUNT & TRN_LH, DELAY(-1,18NS,33NS),
+     COUNT & TRN_HL, DELAY(-1,18NS,33NS),
+     EDGE & TRN_LH, DELAY(-1,20NS,35NS),
+     EDGE & TRN_HL, DELAY(-1,20NS,35NS),
+     DELAY(-1,27NS,46NS))}

U7 CONSTRAINT(8) DPWR DGND
+ CP PLBAR CEBAR UBAR/D D0 D1 D2 D3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 27MEG
+ WIDTH:
+   NODE = PLBAR
+   MIN_LO = 12NS
+ WIDTH:
+   NODE = CP
+   MIN_LO = 10NS
+   MIN_HI = 10NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = CEBAR
+   SETUPTIME = 18NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = UBAR/D
+   SETUPTIME = 25NS
+ SETUP_HOLD:
+   CLOCK LH = PLBAR
+   DATA(4) = D0 D1 D2 D3
+   SETUPTIME = 10NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = PLBAR
+   SETUPTIME_HI = 1NS

.ENDS 74HCT190

* ----------------------------------------------------------- 74LS190 ------
*  Synchronous Up/Down Decade Counter with Down/Up Mode Control
*
*  The Standard TTL Logic Data Book, 1988, TI Pages 2-263 to 2-270
*  jds    5/6/94
*
.SUBCKT 74LS190 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS190 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR 
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      i3 = { (~(qbbar & qcbar & qdbar)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & i3 & qabar) | (QA_O & i1 & qdbar)}
+      jkc = { (i2 & i3 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QD_O & i1) |
+              (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_LS

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_LS

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_LS

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_LS

Udly PINDLY (6,0,7) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,13ns,20ns),
+                 CLOCK & TRN_HL, DELAY(-1,16ns,24ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,30ns,45ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,31ns,46ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(-1,22ns,33ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,33ns,50ns),
+                 DATA & TRN_LH, DELAY(-1,20ns,32ns),
+                 DATA & TRN_HL, DELAY(-1,27ns,40ns),
+                 CLOCK & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLOCK & TRN_HL, DELAY(-1,24ns,36ns),
+                 DELAY(-1,34ns,51ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,28ns,42ns),
+                 CLOCK & TRN_HL, DELAY(-1,37ns,52ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,21ns,33ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,22ns,33ns),
+                 DELAY(-1,38ns,53ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK CTENBAR LOADBAR A B C D D/UBAR
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns   
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 35ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CTENBAR
+        SETUPTIME = 40ns

.ENDS 74LS190
*
*
* ----------------------------------------------------------- 74191 ------
*  Synchronous Up/Down Binary Counter with Down/Up Mode Control
*
*  The Standard TTL Data Book, 1988, TI Pages 2-619 to 2-631
*  jds    5/6/94
*
.SUBCKT 74191 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74191 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QB_O & QC_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & qabar) | (QA_O & i1)}
+      jkc = { (i2 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_STD

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_STD

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_STD

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_STD

Udly PINDLY (6,0,7) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,13ns,20ns),
+                 CLOCK & TRN_HL, DELAY(-1,16ns,24ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,30ns,45ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,31ns,46ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(-1,22ns,33ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,33ns,50ns),
+                 DATA & TRN_LH, DELAY(-1,14ns,22ns),
+                 DATA & TRN_HL, DELAY(-1,35ns,50ns),
+                 CLOCK & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLOCK & TRN_HL, DELAY(-1,24ns,36ns),
+                 DELAY(-1,36ns,51ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,28ns,42ns),
+                 CLOCK & TRN_HL, DELAY(-1,37ns,52ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,21ns,33ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,22ns,33ns),
+                 DELAY(-1,38ns,53ns)
+                )
+            }

Ucnstr CONSTRAINT(7) DPWR DGND
+          CLK CTENBAR LOADBAR A B C D
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 35ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CTENBAR
+        SETUPTIME = 20ns

.ENDS 74191
*
*
* ----------------------------------------------------------- 74AC191 ------
*  Synchronous Up/Down Binary Counter with Down/Up Mode Control
*
*  The FACT Advanced CMOS Logic Databook, 1989, National Semiconductor
*  jds    5/6/94                                                        Pages 4-119 to 4-125
*
.SUBCKT 74AC191 UBAR/D CP P0 P1 P2 P3 TC PLBAR CEBAR Q0 Q1 Q2 Q3 RCBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC191 LOGICEXP (16,15) DPWR DGND
+      UBAR/D CP P0 P1 P2 P3 PLBAR CEBAR 
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      RCBAR_O TC_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CP) }
+      load = {(~PLBAR)}
+      cten = {(~CEBAR)}
+      dbar/u = {(~UBAR/D)}
+      sa = { ~(P0 & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(P1 & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(P2 & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(P3 & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(UBAR/D | CEBAR)) }
+      i2 = { (~(dbar/u | CEBAR)) }
+      TC_O = { (dbar/u & Q0_O & Q1_O & Q2_O & Q3_O) |
+                    (UBAR/D & q0bar & q1bar & q2bar & q3bar)}
+      RCBAR_O =  { ~(TC_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & q0bar) | (Q0_O & i1)}
+      jkc = { (i2 & q0bar & q1bar) | (Q0_O & Q1_O & i1)}
+      jkd = { (i2 & q0bar & q1bar & q2bar) | (Q0_O & Q1_O & Q2_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka Q0_O q0bar
+ D0_EFF IO_AC

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb Q1_O q1bar
+ D0_EFF IO_AC

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc Q2_O q2bar
+ D0_EFF IO_AC

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd Q3_O q3bar
+ D0_EFF IO_AC

Udly PINDLY (6,0,8) DPWR DGND
+    RCBAR_O Q0_O Q1_O Q2_O Q3_O TC_O
+    UBAR/D CP P0 P1 P2 P3 CEBAR PLBAR
+    RCBAR Q0 Q1 Q2 Q3 TC 
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CP,0) }
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     UP/DOWN = { CHANGED(UBAR/D,0) }
+     EN = { CHANGED(CEBAR,0) }
+     DATA = {CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0)}
+
+    PINDLY:
+       RCBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2ns,5.5ns,9.5ns),
+                 CLOCK & TRN_HL, DELAY(1.5ns,5ns,8.5ns),
+                 UP/DOWN & TRN_LH, DELAY(1.5ns,5ns,9ns),
+                 UP/DOWN & TRN_HL, DELAY(1.5ns,5ns,8.5ns),
+                 EN & TRN_LH, DELAY(1.5ns,5ns,8.5ns),
+                 EN & TRN_HL, DELAY(1.5ns,5ns,8ns),
+                 DELAY(3ns,6ns,10.5ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(2ns,5.5ns,9.5ns),
+                 LOAD_DAT & TRN_HL, DELAY(2ns,6ns,10ns),
+                 DATA & TRN_LH, DELAY(2ns,5.5ns,9.5ns),
+                 DATA & TRN_HL, DELAY(1.5ns,9.5ns,9.5ns),
+                 CLOCK & TRN_LH, DELAY(1.5ns,6ns,11ns),
+                 CLOCK & TRN_HL, DELAY(1.5ns,6ns,10.5ns),
+                 DELAY(3ns,10.5ns,12ns)
+                )
+            }
+       TC = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2.5ns,7.5ns,12ns),
+                 CLOCK & TRN_HL, DELAY(2.5ns,7.5ns,12.5ns),
+                 UP/DOWN & TRN_LH, DELAY(1.5ns,5ns,8.5ns),
+                 UP/DOWN & TRN_HL, DELAY(1.5ns,5ns,8.5ns),
+                 DELAY(3.5ns,8.5ns,13.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CP CEBAR PLBAR UBAR/D P0 P1 P2 P3
+          IO_AC
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 133MEG
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 1ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = .5ns
+        HOLDTIME = .5ns
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = CEBAR
+        SETUPTIME = 1.5ns
+        HOLDTIME = 2.5ns
+        WHEN = { PLBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = PLBAR
+        RELEASETIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = UBAR/D
+        SETUPTIME = 2.5ns
+        HOLDTIME = 3ns
+        WHEN = { (PLBAR != '0) & ((CEBAR != '1) ^ CHANGED(CEBAR,0)) }

.ENDS 74AC191
*
*
*-------------------------------------------------------------74ACT191------

* Synchronous 4 Bit Up/Down Binary Counter
* TI Advanced CMOS Logic Databook, 1993, pages 2-245 to 2-251
* jat 12/20/95

.SUBCKT 74ACT191
+ CTENBAR D/UBAR CLK LOADBAR A B C D MAX/MIN RCOBAR QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,14) DPWR DGND
+ CTENBAR D/UBAR LOADBAR A B C D QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO CLK
+ SA RA SB RB SC RC SD RD DA DB DC DD MAX/MINO RCOBARO
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  NOR1 = {D/UBAR & (~CTENBAR)}
+  NOR2 = {(~D/UBAR) & (~CTENBAR)}
+  SA = {~(A & (~LOADBAR))}
+  RA = {~((~A) & (~LOADBAR))}
+  SB = {~(B & (~LOADBAR))}
+  RB = {~((~B) & (~LOADBAR))}
+  SC = {~(C & (~LOADBAR))}
+  RC = {~((~C) & (~LOADBAR))}
+  SD = {~(D & (~LOADBAR))}
+  RD = {~((~D) & (~LOADBAR))}
+  DA = {(~CTENBAR) ^ QAO}
+  DB = {(NOR2 & (QAO ^ QBO)) | (CTENBAR & QBO) | (NOR1 & (QBO ^ QABARO))}
+  XORC1 = {(QAO & QBO) ^ QCO}
+  XORC2 = {QCO ^ (QABARO & QBBARO)}
+  DC = {(NOR2 & XORC1) | (CTENBAR & QCO) | (NOR1 & XORC2)}
+  XORD1 = {QDO ^ (QAO & QBO & QCO)}
+  XORD2 = {QDO ^ (QABARO & QBBARO & QCBARO)}
+  DD = {(NOR2 & XORD1) | (CTENBAR & QDO) | (NOR1 & XORD2)}
+  MAX/MINO = {(QAO & QBO & QCO & QDO & (~D/UBAR)) | (QABARO & QBBARO & QCBARO &
+              QDBARO & D/UBAR)}
+  RCOBARO = {~(MAX/MINO & (~CTENBAR) & (~CLK))}

U2 DFF(1) DPWR DGND
+ SA RA CLK
+ DA QAO QABARO
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U3 DFF(1) DPWR DGND
+ SB RB CLK
+ DB QBO QBBARO
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U4 DFF(1) DPWR DGND
+ SC RC CLK
+ DC QCO QCBARO
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U5 DFF(1) DPWR DGND
+ SD RD CLK
+ DD QDO QDBARO
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U6 PINDLY(6,0,8) DPWR DGND
+ QAO QBO QCO QDO MAX/MINO RCOBARO
+ LOADBAR A B C D CLK D/UBAR CTENBAR
+ QA QB QC QD MAX/MIN RCOBAR
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   LOAD = {CHANGED(LOADBAR,0)}
+   JAM = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0)}
+   CLOCK = {CHANGED(CLK,0)}
+   UPDOWN = {CHANGED(D/UBAR,0)}
+   COUNT = {CHANGED(CTENBAR,0)}
+ PINDLY:
+   QA QB QC QD = {
+     CASE(
+       LOAD & TRN_LH, DELAY(4NS,7.6NS,10.8NS),
+       LOAD & TRN_HL, DELAY(3.8NS,7.4NS,10.5NS),
+       JAM & TRN_LH, DELAY(4.5NS,7.6NS,10.1NS),
+       JAM & TRN_HL, DELAY(3.7NS,7.1NS,10.3NS),
+       CLOCK & TRN_LH, DELAY(3.6NS,6.7NS,9.2NS),
+       CLOCK & TRN_HL, DELAY(4.2NS,7.1NS,9.4NS),
+       DELAY(5.5NS,8.6NS,11.8NS))}
+   MAX/MIN = {
+      CASE(
+       LOAD & TRN_LH, DELAY(5.2NS,9.7NS,13.9NS),
+       LOAD & TRN_HL, DELAY(4.7NS,9.5NS,13.6NS),
+       JAM & TRN_LH, DELAY(5.1NS,9.5NS,13.6NS),
+       JAM & TRN_HL, DELAY(4.7NS,9.2NS,13.4NS),
+       UPDOWN & TRN_LH, DELAY(3.2NS,6.9NS,9.6NS),
+       UPDOWN & TRN_HL, DELAY(3.6NS,7.2NS,10.3NS),
+       CLOCK & TRN_LH, DELAY(5NS,8NS,10.3NS),
+       CLOCK & TRN_HL, DELAY(5.3NS,8.6NS,11.5NS),
+       DELAY(6.3NS,10.7NS,14.9NS))}
+   RCOBAR = {
+      CASE(
+       LOAD & TRN_LH, DELAY(5.4NS,10.5NS,15.1NS),
+       LOAD & TRN_HL, DELAY(5.8NS,11NS,15.7NS),
+       JAM & TRN_LH, DELAY(5.5NS,10.3NS,14.8NS),
+       JAM & TRN_HL, DELAY(5.9NS,10.9NS,15.5NS),
+       COUNT & TRN_LH, DELAY(3.9NS,6.4NS,8.2NS),
+       COUNT & TRN_HL, DELAY(2.8NS,6NS,8.4NS),
+       UPDOWN & TRN_LH, DELAY(4.4NS,8.4NS,11.7NS),
+       UPDOWN & TRN_HL, DELAY(4.2NS,8.8NS,11.3NS),
+       CLOCK & TRN_LH, DELAY(4.4NS,7.4NS,9.5NS),
+       CLOCK & TRN_HL, DELAY(3.5NS,6.7NS,9.2NS),
+       DELAY(6.9NS,12NS,16.7NS))}

U7 CONSTRAINT(8) DPWR DGND
+ LOADBAR CLK A B C D CTENBAR D/UBAR
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 65MEG
+ WIDTH:
+   NODE = LOADBAR
+   MIN_LO = 4NS
+ WIDTH:
+   NODE = CLK
+   MIN_LO = 7.7NS
+   MIN_HI = 7.7NS
+ SETUP_HOLD:
+   CLOCK HL = LOADBAR
+   DATA(4) = A B C D
+   SETUPTIME = 3NS
+   HOLDTIME = 2.5NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = CTENBAR
+   SETUPTIME = 7.5NS
+   HOLDTIME = 1.5NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = D/UBAR
+   SETUPTIME = 8.5NS
+   HOLDTIME = 0.5NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = LOADBAR
+   SETUPTIME = 2NS

.ENDS 74ACT191

* ----------------------------------------------------------- 74ALS191 ------
*  Synchronous Up/Down Binary Counter with Down/Up Mode Control
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-213 to 2-220
*  jds    5/4/94
*
.SUBCKT 74ALS191 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS191 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR 
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QB_O & QC_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & qabar) | (QA_O & i1)}
+      jkc = { (i2 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_ALS00

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_ALS00

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_ALS00

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_ALS00

Udly PINDLY (6,0,8) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D CTENBAR LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     EN = { CHANGED(CTENBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(5ns,-1,20ns),
+                 CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                 UP/DOWN & TRN_LH, DELAY(15ns,-1,37ns),
+                 UP/DOWN & TRN_HL, DELAY(10ns,-1,28ns),
+                 EN & TRN_LH, DELAY(4ns,-1,18ns),
+                 EN & TRN_HL, DELAY(4ns,-1,18ns),
+                 DELAY(16ns,-1,38ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(8ns,-1,30ns),
+                 LOAD_DAT & TRN_HL, DELAY(8ns,-1,30ns),
+                 DATA & TRN_LH, DELAY(4ns,-1,21ns),
+                 DATA & TRN_HL, DELAY(4ns,-1,21ns),
+                 CLOCK & TRN_LH, DELAY(3ns,-1,18ns),
+                 CLOCK & TRN_HL, DELAY(3ns,-1,18ns),
+                 DELAY(9ns,-1,31ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(8ns,-1,31ns),
+                 CLOCK & TRN_HL, DELAY(8ns,-1,31ns),
+                 UP/DOWN & TRN_LH, DELAY(8ns,-1,25ns),
+                 UP/DOWN & TRN_HL, DELAY(8ns,-1,25ns),
+                 DELAY(9ns,-1,32ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK CTENBAR LOADBAR D/UBAR A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK 
+        DATA(1) = CTENBAR
+        SETUPTIME = 20ns
+        WHEN = { LOADBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CLK 
+        DATA(1) = D/UBAR
+        SETUPTIME = 20ns
+        WHEN = { (LOADBAR != '0) & ((CTENBAR != '1) ^ CHANGED(CTENBAR,0)) }

.ENDS 74ALS191
*
*
* ----------------------------------------------------------- 74F191 ------
*  Synchronous Up/Down Binary Counter with Down/Up Mode Control
*
*  The Fast TTL Logic Series Book, 1992, Philips Pages 263-270
*  jds    5/5/94
*
.SUBCKT 74F191 UBAR/D CP D0 D1 D2 D3 TC PLBAR CEBAR Q0 Q1 Q2 Q3 RCBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F191 LOGICEXP (16,15) DPWR DGND
+      UBAR/D CP D0 D1 D2 D3 PLBAR CEBAR 
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      RCBAR_O TC_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CP) }
+      load = {(~PLBAR)}
+      cten = {(~CEBAR)}
+      dbar/u = {(~UBAR/D)}
+      sa = { ~(D0 & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(D1 & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(D2 & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D3 & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(UBAR/D | CEBAR)) }
+      i2 = { (~(dbar/u | CEBAR)) }
+      TC_O = { (dbar/u & Q0_O & Q1_O & Q2_O & Q3_O) |
+                    (UBAR/D & q0bar & q1bar & q2bar & q3bar)}
+      RCBAR_O =  { ~(TC_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & q0bar) | (Q0_O & i1)}
+      jkc = { (i2 & q0bar & q1bar) | (Q0_O & Q1_O & i1)}
+      jkd = { (i2 & q0bar & q1bar & q2bar) | (Q0_O & Q1_O & Q2_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka Q0_O q0bar
+ D0_EFF IO_F

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb Q1_O q1bar
+ D0_EFF IO_F

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc Q2_O q2bar
+ D0_EFF IO_F

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd Q3_O q3bar
+ D0_EFF IO_F

Udly PINDLY (6,0,8) DPWR DGND
+    RCBAR_O Q0_O Q1_O Q2_O Q3_O TC_O
+    UBAR/D CP D0 D1 D2 D3 CEBAR PLBAR
+    RCBAR Q0 Q1 Q2 Q3 TC
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CP,0) }
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     UP/DOWN = { CHANGED(UBAR/D,0) }
+     EN = { CHANGED(CEBAR,0) }
+     DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)}
+
+    PINDLY:
+       RCBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(2.5ns,4.5ns,7.5ns),
+                 CLOCK & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 UP/DOWN & TRN_LH, DELAY(8ns,11ns,16ns),
+                 UP/DOWN & TRN_HL, DELAY(4.5ns,7.5ns,10.5ns),
+                 EN & TRN_LH, DELAY(2ns,4ns,7ns),
+                 EN & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 DELAY(9ns,12ns,17ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(4.5ns,6.5ns,9.5ns),
+                 LOAD_DAT & TRN_HL, DELAY(5.5ns,8ns,11.5ns),
+                 DATA & TRN_LH, DELAY(2ns,4ns,7ns),
+                 DATA & TRN_HL, DELAY(6.5ns,9ns,12ns),
+                 CLOCK & TRN_LH, DELAY(2.5ns,4.5ns,8ns),
+                 CLOCK & TRN_HL, DELAY(5ns,7.5ns,11.5ns),
+                 DELAY(7.5ns,10ns,13ns)
+                )
+            }
+       TC = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(6.5ns,9ns,12.5ns),
+                 CLOCK & TRN_HL, DELAY(6ns,8ns,11ns),
+                 UP/DOWN & TRN_LH, DELAY(4ns,6.5ns,9.5ns),
+                 UP/DOWN & TRN_HL, DELAY(3ns,6ns,9.5ns),
+                 DELAY(7ns,9ns,13.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CP CEBAR PLBAR UBAR/D D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 95MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 3.5ns
+         MIN_LO = 6ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 6ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 4.5ns
+        HOLDTIME = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = CEBAR
+        SETUPTIME = 10ns
+        WHEN = { PLBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = PLBAR
+        RELEASETIME = 6ns
+      SETUP_HOLD:
+        CLOCK LH = CP 
+        DATA(1) = UBAR/D
+        SETUPTIME = 12ns
+        WHEN = { (PLBAR != '0) & ((CEBAR != '1) ^ CHANGED(CEBAR,0)) }

.ENDS 74F191
*
*
* ----------------------------------------------------------- 74HC191 ------
*  Synchronous Up/Down Binary Counter with Down/Up Mode Control
*
*  High Speed CMOS Logic Data Book 1989, TI Pages 2-263 to 2-270
*  jds    5/6/94
*
.SUBCKT 74HC191 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC191 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR 
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QB_O & QC_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & qabar) | (QA_O & i1)}
+      jkc = { (i2 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_HC

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_HC

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_HC

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_HC

Udly PINDLY (6,0,7) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,17ns,24ns),
+                 CLOCK & TRN_HL, DELAY(-1,17ns,24ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,29ns,46ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,29ns,46ns),
+                 DELAY(-1,30ns,47ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(-1,40ns,53ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,40ns,53ns),
+                 DATA & TRN_LH, DELAY(-1,36ns,48ns),
+                 DATA & TRN_HL, DELAY(-1,36ns,48ns),
+                 CLOCK & TRN_LH, DELAY(-1,31ns,38ns),
+                 CLOCK & TRN_HL, DELAY(-1,31ns,38ns),
+                 DELAY(-1,41ns,54ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,39ns,50ns),
+                 CLOCK & TRN_HL, DELAY(-1,39ns,50ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,24ns,38ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,24ns,38ns),
+                 DELAY(-1,40ns,51ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK CTENBAR LOADBAR A B C D D/UBAR
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 21MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 24ns
+         MIN_LO = 24ns    
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 24ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 30ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CTENBAR
+        SETUPTIME = 41ns
+        HOLDTIME = 5ns 
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = D/UBAR
+        SETUPTIME = 41ns
+        HOLDTIME = 5ns

.ENDS 74HC191

*-------------------------------------------------------------74HCT191------

* Presettable Synchronous 4-Bit Binary Up/Down Counter
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 419 to 428
* jat 9/10/96

.SUBCKT 74HCT191
+ UBAR/D CEBAR CP PLBAR D0 D1 D2 D3 Q0 Q1 Q2 Q3 RCBAR TC
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,15) DPWR DGND
+ CP UBAR/D CEBAR D0 D1 D2 D3 PLBAR Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ CPBAR TCO RCBARO JK0 JK1 JK2 JK3 S0 S1 S2 S3 R0 R1 R2 R3
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  NOR1 = {~UBAR/D & (~CEBAR)}
+  NOR2 = {UBAR/D & (~CEBAR)}
+  S0 = {~(D0 & ~PLBAR)}
+  R0 = {~(S0 & ~PLBAR)}
+  S1 = {~(D1 & ~PLBAR)}
+  R1 = {~(S1 & ~PLBAR)}
+  S2 = {~(D2 & ~PLBAR)}
+  R2 = {~(S2 & ~PLBAR)}
+  S3 = {~(D3 & ~PLBAR)}
+  R3 = {~(S3 & ~PLBAR)}
+  JK0 = {~CEBAR}
+  JK1 = {(NOR2 & Q0BARO) | (Q0O & NOR1)}
+  JK2 = {(NOR2 & Q0BARO & Q1BARO) | (NOR1 & Q0O & Q1O)}
+  JK3 = {(NOR2 & Q0BARO & Q1BARO & Q2BARO) | (NOR1 & Q0O & Q1O & Q2O)}
+  CPBAR = {~CP}
+  TCO = {(~UBAR/D & Q0O & Q1O & Q2O & Q3O) | (UBAR/D & Q0BARO & Q1BARO & Q2BARO & Q3BARO)}
+  RCBARO = {~(TCO & ~CEBAR & ~CP)}

U2 JKFF(1) DPWR DGND
+ S0 R0 CPBAR
+ JK0 JK0 Q0O Q0BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U3 JKFF(1) DPWR DGND
+ S1 R1 CPBAR
+ JK1 JK1 Q1O Q1BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U4 JKFF(1) DPWR DGND
+ S2 R2 CPBAR
+ JK2 JK2 Q2O Q2BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U5 JKFF(1) DPWR DGND
+ S3 R3 CPBAR
+ JK3 JK3 Q3O Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}  

U6 PINDLY(6,0,8) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO RCBARO
+ CP D0 D1 D2 D3 PLBAR CEBAR UBAR/D
+ Q0 Q1 Q2 Q3 TC RCBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED(CP,0)}
+   DATA = {CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0)}
+   LOAD = {CHANGED_HL(PLBAR,0)}
+   COUNT = {CHANGED(CEBAR,0)}
+   UPDOWN = {CHANGED(UBAR/D,0)}
+ PINDLY:
+   Q0 Q1 Q2 Q3 = {
+    CASE(
+     LOAD & TRN_LH, DELAY(-1,27NS,46NS),
+     LOAD & TRN_HL, DELAY(-1,27NS,46NS),
+     DATA & TRN_LH, DELAY(-1,22NS,44NS),
+     DATA & TRN_HL, DELAY(-1,22NS,44NS),
+     EDGE & TRN_LH, DELAY(-1,26NS,48NS),
+     EDGE & TRN_HL, DELAY(-1,26NS,48NS),
+     DELAY(-1,28NS,49NS))}
+   TC = {
+    CASE(
+     UPDOWN & TRN_LH, DELAY(-1,23NS,45NS),
+     UPDOWN & TRN_HL, DELAY(-1,23NS,45NS),
+     EDGE & TRN_LH, DELAY(-1,32NS,51NS),
+     EDGE & TRN_HL, DELAY(-1,32NS,51NS),
+     DELAY(-1,33NS,52NS))}
+   RCBAR = {
+    CASE(
+     UPDOWN & TRN_LH, DELAY(-1,24NS,45NS),
+     UPDOWN & TRN_HL, DELAY(-1,24NS,45NS),
+     COUNT & TRN_LH, DELAY(-1,19NS,33NS),
+     COUNT & TRN_HL, DELAY(-1,19NS,33NS),
+     EDGE & TRN_LH, DELAY(-1,19NS,35NS),
+     EDGE & TRN_HL, DELAY(-1,19NS,35NS),
+     DELAY(-1,25NS,46NS))}

U7 CONSTRAINT(8) DPWR DGND
+ CP PLBAR CEBAR UBAR/D D0 D1 D2 D3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CP
+   MAXFREQ = 33MEG
+ WIDTH:
+   NODE = PLBAR
+   MIN_LO = 11NS
+ WIDTH:
+   NODE = CP
+   MIN_LO = 9NS
+   MIN_HI = 9NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = CEBAR
+   SETUPTIME = 18NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = UBAR/D
+   SETUPTIME = 20NS
+ SETUP_HOLD:
+   CLOCK LH = PLBAR
+   DATA(4) = D0 D1 D2 D3
+   SETUPTIME = 9NS
+ SETUP_HOLD:
+   CLOCK LH = CP
+   DATA(1) = PLBAR
+   SETUPTIME_HI = 1NS

.ENDS 74HCT191

* ----------------------------------------------------------- 74LS191 ------
*  Synchronous Up/Down Binary Counter with Down/Up Mode Control
*
*  The Standard TTL Logic Data Book, 1988, TI Pages 2-263 to 2-270
*  jds    5/6/94
*
.SUBCKT 74LS191 D/UBAR CLK A B C D MAX/MIN LOADBAR CTENBAR QA QB QC QD RCOBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS191 LOGICEXP (16,15) DPWR DGND
+      D/UBAR CLK A B C D LOADBAR CTENBAR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      RCOBAR_O MAX/MIN_O jka jkb jkc jkd sa sb sc sd ra rb rc rd clkbar
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = {(~CLK) }
+      load = {(~LOADBAR)}
+      cten = {(~CTENBAR)}
+      dbar/u = {(~D/UBAR)}
+      sa = { ~(A & load) }
+      ra = { ~(sa & load) }
+      sb = { ~(B & load) }
+      rb = { ~(sb & load) }
+      sc = { ~(C & load) }
+      rc = { ~(sc & load) }
+      sd = { ~(D & load) }
+      rd = { ~(sd & load) }
+      i1 = { (~(D/UBAR | CTENBAR)) }
+      i2 = { (~(dbar/u | CTENBAR)) }
+      MAX/MIN_O = { (dbar/u & QA_O & QB_O & QC_O & QD_O) |
+                    (D/UBAR & qabar & qbbar & qcbar & qdbar)}
+      RCOBAR_O =  { ~(MAX/MIN_O & cten & clkbar) }
+      jka = { (cten) }
+      jkb = { (i2 & qabar) | (QA_O & i1)}
+      jkc = { (i2 & qabar & qbbar) | (QA_O & QB_O & i1)}
+      jkd = { (i2 & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O & i1) }

uf0 jkFF(1) DPWR DGND
+ sa ra clkbar jka jka QA_O qabar
+ D0_EFF IO_LS

uf1 jkFF(1) DPWR DGND
+ sb rb clkbar jkb jkb QB_O qbbar
+ D0_EFF IO_LS

uf2 jkFF(1) DPWR DGND
+ sc rc clkbar jkc jkc QC_O qcbar
+ D0_EFF IO_LS

uf3 jkFF(1) DPWR DGND
+ sd rd clkbar jkd jkd QD_O qdbar
+ D0_EFF IO_LS

Udly PINDLY (6,0,7) DPWR DGND
+    RCOBAR_O QA_O QB_O QC_O QD_O MAX/MIN_O
+    D/UBAR CLK A B C D LOADBAR
+    RCOBAR QA QB QC QD MAX/MIN
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     CLOCK = { CHANGED(CLK,0) }
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     UP/DOWN = { CHANGED(D/UBAR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       RCOBAR = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,13ns,20ns),
+                 CLOCK & TRN_HL, DELAY(-1,16ns,24ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,30ns,45ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,30ns,45ns),
+                 DELAY(-1,31ns,46ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 LOAD_DAT & TRN_LH, DELAY(-1,22ns,33ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,33ns,50ns),
+                 DATA & TRN_LH, DELAY(-1,20ns,32ns),
+                 DATA & TRN_HL, DELAY(-1,27ns,40ns),
+                 CLOCK & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLOCK & TRN_HL, DELAY(-1,24ns,36ns),
+                 DELAY(-1,34ns,51ns)
+                )
+            }
+       MAX/MIN = {
+            CASE(
+                 CLOCK & TRN_LH, DELAY(-1,28ns,42ns),
+                 CLOCK & TRN_HL, DELAY(-1,37ns,52ns),
+                 UP/DOWN & TRN_LH, DELAY(-1,21ns,33ns),
+                 UP/DOWN & TRN_HL, DELAY(-1,22ns,33ns),
+                 DELAY(-1,38ns,53ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLK CTENBAR LOADBAR A B C D D/UBAR
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns   
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 35ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CTENBAR
+        SETUPTIME = 40ns

.ENDS 74LS191
*
*
* ----------------------------------------------------------- 74192 ------
*  Synchronous 4-Bit Up/Down BCD Counter with Dual Clock and Clear
*
*  The Standard TTL Data Book, 1988, TI Pages 2-633 to 2-644
*  jds    5/6/94
*
.SUBCKT 74192 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74192 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QD_O) }
+      i1 = { ~(qbbar & qcbar & qdbar) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar & i1) | (upbar & QA_O & qdbar)}
+      tc = { (i1 & downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QD_O & upbar) | 
+               (QA_O & QB_O & QC_O & upbar) }

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_STD

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_STD

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_STD

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_STD

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLKUP & TRN_HL, DELAY(-1,16ns,24ns),
+                 DELAY(-1,18ns,27ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,22ns,35ns),
+                 LOAD_DAT & TRN_LH, DELAY(-1,27ns,40ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,29ns,40ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(-1,25ns,38ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(-1,31ns,47ns),
+                 DELAY(-1,30ns,49ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLKDOWN & TRN_HL, DELAY(-1,16ns,24ns),
+                 DELAY(-1,17ns,25ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_STD
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 20MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        WHEN = { CLR != '1 }

.ENDS 74192
*
*
* ----------------------------------------------------------- 74ALS192 ------
*  Synchronous 4-Bit Up/Down BCD Counter with Dual Clock and Clear
*
*  The ALS/AS Logic Data Book, TI Pages 2-221 to 2-228
*  jds    5/6/94
*
.SUBCKT 74ALS192 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS192 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QD_O) }
+      i1 = { ~(qbbar & qcbar & qdbar) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar & i1) | (upbar & QA_O & qdbar)}
+      tc = { (i1 & downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QD_O & upbar) | 
+               (QA_O & QB_O & QC_O & upbar) }

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_ALS00

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_ALS00

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_ALS00

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_ALS00

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(4ns,-1,16ns),
+                 CLKUP & TRN_HL, DELAY(5ns,-1,18ns),
+                 DELAY(6ns,-1,19ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(5ns,-1,17ns),
+                 LOAD_DAT & TRN_LH, DELAY(8ns,-1,30ns),
+                 LOAD_DAT & TRN_HL, DELAY(8ns,-1,28ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(4ns,-1,19ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(4ns,-1,17ns),
+                 DELAY(9ns,-1,31ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(4ns,-1,19ns),
+                 CLKDOWN & TRN_HL, DELAY(4ns,-1,17ns),
+                 DELAY(5ns,-1,20ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 25MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 10ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(1) = CLR
+        SETUPTIME_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(1) = CLR
+        SETUPTIME_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(1) = LOADBAR
+        SETUPTIME_HI = 20ns
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(1) = LOADBAR
+        SETUPTIME_HI = 20ns
+        WHEN = { CLR != '1 }

.ENDS 74ALS192
*
*
* ----------------------------------------------------------- 74F192 ------
*  Synchronous 4-Bit Up/Down BCD Counter with Dual Clock and Clear
*
*  The FAST TTL Logic Series Data Book, 1992,  Philips pages 271-278
*  jds    5/11/94
*
.SUBCKT 74F192 CPU CPD MR D0 D1 D2 D3 TCUBAR PLBAR TCDBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F192 LOGICEXP (16,14) DPWR DGND
+      CPD CPU D0 D1 D2 D3 PLBAR MR
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCUBAR_O TCDBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~CPU) }
+      load = {(~PLBAR)}
+      downbar = {(~CPD)}
+      clrbar = {(~MR)}
+      sa = { ~(D0 & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(D1 & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(D2 & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D3 & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      TCDBAR_O = { ~(downbar & q0bar & q1bar & q2bar & q3bar) }
+      TCUBAR_O =  { ~(upbar & Q0_O & Q3_O) }
+      i1 = { ~(q1bar & q2bar & q3bar) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & q0bar & i1) | (upbar & Q0_O & q3bar)}
+      tc = { (i1 & downbar & q0bar & q1bar) | (upbar & Q0_O & Q1_O)}
+      td = { (downbar & q0bar & q1bar & q2bar) | (Q0_O & Q3_O & upbar) | 
+               (Q0_O & Q1_O & Q2_O & upbar) }

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI Q0_O q0bar
+ D0_EFF IO_F

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI Q1_O q1bar
+ D0_EFF IO_F

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI Q2_O q2bar
+ D0_EFF IO_F

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI Q3_O q3bar
+ D0_EFF IO_F

Udly PINDLY (6,0,8) DPWR DGND
+    TCUBAR_O Q0_O Q1_O Q2_O Q3_O TCDBAR_O
+    CPD CPU MR PLBAR D0 D1 D2 D3
+    TCUBAR Q0 Q1 Q2 Q3 TCDBAR
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     CLKUP  = { CHANGED(CPU,0) }
+     CLKDOWN  = { CHANGED(CPD,0) }
+     CLEAR = { CHANGED(MR,0) }
+     DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) }
+
+    PINDLY:
+       TCUBAR = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(6ns,8.5ns,12ns),
+                 CLKUP & TRN_LH, DELAY(2.5ns,5.5ns,8.5ns),
+                 CLKUP & TRN_HL, DELAY(3ns,5ns,8ns),
+                  LOAD_DAT & TRN_LH, DELAY(6ns,9.5ns,13.5ns),
+                  LOAD_DAT & TRN_HL, DELAY(6ns,9ns,12ns),
+                  DATA & TRN_LH, DELAY(5.5ns,9ns,13ns),
+                  DATA & TRN_HL, DELAY(4.5ns,8.5ns,12.5ns),
+                 DELAY(7ns,10ns,14.5ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(5ns,7.5ns,11ns),
+                 LOAD_DAT & TRN_LH, DELAY(4.5ns,6.5ns,10ns),
+                 LOAD_DAT & TRN_HL, DELAY(5.5ns,8.5ns,12ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(2.5ns,5.5ns,8.5ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(5ns,8.5ns,12ns),
+                  DATA & TRN_LH, DELAY(2ns,4ns,7ns),
+                  DATA & TRN_HL, DELAY(6ns,9.5ns,13.5ns),
+                 DELAY(7ns,10.5ns,14.5ns)
+                )
+            }
+       TCDBAR = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(5ns,7.5ns,11ns),
+                 CLKDOWN & TRN_LH, DELAY(2.5ns,5.5ns,8.5ns),
+                 CLKDOWN & TRN_HL, DELAY(3ns,5ns,8ns),
+                 LOAD_DAT & TRN_LH, DELAY(6ns,9.5ns,13.5ns),
+                 LOAD_DAT & TRN_HL, DELAY(6ns,9ns,12ns),
+                  DATA & TRN_LH, DELAY(5.5ns,9ns,13ns),
+                  DATA & TRN_HL, DELAY(4.5ns,8.5ns,12.5ns),
+                 DELAY(7ns,10.5ns,14.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          MR CPU CPD PLBAR D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CPU
+         MAXFREQ = 125MEG
+      FREQ:
+         NODE = CPD
+         MAXFREQ = 125MEG
+      WIDTH:
+         NODE = CPU
+         MIN_HI = 3.5ns
+         MIN_LO = 5ns
+      WIDTH:
+         NODE = CPD
+         MIN_HI = 3.5ns
+         MIN_LO = 5ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 6ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 6ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 2ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = PLBAR
+        RELEASETIME = 6ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = PLBAR
+        RELEASETIME = 6ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = MR
+        RELEASETIME = 4ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = MR
+        RELEASETIME = 4ns

.ENDS 74F192
*
*
* ----------------------------------------------------------- 74HC192 ------
*  Synchronous 4-Bit Up/Down BCD Counter with Dual Clock and Clear
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-271 to 2-278
*  jds    5/13/94
*
.SUBCKT 74HC192 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC192 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QD_O) }
+      i1 = { ~(qbbar & qcbar & qdbar) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar & i1) | (upbar & QA_O & qdbar)}
+      tc = { (i1 & downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QD_O & upbar) | 
+               (QA_O & QB_O & QC_O & upbar) }

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_HC

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_HC

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_STD

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_HC

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(-1,24ns,33ns),
+                 CLKUP & TRN_HL, DELAY(-1,24ns,33ns),
+                 DELAY(-1,25ns,33ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,36ns,48ns),
+                 LOAD_DAT & TRN_LH, DELAY(-1,40ns,52ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,40ns,52ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(-1,40ns,50ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(-1,40ns,50ns),
+                 DELAY(-1,41ns,51ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(-1,24ns,33ns),
+                 CLKDOWN & TRN_HL, DELAY(-1,24ns,33ns),
+                 DELAY(-1,25ns,33ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_HC
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 21MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 21MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 24ns
+         MIN_LO = 24ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 24ns
+         MIN_LO = 24ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 24ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 24ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 22ns
+        HOLDTIME = 5ns
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 22ns
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 22ns

.ENDS 74HC192
*
*
* ----------------------------------------------------------- 74HCT192 ------
*  Synchronous 4-Bit Up/Down BCD Counter with Dual Clock and Clear
*
*  The High Speed CMOS Logic Family Data Book, 1994,  Philips pages 429-436
*  jds    5/11/94
*
.SUBCKT 74HCT192 CPU CPD MR D0 D1 D2 D3 TCUBAR PLBAR TCDBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT192 LOGICEXP (16,14) DPWR DGND
+      CPD CPU D0 D1 D2 D3 PLBAR MR
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCUBAR_O TCDBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~CPU) }
+      load = {(~PLBAR)}
+      downbar = {(~CPD)}
+      clrbar = {(~MR)}
+      sa = { ~(D0 & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(D1 & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(D2 & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D3 & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      TCDBAR_O = { ~(downbar & q0bar & q1bar & q2bar & q3bar) }
+      TCUBAR_O =  { ~(upbar & Q0_O & Q3_O) }
+      i1 = { ~(q1bar & q2bar & q3bar) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & q0bar & i1) | (upbar & Q0_O & q3bar)}
+      tc = { (i1 & downbar & q0bar & q1bar) | (upbar & Q0_O & Q1_O)}
+      td = { (downbar & q0bar & q1bar & q2bar) | (Q0_O & Q3_O & upbar) | 
+               (Q0_O & Q1_O & Q2_O & upbar) }

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI Q0_O q0bar
+ D0_EFF IO_HCT

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI Q1_O q1bar
+ D0_EFF IO_HCT

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI Q2_O q2bar
+ D0_EFF IO_HCT

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI Q3_O q3bar
+ D0_EFF IO_HCT

Udly PINDLY (6,0,8) DPWR DGND
+    TCUBAR_O Q0_O Q1_O Q2_O Q3_O TCDBAR_O
+    CPD CPU MR PLBAR D0 D1 D2 D3
+    TCUBAR Q0 Q1 Q2 Q3 TCDBAR
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     CLKUP  = { CHANGED(CPU,0) }
+     CLKDOWN  = { CHANGED(CPD,0) }
+     CLEAR = { CHANGED(MR,0) }
+     DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) }
+
+    PINDLY:
+       TCUBAR = {
+            CASE(
+                 CLEAR, DELAY(-1,36ns,64ns),
+                 CLKUP, DELAY(-1,16ns,30ns),
+                  LOAD_DAT, DELAY(-1,36ns,64ns),
+                  DATA, DELAY(-1,33ns,58ns),
+                  DELAY(-1,37ns,65ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR, DELAY(-1,24ns,40ns),
+                 LOAD_DAT, DELAY(-1,28ns,46ns),
+                 (CLKUP | CLKDOWN), DELAY(-1,23ns,43ns),
+                  DATA , DELAY(-1,36ns,60ns),
+                 DELAY(-1,37ns,61ns)
+                )
+            }
+       TCDBAR = {
+            CASE(
+                 CLEAR, DELAY(-1,36ns,64ns),
+                 CLKDOWN, DELAY(-1,17ns,30ns),
+                  LOAD_DAT, DELAY(-1,36ns,64ns),
+                  DATA, DELAY(-1,36ns,62ns),
+                 DELAY(-1,37ns,65ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          MR CPU CPD PLBAR D0 D1 D2 D3
+          IO_HCT
+
+      FREQ:
+         NODE = CPU
+         MAXFREQ = 41MEG
+      FREQ:
+         NODE = CPD
+         MAXFREQ = 41MEG
+      WIDTH:
+         NODE = CPU
+         MIN_HI = 14ns
+         MIN_LO = 14ns
+      WIDTH:
+         NODE = CPD
+         MIN_HI =14ns
+         MIN_LO = 14ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 6ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 10ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 6ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = PLBAR
+        RELEASETIME = 1ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = PLBAR
+        RELEASETIME = 1ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = MR
+        RELEASETIME = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = MR
+        RELEASETIME = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = CPD
+        HOLDTIME = 9ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = CPU
+        HOLDTIME = 9ns

.ENDS 74HCT192
*
*
* ----------------------------------------------------------- 74LS192 ------
*  Synchronous 4-Bit Up/Down BCD Counter with Dual Clock and Clear
*
*  The Standard TTL Data Book, 1988, TI Pages 2-633 to 2-644
*  jds    5/12/94
*
.SUBCKT 74LS192 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS192 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QD_O) }
+      i1 = { ~(qbbar & qcbar & qdbar) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar & i1) | (upbar & QA_O & qdbar)}
+      tc = { (i1 & downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QD_O & upbar) | 
+               (QA_O & QB_O & QC_O & upbar) }

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_LS

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_LS

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_LS

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_LS

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLKUP & TRN_HL, DELAY(-1,18ns,24ns),
+                 DELAY(-1,19ns,27ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,23ns,35ns),
+                 LOAD_DAT & TRN_LH, DELAY(-1,24ns,40ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,25ns,40ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(-1,27ns,38ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(-1,30ns,47ns),
+                 DELAY(-1,31ns,48ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLKDOWN & TRN_HL, DELAY(-1,15ns,24ns),
+                 DELAY(-1,17ns,25ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_LS
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 25MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5n
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 15ns
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 15ns

.ENDS 74LS192
*
*
* ----------------------------------------------------------- 74193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  The Standard TTL Data Book, 1988, TI Pages 2-633 to 2-644
*  jds    5/13/94
*
.SUBCKT 74193 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74193 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QB_O & QC_O & QD_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar) | (upbar & QA_O)}
+      tc = { (downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_STD

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_STD

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_STD

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_STD

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLKUP & TRN_HL, DELAY(-1,16ns,24ns),
+                 DELAY(-1,18ns,27ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,22ns,35ns),
+                 LOAD_DAT & TRN_LH, DELAY(-1,27ns,40ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,29ns,40ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(-1,25ns,38ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(-1,31ns,47ns),
+                 DELAY(-1,30ns,49ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLKDOWN & TRN_HL, DELAY(-1,16ns,24ns),
+                 DELAY(-1,17ns,25ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_STD
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 20MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        WHEN = { CLR != '1 }

.ENDS 74193
*
*
* ----------------------------------------------------------- 74AC193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  Harris Semiconductor online FAX data
*  jds    5/11/94
*
.SUBCKT 74AC193 CPU CPD MR P0 P1 P2 P3 TCUBAR PLBAR TCDBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC193 LOGICEXP (16,14) DPWR DGND
+      CPD CPU P0 P1 P2 P3 PLBAR MR
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCUBAR_O TCDBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~CPU) }
+      load = {(~PLBAR)}
+      downbar = {(~CPD)}
+      clrbar = {(~MR)}
+      sa = { ~(P0 & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(P1 & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(P2 & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(P3 & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      TCDBAR_O = { ~(downbar & q0bar & q1bar & q2bar & q3bar) }
+      TCUBAR_O =  { ~(upbar & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & q0bar) | (upbar & Q0_O)}
+      tc = { (downbar & q0bar & q1bar) | (upbar & Q0_O & Q1_O)}
+      td = { (downbar & q0bar & q1bar & q2bar) | (Q1_O & Q1_O & Q2_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI Q0_O q0bar
+ D0_EFF IO_AC

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI Q1_O q1bar
+ D0_EFF IO_AC

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI Q2_O q2bar
+ D0_EFF IO_AC

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI Q3_O q3bar
+ D0_EFF IO_AC

Udly PINDLY (6,0,8) DPWR DGND
+    TCUBAR_O Q0_O Q1_O Q2_O Q3_O TCDBAR_O
+    CPD CPU MR PLBAR P0 P1 P2 P3
+    TCUBAR Q0 Q1 Q2 Q3 TCDBAR
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     CLKUP  = { CHANGED(CPU,0) }
+     CLKDOWN  = { CHANGED(CPD,0) }
+     CLEAR = { CHANGED(MR,0) }
+     DATA = { CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) }
+
+    PINDLY:
+       TCUBAR = {
+            CASE(
+                 CLEAR, DELAY(3.9ns,-1,13.6ns),
+                 CLKUP, DELAY(2.9ns,-1,10.2ns),
+                  DELAY(4.9ns,-1,14.6ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR, DELAY(4.1ns,-1,14.5ns),
+                 LOAD_DAT, DELAY(3.9ns,-1,13.6ns),
+                 (CLKUP | CLKDOWN), DELAY(3.6ns,-1,12.7ns),
+                  DATA , DELAY(4.2ns,-1,15ns),
+                 DELAY(5.2ns,-1,16ns)
+                )
+            }
+       TCDBAR = {
+            CASE(
+                 CLEAR, DELAY(4.7ns,-1,16.5ns),
+                 CLKDOWN, DELAY(2.9ns,-1,10.2ns),
+                 DELAY(5.7ns,-1,17.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          MR CPU CPD PLBAR P0 P1 P2 P3
+          IO_AC
+
+      FREQ:
+         NODE = CPU
+         MAXFREQ = 86MEG
+      FREQ:
+         NODE = CPD
+         MAXFREQ = 97MEG
+      WIDTH:
+         NODE = CPU
+         MIN_HI = 5.8ns
+         MIN_LO = 5.8ns
+      WIDTH:
+         NODE = CPD
+         MIN_HI =5.1ns
+         MIN_LO = 5.1ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 4.4ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 5.3ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 3.5ns
+         HOLDTIME = 2ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = PLBAR
+        RELEASETIME = 4.4ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = PLBAR
+        RELEASETIME = 4.4ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = MR
+        RELEASETIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = MR
+        RELEASETIME = 1ns

.ENDS 74AC193
*
*
* ----------------------------------------------------------- 74ACT193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  Harris Semiconductor online FAX data
*  jds    5/13/94
*
.SUBCKT 74ACT193 CPU CPD MR P0 P1 P2 P3 TCUBAR PLBAR TCDBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ACT193 LOGICEXP (16,14) DPWR DGND
+      CPD CPU P0 P1 P2 P3 PLBAR MR
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCUBAR_O TCDBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~CPU) }
+      load = {(~PLBAR)}
+      downbar = {(~CPD)}
+      clrbar = {(~MR)}
+      sa = { ~(P0 & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(P1 & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(P2 & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(P3 & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      TCDBAR_O = { ~(downbar & q0bar & q1bar & q2bar & q3bar) }
+      TCUBAR_O =  { ~(upbar & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & q0bar) | (upbar & Q0_O)}
+      tc = { (downbar & q0bar & q1bar) | (upbar & Q0_O & Q1_O)}
+      td = { (downbar & q0bar & q1bar & q2bar) | (Q1_O & Q1_O & Q2_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI Q0_O q0bar
+ D0_EFF IO_ACT

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI Q1_O q1bar
+ D0_EFF IO_ACT

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI Q2_O q2bar
+ D0_EFF IO_ACT

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI Q3_O q3bar
+ D0_EFF IO_ACT

Udly PINDLY (6,0,8) DPWR DGND
+    TCUBAR_O Q0_O Q1_O Q2_O Q3_O TCDBAR_O
+    CPD CPU MR PLBAR P0 P1 P2 P3
+    TCUBAR Q0 Q1 Q2 Q3 TCDBAR
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     CLKUP  = { CHANGED(CPU,0) }
+     CLKDOWN  = { CHANGED(CPD,0) }
+     CLEAR = { CHANGED(MR,0) }
+     DATA = { CHANGED(P0,0) | CHANGED(P1,0) | CHANGED(P2,0) | CHANGED(P3,0) }
+
+    PINDLY:
+       TCUBAR = {
+            CASE(
+                 CLEAR, DELAY(3.9ns,-1,13.6ns),
+                 CLKUP, DELAY(2.9ns,-1,10.2ns),
+                  DELAY(4.9ns,-1,14.6ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR, DELAY(4.1ns,-1,14.5ns),
+                 LOAD_DAT, DELAY(3.9ns,-1,13.6ns),
+                 (CLKUP | CLKDOWN), DELAY(3.6ns,-1,12.7ns),
+                  DATA , DELAY(4.2ns,-1,15ns),
+                 DELAY(5.2ns,-1,16ns)
+                )
+            }
+       TCDBAR = {
+            CASE(
+                 CLEAR, DELAY(4.7ns,-1,16.5ns),
+                 CLKDOWN, DELAY(2.9ns,-1,10.2ns),
+                 DELAY(5.7ns,-1,17.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          MR CPU CPD PLBAR P0 P1 P2 P3
+          IO_ACT
+
+      FREQ:
+         NODE = CPU
+         MAXFREQ = 74MEG
+      FREQ:
+         NODE = CPD
+         MAXFREQ = 86MEG
+      WIDTH:
+         NODE = CPU
+         MIN_HI = 6.8ns
+         MIN_LO = 6.8ns
+      WIDTH:
+         NODE = CPD
+         MIN_HI =5.8ns
+         MIN_LO = 5.8ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 4.4ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 6.6ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 4.7ns
+         HOLDTIME = 2ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = PLBAR
+        RELEASETIME = 5.7ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = PLBAR
+        RELEASETIME = 5.7ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = MR
+        RELEASETIME = 1ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = MR
+        RELEASETIME = 1ns

.ENDS 74ACT193
*
*
* ----------------------------------------------------------- 74ALS193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  The ALS/AS Logic Data Book, TI Pages 2-221 to 2-228
*  jds    5/13/94
*
.SUBCKT 74ALS193 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS193 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QB_O & QC_O & QD_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar) | (upbar & QA_O)}
+      tc = { (downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_ALS00

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_ALS00

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_ALS00

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_ALS00

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(4ns,-1,16ns),
+                 CLKUP & TRN_HL, DELAY(5ns,-1,18ns),
+                 DELAY(6ns,-1,19ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(5ns,-1,17ns),
+                 LOAD_DAT & TRN_LH, DELAY(8ns,-1,30ns),
+                 LOAD_DAT & TRN_HL, DELAY(8ns,-1,28ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(4ns,-1,19ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(4ns,-1,17ns),
+                 DELAY(9ns,-1,31ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(4ns,-1,19ns),
+                 CLKDOWN & TRN_HL, DELAY(4ns,-1,17ns),
+                 DELAY(5ns,-1,20ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 25MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 10ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(1) = CLR
+        SETUPTIME_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(1) = CLR
+        SETUPTIME_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(1) = LOADBAR
+        SETUPTIME_HI = 20ns
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(1) = LOADBAR
+        SETUPTIME_HI = 20ns
+        WHEN = { CLR != '1 }

.ENDS 74ALS193
*
*
* ----------------------------------------------------------- 74F193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  The FAST TTL Logic Series Data Book, 1992,  Philips pages 271-278
*  jds    5/13/94
*
.SUBCKT 74F193 CPU CPD MR D0 D1 D2 D3 TCUBAR PLBAR TCDBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F193 LOGICEXP (16,14) DPWR DGND
+      CPD CPU D0 D1 D2 D3 PLBAR MR
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCUBAR_O TCDBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~CPU) }
+      load = {(~PLBAR)}
+      downbar = {(~CPD)}
+      clrbar = {(~MR)}
+      sa = { ~(D0 & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(D1 & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(D2 & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D3 & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      TCDBAR_O = { ~(downbar & q0bar & q1bar & q2bar & q3bar) }
+      TCUBAR_O =  { ~(upbar & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & q0bar) | (upbar & Q0_O)}
+      tc = { (downbar & q0bar & q1bar) | (upbar & Q0_O & Q1_O)}
+      td = { (downbar & q0bar & q1bar & q2bar) | (Q0_O & Q1_O & Q2_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI Q0_O q0bar
+ D0_EFF IO_F

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI Q1_O q1bar
+ D0_EFF IO_F

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI Q2_O q2bar
+ D0_EFF IO_F

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI Q3_O q3bar
+ D0_EFF IO_F

Udly PINDLY (6,0,8) DPWR DGND
+    TCUBAR_O Q0_O Q1_O Q2_O Q3_O TCDBAR_O
+    CPD CPU MR PLBAR D0 D1 D2 D3
+    TCUBAR Q0 Q1 Q2 Q3 TCDBAR
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     CLKUP  = { CHANGED(CPU,0) }
+     CLKDOWN  = { CHANGED(CPD,0) }
+     CLEAR = { CHANGED(MR,0) }
+     DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) }
+
+    PINDLY:
+       TCUBAR = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(6ns,8.5ns,12ns),
+                 CLKUP & TRN_LH, DELAY(2.5ns,5.5ns,8.5ns),
+                 CLKUP & TRN_HL, DELAY(3ns,5ns,8ns),
+                  LOAD_DAT & TRN_LH, DELAY(6ns,9.5ns,13.5ns),
+                  LOAD_DAT & TRN_HL, DELAY(6ns,9ns,12ns),
+                  DATA & TRN_LH, DELAY(5.5ns,9ns,13ns),
+                  DATA & TRN_HL, DELAY(4.5ns,8.5ns,12.5ns),
+                 DELAY(7ns,10ns,14.5ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(5ns,7.5ns,11ns),
+                 LOAD_DAT & TRN_LH, DELAY(4.5ns,6.5ns,10ns),
+                 LOAD_DAT & TRN_HL, DELAY(5.5ns,8.5ns,12ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(2.5ns,5.5ns,8.5ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(5ns,8.5ns,12ns),
+                  DATA & TRN_LH, DELAY(2ns,4ns,7ns),
+                  DATA & TRN_HL, DELAY(6ns,9.5ns,13.5ns),
+                 DELAY(7ns,10.5ns,14.5ns)
+                )
+            }
+       TCDBAR = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(5ns,7.5ns,11ns),
+                 CLKDOWN & TRN_LH, DELAY(2.5ns,5.5ns,8.5ns),
+                 CLKDOWN & TRN_HL, DELAY(3ns,5ns,8ns),
+                 LOAD_DAT & TRN_LH, DELAY(6ns,9.5ns,13.5ns),
+                 LOAD_DAT & TRN_HL, DELAY(6ns,9ns,12ns),
+                  DATA & TRN_LH, DELAY(5.5ns,9ns,13ns),
+                  DATA & TRN_HL, DELAY(4.5ns,8.5ns,12.5ns),
+                 DELAY(7ns,10.5ns,14.5ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          MR CPU CPD PLBAR D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CPU
+         MAXFREQ = 125MEG
+      FREQ:
+         NODE = CPD
+         MAXFREQ = 125MEG
+      WIDTH:
+         NODE = CPU
+         MIN_HI = 3.5ns
+         MIN_LO = 5ns
+      WIDTH:
+         NODE = CPD
+         MIN_HI = 3.5ns
+         MIN_LO = 5ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 6ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 6ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 2ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = PLBAR
+        RELEASETIME = 6ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = PLBAR
+        RELEASETIME = 6ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = MR
+        RELEASETIME = 4ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = MR
+        RELEASETIME = 4ns

.ENDS 74F193
* ----------------------------------------------------------- 74F193A ------
*  Synchronous 4-Bit Up/Down Decade Counter with Reset And Ripple Clock
*
*  The F Data Book, 1994, TI Pages 2-151 to 2-156
*  jat 7/2/96
*
.SUBCKT 74F193A CLR UP DOWN A B C D LOADBAR COBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

UF193A LOGICEXP(16,15) DPWR DGND
+  CLR UP DOWN LOADBAR A B C D QAO QBO QCO QDO QABAR QBBAR QCBAR QDBAR
+  COBARO BOBARO DA DB DC DD CLK SETA SETB SETC SETD CLRA CLRB CLRC CLRD
+  D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+  LOGIC:
+     SETA = {CLR | (LOADBAR | ~A)}
+     CLRA = {(~CLR) & (LOADBAR | A)}
+     SETB = {CLR | (LOADBAR | ~B)}
+     CLRB = {(~CLR) & (LOADBAR | B)}
+     SETC = {CLR | (LOADBAR | ~C)}
+     CLRC = {(~CLR) & (LOADBAR | C)}
+     SETD = {CLR | (LOADBAR | ~D)}
+     CLRD = {(~CLR) & (LOADBAR | D)}
+     DA = {QABAR}
+     XORB1 = {QAO ^ QBO}
+     XORB2 = {QBO ^ QABAR}
+     DB = {(DOWN & XORB1) | (UP & XORB2)}
+     XORC1 = {(QAO & QBO) ^ QCO}
+     XORC2 = {(QABAR & QBBAR) ^ QCO}
+     DC = {(DOWN & XORC1) | (UP & XORC2)}
+     XORD1 = {(QAO & QBO & QCO) ^ QDO}
+     XORD2 = {(QABAR & QBBAR & QCBAR) ^ QDO}
+     DD = {(DOWN & XORD1) | (UP & XORD2)}
+     CLK = {UP & DOWN}
+     COBARO = {~(QAO & QBO & QCO & QDO & ~UP)}
+     BOBARO = {~(QABAR & QBBAR & QCBAR & QDBAR & ~DOWN)}

U2 DFF(1) DPWR DGND
+  SETA CLRA CLK DA QAO QABAR
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 DFF(1) DPWR DGND
+  SETB CLRB CLK DB QBO QBBAR
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 DFF(1) DPWR DGND
+  SETC CLRC CLK DC QCO QCBAR
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 DFF(1) DPWR DGND
+  SETD CLRD CLK DD QDO QDBAR
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 PINDLY(6,0,8) DPWR DGND
+ COBARO BOBARO QAO QBO QCO QDO
+ CLR UP DOWN A B C D LOADBAR
+ COBAR BOBAR QA QB QC QD
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+    EDGE = {CHANGED(UP,0) | CHANGED(DOWN,0)}
+    DATA = {CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0)}
+    LOAD = {CHANGED(LOADBAR,0)}
+    CLEAR = {CHANGED(CLR,0)}
+ PINDLY:
+    QA QB QC QD = {
+       CASE(
+          CLEAR & (TRN_LH | TRN_HL), DELAY(5NS,-1,11NS),
+          LOAD & TRN_LH, DELAY(4.5NS,-1,10NS),
+          LOAD & TRN_HL, DELAY(5.5NS,-1,12NS),
+          DATA & TRN_LH, DELAY(2NS,-1,7NS),
+          DATA & TRN_HL, DELAY(6NS,-1,13.5NS),
+          EDGE & TRN_LH, DELAY(2.5NS,-1,8.5NS),
+          EDGE & TRN_HL, DELAY(5NS,-1,12NS),
+          DELAY(7NS,-1,14.5NS))}
+    COBAR = {
+        CASE(
+          CLEAR & TRN_LH, DELAY(6NS,-1,12NS),
+          LOAD & TRN_LH, DELAY(6NS,-1,13.5NS),
+          LOAD & TRN_HL, DELAY(6NS,-1,12.6NS),
+          DATA & TRN_LH, DELAY(5.5NS,-1,13NS),
+          DATA & TRN_HL, DELAY(4.5NS,-1,12.5NS),
+          EDGE & TRN_LH, DELAY(2.5NS,-1,8.5NS),
+          EDGE & TRN_HL, DELAY(3NS,-1,8NS),
+          DELAY(7NS,-1,14.5NS))}
+    BOBAR = {
+        CASE(
+          CLEAR & TRN_LH, DELAY(5NS,-1,11NS),
+          LOAD & TRN_LH, DELAY(6NS,-1,13.5NS),
+          LOAD & TRN_HL, DELAY(6NS,-1,12.6NS),
+          DATA & TRN_LH, DELAY(5.5NS,-1,13NS),
+          DATA & TRN_HL, DELAY(4.5NS,-1,12.5NS),
+          EDGE & TRN_LH, DELAY(2.5NS,-1,8.5NS),
+          EDGE & TRN_HL, DELAY(3NS,-1,8NS),
+          DELAY(7NS,-1,14.5NS))}

U7 CONSTRAINT(8) DPWR DGND
+ LOADBAR CLR UP DOWN A B C D
+ IO_F IO_LEVEL={IO_LEVEL}
+ FREQ:
+    NODE = UP
+    MAXFREQ = 85MEG
+ FREQ:
+    NODE = DOWN
+    MAXFREQ = 85MEG
+ WIDTH:
+    NODE =  UP
+    MIN_LO = 6NS
+    MIN_HI = 4NS
+ WIDTH:
+    NODE =  DOWN
+    MIN_LO = 6NS
+    MIN_HI = 4NS
+ WIDTH:
+    NODE =  CLR
+    MIN_HI = 4NS
+ WIDTH:
+    NODE =  LOADBAR
+    MIN_LO = 5.5NS
+ SETUP_HOLD:
+   CLOCK LH = LOADBAR
+   DATA(4) = A B C D
+   SETUPTIME = 3.5NS
+   HOLDTIME = 2.5NS
+ SETUP_HOLD:
+   CLOCK LH = UP
+   DATA(1) = CLR
+   SETUPTIME_LO = 5NS
+ SETUP_HOLD:
+   CLOCK LH = DOWN
+   DATA(1) = CLR
+   SETUPTIME_LO = 5NS
+ SETUP_HOLD:
+   CLOCK LH = UP
+   DATA(1) = CLR
+   SETUPTIME_HI = 7.5NS
+ SETUP_HOLD:
+   CLOCK LH = DOWN
+   DATA(1) = CLR
+   SETUPTIME_HI = 7.5NS

.ENDS 74F193A

*
*
* ----------------------------------------------------------- 74HC193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-271 to 2-278
*  jds    5/13/94
*
.SUBCKT 74HC193 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC193 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QB_O & QC_O & QD_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar) | (upbar & QA_O)}
+      tc = { (downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_HC

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_HC

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_STD

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_HC

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(-1,24ns,33ns),
+                 CLKUP & TRN_HL, DELAY(-1,24ns,33ns),
+                 DELAY(-1,25ns,33ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,36ns,48ns),
+                 LOAD_DAT & TRN_LH, DELAY(-1,40ns,52ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,40ns,52ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(-1,40ns,50ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(-1,40ns,50ns),
+                 DELAY(-1,41ns,51ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(-1,24ns,33ns),
+                 CLKDOWN & TRN_HL, DELAY(-1,24ns,33ns),
+                 DELAY(-1,25ns,33ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_HC
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 21MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 21MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 24ns
+         MIN_LO = 24ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 24ns
+         MIN_LO = 24ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 24ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 24ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 22ns
+        HOLDTIME = 5ns
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 22ns
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 22ns

.ENDS 74HC193
*
*
* ----------------------------------------------------------- 74HCT193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  The High Speed CMOS Logic Family Data Book, 1994,  Philips pages 429-436
*  jds    5/11/94
*
.SUBCKT 74HCT193 CPU CPD MR D0 D1 D2 D3 TCUBAR PLBAR TCDBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT193 LOGICEXP (16,14) DPWR DGND
+      CPD CPU D0 D1 D2 D3 PLBAR MR
+      Q0_O Q1_O Q2_O Q3_O q0bar q1bar q2bar q3bar
+      TCUBAR_O TCDBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~CPU) }
+      load = {(~PLBAR)}
+      downbar = {(~CPD)}
+      clrbar = {(~MR)}
+      sa = { ~(D0 & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(D1 & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(D2 & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D3 & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      TCDBAR_O = { ~(downbar & q0bar & q1bar & q2bar & q3bar) }
+      TCUBAR_O =  { ~(upbar & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & q0bar) | (upbar & Q0_O)}
+      tc = { (downbar & q0bar & q1bar) | (upbar & Q0_O & Q1_O)}
+      td = { (downbar & q0bar & q1bar & q2bar) | (Q0_O & Q1_O & Q2_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI Q0_O q0bar
+ D0_EFF IO_HCT

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI Q1_O q1bar
+ D0_EFF IO_HCT

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI Q2_O q2bar
+ D0_EFF IO_HCT

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI Q3_O q3bar
+ D0_EFF IO_HCT

Udly PINDLY (6,0,8) DPWR DGND
+    TCUBAR_O Q0_O Q1_O Q2_O Q3_O TCDBAR_O
+    CPD CPU MR PLBAR D0 D1 D2 D3
+    TCUBAR Q0 Q1 Q2 Q3 TCDBAR
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(PLBAR,0) }
+     CLKUP  = { CHANGED(CPU,0) }
+     CLKDOWN  = { CHANGED(CPD,0) }
+     CLEAR = { CHANGED(MR,0) }
+     DATA = { CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) }
+
+    PINDLY:
+       TCUBAR = {
+            CASE(
+                 CLEAR, DELAY(-1,29ns,55ns),
+                 CLKUP, DELAY(-1,15ns,27ns),
+                  LOAD_DAT, DELAY(-1,31ns,55ns),
+                  DATA, DELAY(-1,32ns,58ns),
+                  DELAY(-1,33ns,59ns)
+                )
+            }
+       Q0 Q1 Q2 Q3 = {
+            CASE(
+                 CLEAR, DELAY(-1,22ns,40ns),
+                 LOAD_DAT, DELAY(-1,26ns,46ns),
+                 (CLKUP | CLKDOWN), DELAY(-1,23ns,43ns),
+                  DATA , DELAY(-1,27ns,46ns),
+                 DELAY(-1,28ns,47ns)
+                )
+            }
+       TCDBAR = {
+            CASE(
+                 CLEAR, DELAY(-1,29ns,55ns),
+                 CLKDOWN, DELAY(-1,15ns,27ns),
+                  LOAD_DAT, DELAY(-1,31ns,55ns),
+                  DATA, DELAY(-1,32ns,58ns),
+                 DELAY(-1,33ns,59ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          MR CPU CPD PLBAR D0 D1 D2 D3
+          IO_HCT
+
+      FREQ:
+         NODE = CPU
+         MAXFREQ = 43MEG
+      FREQ:
+         NODE = CPD
+         MAXFREQ = 43MEG
+      WIDTH:
+         NODE = CPU
+         MIN_HI = 14ns
+         MIN_LO = 14ns
+      WIDTH:
+         NODE = CPD
+         MIN_HI =11ns
+         MIN_LO = 11ns
+      WIDTH:
+         NODE = MR
+         MIN_HI = 7ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 8ns
+      SETUP_HOLD:
+        CLOCK LH = PLBAR
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 8ns
+        HOLDTIME = 6ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = PLBAR
+        RELEASETIME = 2ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = PLBAR
+        RELEASETIME = 2ns
+        WHEN = { MR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = CPU
+        DATA(1) = CPD
+        HOLDTIME = 7ns
+      SETUP_HOLD:
+        CLOCK LH = CPD
+        DATA(1) = CPU
+        HOLDTIME = 7ns

.ENDS 74HCT193
*
*
* ----------------------------------------------------------- 74LS193 ------
*  Synchronous 4-Bit Up/Down Binary Counter with Dual Clock and Clear
*
*  The Standard TTL Data Book, 1988, TI Pages 2-633 to 2-644
*  jds    5/13/94
*
.SUBCKT 74LS193 DOWN UP CLR A B C D COBAR LOADBAR BOBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS193 LOGICEXP (16,14) DPWR DGND
+      DOWN UP A B C D LOADBAR CLR
+      QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+      COBAR_O BOBAR_O ta tb tc td sa sb sc sd ra rb rc rd
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      upbar = {(~UP) }
+      load = {(~LOADBAR)}
+      downbar = {(~DOWN)}
+      clrbar = {(~CLR)}
+      sa = { ~(A & load & clrbar) }
+      ra = { ((~(sa & load)) & clrbar) }
+      sb = { ~(B & load & clrbar) }
+      rb = { ((~(sb & load)) & clrbar) }
+      sc = { ~(C & load & clrbar) }
+      rc = { ((~(sc & load)) & clrbar) }
+      sd = { ~(D & load & clrbar) }
+      rd = { ((~(sd & load)) & clrbar) }
+      BOBAR_O = { ~(downbar & qabar & qbbar & qcbar & qdbar) }
+      COBAR_O =  { ~(upbar & QA_O & QB_O & QC_O & QD_O) }
+      ta = { (upbar | downbar) }
+      tb = { (downbar & qabar) | (upbar & QA_O)}
+      tc = { (downbar & qabar & qbbar) | (upbar & QA_O & QB_O)}
+      td = { (downbar & qabar & qbbar & qcbar) | (QA_O & QB_O & QC_O &  upbar)}

uf0 jkFF(1) DPWR DGND
+ sa ra ta $D_HI $D_HI QA_O qabar
+ D0_EFF IO_LS

uf1 jkFF(1) DPWR DGND
+ sb rb tb $D_HI $D_HI QB_O qbbar
+ D0_EFF IO_LS

uf2 jkFF(1) DPWR DGND
+ sc rc tc $D_HI $D_HI QC_O qcbar
+ D0_EFF IO_LS

uf3 jkFF(1) DPWR DGND
+ sd rd td $D_HI $D_HI QD_O qdbar
+ D0_EFF IO_LS

Udly PINDLY (6,0,8) DPWR DGND
+    COBAR_O QA_O QB_O QC_O QD_O BOBAR_O
+    DOWN UP CLR LOADBAR A B C D
+    COBAR QA QB QC QD BOBAR
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+     LOAD_DAT = { CHANGED(LOADBAR,0) }
+     CLKUP  = { CHANGED(UP,0) }
+     CLKDOWN  = { CHANGED(DOWN,0) }
+     CLEAR = { CHANGED(CLR,0) }
+     DATA = { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+       COBAR = {
+            CASE(
+                 CLKUP & TRN_LH, DELAY(-1,17ns,26ns),
+                 CLKUP & TRN_HL, DELAY(-1,18ns,24ns),
+                 DELAY(-1,19ns,27ns)
+                )
+            }
+       QA QB QC QD = {
+            CASE(
+                 CLEAR & TRN_HL, DELAY(-1,23ns,35ns),
+                 LOAD_DAT & TRN_LH, DELAY(-1,24ns,40ns),
+                 LOAD_DAT & TRN_HL, DELAY(-1,25ns,40ns),
+                 (CLKUP | CLKDOWN) & TRN_LH, DELAY(-1,27ns,38ns),
+                 (CLKUP | CLKDOWN) & TRN_HL, DELAY(-1,30ns,47ns),
+                 DELAY(-1,31ns,48ns)
+                )
+            }
+       BOBAR = {
+            CASE(
+                 CLKDOWN & TRN_LH, DELAY(-1,16ns,24ns),
+                 CLKDOWN & TRN_HL, DELAY(-1,15ns,24ns),
+                 DELAY(-1,17ns,25ns)
+                )
+            }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLR UP DOWN LOADBAR A B C D
+          IO_LS
+
+      FREQ:
+         NODE = UP
+         MAXFREQ = 25MEG
+      FREQ:
+         NODE = DOWN
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = UP
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = DOWN
+         MIN_HI = 20ns
+         MIN_LO = 20ns
+      WIDTH:
+         NODE = CLR
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = LOADBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = LOADBAR
+        DATA(4) = A B C D
+        SETUPTIME = 20ns
+        HOLDTIME = 5n
+        WHEN = { CLR != '1 }
+      SETUP_HOLD:
+        CLOCK LH = UP
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 15ns
+      SETUP_HOLD:
+        CLOCK LH = DOWN
+        DATA(2) = CLR LOADBAR
+        SETUPTIME = 15ns

.ENDS 74LS193
*
*
* ----------------------------------------------------------- 74194 ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-645 to 2-654
*  jds    2/18/94
*
.SUBCKT 74194 A B C D CLRBAR CLK S0 S1 SR_SER SL_SER QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74194 LOGICEXP (13, 9) DPWR DGND
+        S0 S1 SL_SER SR_SER CLK A B C D QA_O QB_O QC_O QD_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( SL_SER & s0bar) }
+      i0b = { ( D & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & QC_O) }
+      i1a = { ( QD_O & s0bar) }
+      i1b = { ( C & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & QB_O) }
+      i2a = { ( QC_O & s0bar) }
+      i2b = { ( B & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & QA_O) }
+      i3a = { ( QB_O & s0bar) }
+      i3b = { ( A & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & SR_SER) }
+
+      C1 = { ~((s0bar & s1bar) | CLK ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_STD

Udly PINDLY (4,0,2) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLRBAR CLK
+    QA QB QC QD
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,19ns,30ns),
+                       CLOCK & TRN_LH, DELAY(-1,14ns,22ns),
+                       CLOCK & TRN_HL, DELAY(-1,17ns,26ns),
+                       DELAY(-1,20ns,31ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          CLRBAR CLK S0 S1 SR_SER SL_SER A B C D
+          IO_STD
+
+      BOOLEAN:
+         NOT_CLR = { (CLRBAR != '0) }
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20n
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 30n
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = SL_SER
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='0 ^CHANGED_LH(S1,0)) & (S0!='1 ^CHANGED_HL(S0,0))}
+      SETUP_HOLD:
+        DATA(1) = SR_SER
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='1 ^CHANGED_HL(S1,0)) &(S0!='0 ^CHANGED_LH(S0,0))}
+      SETUP_HOLD:
+        DATA(4) = A B C D
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='0^CHANGED_LH(S1,0))&(S0!='0 ^ CHANGED_LH(S0,0))}
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME = 25NS
+      GENERAL:
+        WHEN = { ( (CLK== '0) & ( CHANGED(S1,0) | CHANGED(S0,0) ) )}
+        MESSAGE = "Specification Violated: Mode can only change when clock is high."


.ENDS 74194
*
*
*-------------------------------------------------------74AC194------------
*
* The 74AC194 4-Bit Bidirectional Universal Shift Register 
* Motorola FACT Data, 1993, pages 5-151 to 5-156
* jat 8/2/95

.SUBCKT 74AC194
+ P0 P1 P2 P3 DSL DSR S0 S1 CP MRBAR Q0 Q1 Q2 Q3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,9) DPWR DGND
+ DSR DSL S0 S1 P0 P1 P2 P3 Q_0 Q_1 Q_2 Q_3 CP
+ J0 J1 J2 J3 K0 K1 K2 K3 CPBAR
+ D0_GATE IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        J0 = {(DSR & (~S1) & S0) | (S0 & S1 & P0) |
+               ((~S0) & S1 & Q_1) | ((~S0) & (~S1) & Q_0)}
+        J1 = {(Q_0 & (~S1) & S0) | (S0 & S1 & P1) |
+               ((~S0) & S1 & Q_2) | ((~S0) & (~S1) & Q_1)}
+        J2 = {(Q_1 & (~S1) & S0) | (S0 & S1 & P2) |
+               ((~S0) & S1 & Q_3) | ((~S0) & (~S1) & Q_2)}
+        J3 = {(Q_2 & (~S1) & S0) | (S0 & S1 & P3) |
+               ((~S0) & S1 & DSL) | ((~S0) & (~S1) & Q_3)}
+        K0 = {~J0}
+        K1 = {~J1}
+        K2 = {~J2}
+        K3 = {~J3}
+        CPBAR = {~CP}

U2 JKFF(4) DPWR DGND
+ $D_HI MRBAR CPBAR
+ J0 J1 J2 J3
+ K0 K1 K2 K3 
+ Q_0 Q_1 Q_2 Q_3
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,2) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3
+ CP MRBAR
+ Q0 Q1 Q2 Q3
+ IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CP,0)}
+          CLEAR = {CHANGED(MRBAR,0)}
+ PINDLY:
+         Q0 Q1 Q2 Q3 = {
+           CASE(
+              CLEAR & TRN_HL, DELAY(2NS,-1,9NS),
+              EDGE & (TRN_LH | TRN_HL), DELAY(2NS,-1,12.5NS),
+              DELAY(3NS,-1,13.5NS))}

U4 CONSTRAINT(10) DPWR DGND
+ CP P0 P1 P2 P3 S0 S1 MRBAR DSL DSR
+ IO_AC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 3.5NS
+        HOLDTIME = 2.5NS
+ SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = S0 S1
+        SETUPTIME = 5NS
+        HOLDTIME = 2.5NS
+ SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = MRBAR
+        SETUPTIME_HI = 1NS
+ SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = DSL DSR
+        SETUPTIME = 4.5NS
+        HOLDTIME = 2.5NS
+ WIDTH:
+        NODE = CP
+        MIN_LO = 4.5NS
+        MIN_HI = 4.5NS
+ WIDTH:
+        NODE = MRBAR
+        MIN_LO = 4.5NS
+ FREQ:
+        NODE = CP
+        MAXFREQ = 150MEG

.ENDS 74AC194
*
*
*-------------------------------------------------------74ACT194------------
*
* The 74ACT194 4-Bit Bidirectional Universal Shift Register 
* TI Advanced CMOS Logic Data Book, 1993, pages 2-253 to 2-258
* (Note that the logic diagram has S1 and S0 reversed, which causes right
* and left shifting to be reversed relative to the function table.  This part
* will be modeled after the function table description instead.)
* jat 8/1/95

.SUBCKT 74ACT194
+ A B C D SL_SER SR_SER S0 S1 CLK CLRBAR QA QB QC QD
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,9) DPWR DGND
+ SR_SER SL_SER S0 S1 A B C D Q_A Q_B Q_C Q_D CLK
+ JA JB JC JD KA KB KC KD CLKBAR
+ D0_GATE IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        JA = {(SR_SER & (~S1) & S0) | (S0 & S1 & A) |
+               ((~S0) & S1 & Q_B) | ((~S0) & (~S1) & Q_A)}
+        JB = {(Q_A & (~S1) & S0) | (S0 & S1 & B) |
+               ((~S0) & S1 & Q_C) | ((~S0) & (~S1) & Q_B)}
+        JC = {(Q_B & (~S1) & S0) | (S0 & S1 & C) |
+               ((~S0) & S1 & Q_D) | ((~S0) & (~S1) & Q_C)}
+        JD = {(Q_C & (~S1) & S0) | (S0 & S1 & D) |
+               ((~S0) & S1 & SL_SER) | ((~S0) & (~S1) & Q_D)}
+        KA = {~JA}
+        KB = {~JB}
+        KC = {~JC}
+        KD = {~JD}
+        CLKBAR = {~CLK}

U2 JKFF(4) DPWR DGND
+ $D_HI CLRBAR CLKBAR
+ JA JB JC JD
+ KA KB KC KD 
+ Q_A Q_B Q_C Q_D
+ $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(4,0,2) DPWR DGND
+ Q_A Q_B Q_C Q_D
+ CLK CLRBAR
+ QA QB QC QD
+ IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CLK,0)}
+          CLEAR = {CHANGED(CLRBAR,0)}
+ PINDLY:
+         QA QB QC QD = {
+           CASE(
+              CLEAR & (TRN_LH | TRN_HL), DELAY(2.9NS,7.1NS,9.1NS),
+              EDGE & TRN_LH, DELAY(2.2NS,5.8NS,6.9NS),
+              EDGE & TRN_HL, DELAY(2.6NS,6.6NS,7.7NS),
+              DELAY(3.9NS,8.1NS,10.1NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLK A B C D S0 S1 CLRBAR
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 4NS
+        HOLDTIME = 1NS
+ SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 6NS
+        HOLDTIME = 1.5NS
+ SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 1NS
+ WIDTH:
+        NODE = CLK
+        MIN_LO = 5NS
+        MIN_HI = 5NS
+ WIDTH:
+        NODE = CLRBAR
+        MIN_LO = 4.5NS
+ FREQ:
+        NODE = CLK
+        MAXFREQ = 100MEG

.ENDS 74ACT194
*
*
* ----------------------------------------------------------- 74AS194 ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-229 to 2-234
*  jds    2/24/94
*
.SUBCKT 74AS194 A B C D CLRBAR CLK S0 S1 SR_SER SL_SER QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS194 LOGICEXP (13, 9) DPWR DGND
+        S0 S1 SL_SER SR_SER CLK A B C D QA_O QB_O QC_O QD_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_AS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( SL_SER & s0bar) }
+      i0b = { ( D & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & QC_O) }
+      i1a = { ( QD_O & s0bar) }
+      i1b = { ( C & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & QB_O) }
+      i2a = { ( QC_O & s0bar) }
+      i2b = { ( B & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & QA_O) }
+      i3a = { ( QB_O & s0bar) }
+      i3b = { ( A & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & SR_SER) }
+
+      C1 = { ~((s0bar & s1bar) | CLK ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_AS00

Udly PINDLY (4,0,2) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLRBAR CLK
+    QA QB QC QD
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(3ns,-1,7ns),
+                       CLOCK & TRN_LH, DELAY(3ns,-1,7ns),
+                       CLOCK & TRN_HL, DELAY(4ns,-1,12ns),
+                       DELAY(5ns,-1,13ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          CLRBAR CLK S0 S1 SR_SER SL_SER A B C D
+          IO_AS00
+
+      BOOLEAN:
+         NOT_CLR = { (CLRBAR != '0) }
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 80MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 2ns
+         MIN_LO = 6ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 4ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 8ns
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = SL_SER
+        CLOCK LH = CLK
+        SETUPTIME = 3ns
+        HOLDTIME = .5ns
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                               (S0!='1 ^ CHANGED_HL(S0,0)) }
+      SETUP_HOLD:
+        DATA(1) = SR_SER
+        CLOCK LH = CLK
+        SETUPTIME = 3ns
+        HOLDTIME = .5ns
+        WHEN = { NOT_CLR & (S1!='1 ^ CHANGED_HL(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        DATA(4) = A B C D
+        CLOCK LH = CLK
+        SETUPTIME = 3ns
+        HOLDTIME = .5ns
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 6ns

.ENDS 74AS194
*
*
* ----------------------------------------------------------- 74F194 ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The Philips Fast TTL Logic Series (IC15), 1992 Pages
*  jds    2/23/94       Pages 2-279 to 2-286
*
.SUBCKT 74F194 D0 D1 D2 D3 MRBAR CP S0 S1 DSR DSL Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F194 LOGICEXP (13, 9) DPWR DGND
+        S0 S1 DSL DSR CP D0 D1 D2 D3 Q0_O Q1_O Q2_O Q3_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( DSL & s0bar) }
+      i0b = { ( D3 & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & Q2_O) }
+      i1a = { ( Q3_O & s0bar) }
+      i1b = { ( D2 & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & Q1_O) }
+      i2a = { ( Q2_O & s0bar) }
+      i2b = { ( D1 & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & Q0_O) }
+      i3a = { ( Q1_O & s0bar) }
+      i3b = { ( D0 & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & DSR) }
+
+      C1 = { ~((s0bar & s1bar) | CP ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI MRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    Q0_O Q1_O Q2_O Q3_O Q0bar Q1bar Q2bar Q3bar
+    D0_EFF IO_F

Udly PINDLY (4,0,2) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O
+    MRBAR CP
+    Q0 Q1 Q2 Q3
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+
+    PINDLY:
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(4.5ns,8.6ns,12ns),
+                       CLOCK & TRN_LH, DELAY(3.5ns,5.2ns,7ns),
+                       CLOCK & TRN_HL, DELAY(3.5ns,5.5ns,7ns),
+                       DELAY(5.5ns,9.6ns,13ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          MRBAR CP S0 S1 DSR DSL D0 D1 D2 D3
+          IO_F
+
+      BOOLEAN:
+         NOT_CLR = { (MRBAR != '0) }
+      FREQ:
+         NODE = CP
+         MAXFREQ = 150MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 5n
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = S0 S1
+        SETUPTIME = 8n
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = DSL
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                               (S0!='1 ^ CHANGED_HL(S0,0)) }
+      SETUP_HOLD:
+        DATA(1) = DSR
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        WHEN = { NOT_CLR & (S1!='1 ^ CHANGED_HL(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        DATA(4) = D0 D1 D2 D3
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = MRBAR
+        SETUPTIME_HI = 7NS
+      GENERAL:
+        WHEN = { ( (CP== '0) & (CHANGED(S1,0) | CHANGED(S0,0)) )}
+        MESSAGE = "Specification Violated: Mode can only change when clock is high."

.ENDS 74F194
*
*
* ----------------------------------------------------------- 74HC194 ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-279 to 2-284
*  jds    2/23/94
*
.SUBCKT 74HC194 A B C D CLRBAR CLK S0 S1 SR_SER SL_SER QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC194 LOGICEXP (13, 9) DPWR DGND
+        S0 S1 SL_SER SR_SER CLK A B C D QA_O QB_O QC_O QD_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( SL_SER & s0bar) }
+      i0b = { ( D & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & QC_O) }
+      i1a = { ( QD_O & s0bar) }
+      i1b = { ( C & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & QB_O) }
+      i2a = { ( QC_O & s0bar) }
+      i2b = { ( B & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & QA_O) }
+      i3a = { ( QB_O & s0bar) }
+      i3b = { ( A & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & SR_SER) }
+
+      C1 = { ~((s0bar & s1bar) | CLK ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_HC

Udly PINDLY (4,0,2) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLRBAR CLK
+    QA QB QC QD
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,17ns,30ns),
+                       CLOCK, DELAY(-1,17ns,29ns),
+                       DELAY(-1,18ns,31ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          CLRBAR CLK S0 S1 SR_SER SL_SER A B C D
+          IO_HC
+
+      BOOLEAN:
+         NOT_CLR = { (CLRBAR != '0) }
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16n
+         MIN_LO = 16n
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 16n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 20n
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = SL_SER
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                               (S0!='1 ^ CHANGED_HL(S0,0)) }
+      SETUP_HOLD:
+        DATA(1) = SR_SER
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='1 ^ CHANGED_HL(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        DATA(4) = A B C D
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 20NS
+      GENERAL:
+        WHEN = { ( (CLK== '0) & (CHANGED(S1,0) | CHANGED(S0,0)) )}
+        MESSAGE = "Specification Violated: Mode can only change when clock is high."

.ENDS 74HC194
*
*
* ----------------------------------------------------------- 74HCT194 ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The Philips High Speed CMOS Logic Family (IC06), 1992 Pages
*  jds    2/24/94       Pages 445 to 451
*
.SUBCKT 74HCT194 D0 D1 D2 D3 MRBAR CP S0 S1 DSR DSL Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT194 LOGICEXP (13, 9) DPWR DGND
+        S0 S1 DSL DSR CP D0 D1 D2 D3 Q0_O Q1_O Q2_O Q3_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_HCT IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( DSL & s0bar) }
+      i0b = { ( D3 & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & Q2_O) }
+      i1a = { ( Q3_O & s0bar) }
+      i1b = { ( D2 & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & Q1_O) }
+      i2a = { ( Q2_O & s0bar) }
+      i2b = { ( D1 & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & Q0_O) }
+      i3a = { ( Q1_O & s0bar) }
+      i3b = { ( D0 & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & DSR) }
+
+      C1 = { ~((s0bar & s1bar) | CP ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI MRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    Q0_O Q1_O Q2_O Q3_O Q0bar Q1bar Q2bar Q3bar
+    D0_EFF IO_HCT

Udly PINDLY (4,0,2) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O
+    MRBAR CP
+    Q0 Q1 Q2 Q3
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+
+    PINDLY:
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,14ns,28ns),
+                       CLOCK , DELAY(-1,17ns,29ns),
+                       DELAY(-1,18ns,30ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          MRBAR CP S0 S1 DSR DSL D0 D1 D2 D3
+          IO_HCT
+
+      BOOLEAN:
+         NOT_CLR = { (MRBAR != '0) }
+      FREQ:
+         NODE = CP
+         MAXFREQ = 77MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 6n
+         MIN_LO = 6n
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 6n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = S0 S1
+        SETUPTIME = 8n
+        HOLDTIME = 4n
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = DSL
+        CLOCK LH = CP
+        SETUPTIME = 7n
+        HOLDTIME = 5n
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                               (S0!='1 ^ CHANGED_HL(S0,0)) }
+      SETUP_HOLD:
+        DATA(1) = DSR
+        CLOCK LH = CP
+        SETUPTIME = 7n
+        HOLDTIME = 6n
+        WHEN = { NOT_CLR & (S1!='1 ^ CHANGED_HL(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        DATA(4) = D0 D1 D2 D3
+        CLOCK LH = CP
+        SETUPTIME = 6n
+        HOLDTIME = 5n
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = MRBAR
+        SETUPTIME_HI = 6n
+      GENERAL:
+        WHEN = { ( (CP== '0) & (CHANGED(S1,0) | CHANGED(S0,0)) )}
+        MESSAGE = "Specification Violated: Mode can only change when clock is high."

.ENDS 74HCT194
*
*
* ----------------------------------------------------------- 74LS194A ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-645 to 2-654
*  jds    2/24/94
*
.SUBCKT 74LS194A A B C D CLRBAR CLK S0 S1 SR_SER SL_SER QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS194A LOGICEXP (13, 9) DPWR DGND
+        S0 S1 SL_SER SR_SER CLK A B C D QA_O QB_O QC_O QD_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( SL_SER & s0bar) }
+      i0b = { ( D & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & QC_O) }
+      i1a = { ( QD_O & s0bar) }
+      i1b = { ( C & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & QB_O) }
+      i2a = { ( QC_O & s0bar) }
+      i2b = { ( B & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & QA_O) }
+      i3a = { ( QB_O & s0bar) }
+      i3b = { ( A & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & SR_SER) }
+
+      C1 = { ~((s0bar & s1bar) | CLK ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_LS

Udly PINDLY (4,0,2) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLRBAR CLK
+    QA QB QC QD
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,19ns,30ns),
+                       CLOCK & TRN_LH, DELAY(-1,14ns,22ns),
+                       CLOCK & TRN_HL, DELAY(-1,17ns,26ns),
+                       DELAY(-1,20ns,31ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          CLRBAR CLK S0 S1 SR_SER SL_SER A B C D
+          IO_LS
+
+      BOOLEAN:
+         NOT_CLR = { (CLRBAR != '0) }
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20n
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 30n
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = SL_SER
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                               (S0!='1 ^ CHANGED_HL(S0,0)) }
+      SETUP_HOLD:
+        DATA(1) = SR_SER
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='1 ^ CHANGED_HL(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        DATA(4) = A B C D
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 25NS
+      GENERAL:
+        WHEN = { ( (CLK== '0) & (CHANGED(S1,0) | CHANGED(S0,0)) )}
+        MESSAGE = "Specification Violated: Mode can only change when clock is high."

.ENDS 74LS194A
*
*
* ----------------------------------------------------------- 74S194 ------
*  4-Bit Bidirectional Universal Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-645 to 2-654
*  jds    2/23/94
*
.SUBCKT 74S194 A B C D CLRBAR CLK S0 S1 SR_SER SL_SER QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S194 LOGICEXP (13, 9) DPWR DGND
+        S0 S1 SL_SER SR_SER CLK A B C D QA_O QB_O QC_O QD_O
+        i0 i1 i2 i3 i0bar i1bar i2bar i3bar C1
+        D0_GATE IO_S IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      s0bar = { (~S0) }
+      s1bar = { (~S1) }
+      i0a = { ( SL_SER & s0bar) }
+      i0b = { ( D & (~(s0bar | s1bar)) ) }
+      i0c = { (s1bar & QC_O) }
+      i1a = { ( QD_O & s0bar) }
+      i1b = { ( C & (~(s0bar | s1bar)) ) }
+      i1c = { (s1bar & QB_O) }
+      i2a = { ( QC_O & s0bar) }
+      i2b = { ( B & (~(s0bar | s1bar)) ) }
+      i2c = { (s1bar & QA_O) }
+      i3a = { ( QB_O & s0bar) }
+      i3b = { ( A & (~(s0bar | s1bar)) ) }
+      i3c = { (s1bar & SR_SER) }
+
+      C1 = { ~((s0bar & s1bar) | CLK ) }
+      i0 = { ~( i0a | i0b | i0c) }
+      i1 = { ~( i1a | i1b | i1c) }
+      i2 = { ~( i2a | i2b | i2c) }
+      i3 = { ~( i3a | i3b | i3c) }
+      i0bar = { ~i0 }
+      i1bar = { ~i1 }
+      i2bar = { ~i2 }
+      i3bar = { ~i3 }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR C1
+    i3bar i2bar i1bar i0bar i3 i2 i1 i0
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_S

Udly PINDLY (4,0,2) DPWR DGND
+    QA_O QB_O QC_O QD_O
+    CLRBAR CLK
+    QA QB QC QD
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,12.5ns,18.5ns),
+                       CLOCK & TRN_LH, DELAY(4ns,8ns,12ns),
+                       CLOCK & TRN_HL, DELAY(4ns,11ns,16.5ns),
+                       DELAY(5n,13.5ns,19.5ns)
+                       )
+                     }

Ucnstr CONSTRAINT(10) DPWR DGND
+          CLRBAR CLK S0 S1 SR_SER SL_SER A B C D
+          IO_S
+
+      BOOLEAN:
+         NOT_CLR = { (CLRBAR != '0) }
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 70MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 7n
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 12n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = S0 S1
+        SETUPTIME = 11n
+        HOLDTIME = 3NS
+        WHEN = { NOT_CLR }
+      SETUP_HOLD:
+        DATA(1) = SL_SER
+        CLOCK LH = CLK
+        SETUPTIME = 5NS
+        HOLDTIME = 3NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                               (S0!='1 ^ CHANGED_HL(S0,0)) }
+      SETUP_HOLD:
+        DATA(1) = SR_SER
+        CLOCK LH = CLK
+        SETUPTIME = 5NS
+        HOLDTIME = 3NS
+        WHEN = { NOT_CLR & (S1!='1 ^ CHANGED_HL(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        DATA(4) = A B C D
+        CLOCK LH = CLK
+        SETUPTIME = 5NS
+        HOLDTIME = 3NS
+        WHEN = { NOT_CLR & (S1!='0 ^ CHANGED_LH(S1,0)) &
+                              (S0!='0 ^ CHANGED_LH(S0,0)) }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 9NS
+      GENERAL:
+        WHEN = { ( (CLK== '0) & (CHANGED(S1,0) | CHANGED(S0,0)) )}
+        MESSAGE = "Specification Violated: Mode can only change when clock is high."

.ENDS 74S194
.TRAN 2e-008 1e-006 0 
.TEMP 27
