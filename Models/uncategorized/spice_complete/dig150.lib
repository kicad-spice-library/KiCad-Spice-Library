* -------------------------------------------------------------------------
*    Spectrum Software, all rights reserved, copywrite 1994,
*    Micro-Cap V Digital Library
*
*    Parts in this library are modeled at ambient room temperature (TA=25øC)
*    unless otherwise noted.
*
*    DIGITAL LIBRARY range 74150-74166
*
* ----------------------------------------------------------- 74150 ------
*  Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, TI Pages 2-457 to 2-464
*  jds    2/15/94
*
.SUBCKT 74150  E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 E10 E11 E12 E13 E14 E15
+              A B C D GBAR W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74150 LOGICEXP (21,1) DPWR DGND
+      E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 E10 E11 E12 E13 E14 E15
+      A B C D GBAR W_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      dbar = {(~D)}
+      a0 = {(E0 & abar & bbar & cbar & dbar & g)}
+      a1 = {(E1 & A & bbar & cbar & dbar & g)}
+      a2 = {(E2 & abar & B & cbar & dbar & g)}
+      a3 = {(E3 & A & B & cbar & dbar & g)}
+      a4 = {(E4 & abar & bbar & C & dbar & g)}
+      a5 = {(E5 & A & bbar & C & dbar & g)}
+      a6 = {(E6 & abar & B & C & dbar & g)}
+      a7 = {(E7 & A & B & C & dbar & g)}
+      a8 = {(E8 & abar & bbar & cbar & D & g)}
+      a9 = {(E9 & A & bbar & cbar & D & g)}
+      a10 = {(E10 & abar & B & cbar & D & g)}
+      a11 = {(E11 & A & B & cbar & D & g)}
+      a12 = {(E12 & abar & bbar & C & D & g)}
+      a13 = {(E13 & A & bbar & C & D & g)}
+      a14 = {(E14 & abar & B & C & D & g)}
+      a15 = {(E15 & A & B & C & D & g)}
+
+      Wa = { (a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7) }
+      Wb = { (a8 | a9 | a10 | a11 | a12 | a13 | a14 | a15) }
+      W_O  = { ~(Wa | Wb) }

Udly PINDLY (1,0,21) DPWR DGND
+    W_O
+    E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 E10 E11 E12 E13 E14 E15
+    A B C D GBAR
+    W
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(E0,0) | CHANGED(E1,0) | CHANGED(E2,0) | CHANGED(E3,0)
+            | CHANGED(E4,0) | CHANGED(E5,0) | CHANGED(E6,0) | CHANGED(E7,0)
+            | CHANGED(E8,0) | CHANGED(E9,0) | CHANGED(E10,0) | CHANGED(E11,0)
+            | CHANGED(E12,0) | CHANGED(E13,0) | CHANGED(E14,0) | CHANGED(E15,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,23ns,35ns),
+                 SELECT & TRN_HL, DELAY(-1,22ns,33ns),
+                 STROBE & TRN_LH, DELAY(-1,15.5ns,24ns),
+                 STROBE & TRN_HL, DELAY(-1,21ns,30ns),
+                 DATA & TRN_LH, DELAY(-1,8.5ns,14ns),
+                 DATA & TRN_HL, DELAY(-1,13ns,20ns),
+                 DELAY(-1,24ns,36ns)
+                )
+            }

.ENDS 74150
*
*
* ----------------------------------------------------------- 74151A ------
*  Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, TI Pages 2-457 to 2-464
*  jds    2/16/94
*
.SUBCKT 74151A  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74151A LOGICEXP (12,2) DPWR DGND
+      D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~W_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,17ns,26ns),
+                 SELECT & TRN_HL, DELAY(-1,19ns,30ns),
+                 STROBE & TRN_LH, DELAY(-1,14ns,21ns),
+                 STROBE & TRN_HL, DELAY(-1,15ns,23ns),
+                 DATA & TRN_LH, DELAY(-1,8ns,14ns),
+                 DATA & TRN_HL, DELAY(-1,8ns,14ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,25ns,38ns),
+                 SELECT & TRN_HL, DELAY(-1,25ns,38ns),
+                 STROBE & TRN_LH, DELAY(-1,21ns,33ns),
+                 STROBE & TRN_HL, DELAY(-1,22ns,33ns),
+                 DATA & TRN_LH, DELAY(-1,13ns,20ns),
+                 DATA & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,26ns,39ns)
+                )
+            }

.ENDS 74151A
*
*
* ----------------------------------------------------------- 74AC151 ------
*  8-Input Multiplexers
*
*  NS FACT Advanced CMOS Logic Data Book, 1989
*  jds    2/16/94   Pages 4-62 to 4-67
*
.SUBCKT 74AC151  I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Z ZBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC151 LOGICEXP (12,2) DPWR DGND
+        I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Z_O ZBAR_O
+        D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      s2bar = {(~S2)}
+      a0 = {(I0 & s0bar & s1bar & s2bar & e)}
+      a1 = {(I1 & S0 & s1bar & s2bar & e)}
+      a2 = {(I2 & s0bar & S1 & s2bar & e)}
+      a3 = {(I3 & S0 & S1 & s2bar & e)}
+      a4 = {(I4 & s0bar & s1bar & S2 & e)}
+      a5 = {(I5 & S0 & s1bar & S2 & e)}
+      a6 = {(I6 & s0bar & S1 & S2 & e)}
+      a7 = {(I7 & S0 & S1 & S2 & e)}
+
+      ZBAR_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Z_O = { (~ZBAR_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    Z_O ZBAR_O
+    I0 I1 I2 I3 I4 I5 I6 I7
+    S0 S1 S2 EBAR
+    Z ZBAR
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0) }
+       STROBE= { CHANGED(EBAR,0) }
+       DATA={ CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+              CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) }
+
+    PINDLY:
+       Z ZBAR = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(2.5ns,8.5ns,13ns),
+                 SELECT & TRN_HL, DELAY(2ns,8.5ns,13ns),
+                 STROBE & TRN_LH, DELAY(2ns,6ns,10ns),
+                 STROBE & TRN_HL, DELAY(1.5ns,6.5ns,10ns),
+                 DATA & TRN_LH, DELAY(1.5ns,7ns,10.5ns),
+                 DATA & TRN_HL, DELAY(1.5ns,7ns,11ns),
+                 DELAY(3.5ns,9.5ns,14ns)
+                )
+            }

.ENDS 74AC151
*
*
* ----------------------------------------------------------- 74ACT151 ------
*  8-Input Multiplexers
*
*  NS FACT Advanced CMOS Logic Data Book, 1989
*  jds    2/16/94   Pages 4-62 to 4-67
*
.SUBCKT 74ACT151  I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Z ZBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ACT151 LOGICEXP (12,2) DPWR DGND
+        I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Z_O ZBAR_O
+        D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      s2bar = {(~S2)}
+      a0 = {(I0 & s0bar & s1bar & s2bar & e)}
+      a1 = {(I1 & S0 & s1bar & s2bar & e)}
+      a2 = {(I2 & s0bar & S1 & s2bar & e)}
+      a3 = {(I3 & S0 & S1 & s2bar & e)}
+      a4 = {(I4 & s0bar & s1bar & S2 & e)}
+      a5 = {(I5 & S0 & s1bar & S2 & e)}
+      a6 = {(I6 & s0bar & S1 & S2 & e)}
+      a7 = {(I7 & S0 & S1 & S2 & e)}
+
+      ZBAR_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Z_O = { (~ZBAR_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    Z_O ZBAR_O
+    I0 I1 I2 I3 I4 I5 I6 I7
+    S0 S1 S2 EBAR
+    Z ZBAR
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0) }
+       STROBE= { CHANGED(EBAR,0) }
+       DATA={ CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+              CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) }
+
+    PINDLY:
+       Z = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3.5ns,12.5ns,15.5ns),
+                 SELECT & TRN_HL, DELAY(3.5ns,12.5ns,15.5ns),
+                 STROBE & TRN_LH, DELAY(2.5ns,9.5ns,10ns),
+                 STROBE & TRN_HL, DELAY(2.5ns,9ns,10.5ns),
+                 DATA & TRN_LH, DELAY(3.5ns,11ns,11.5ns),
+                 DATA & TRN_HL, DELAY(3.5ns,11ns,12ns),
+                 DELAY(4.5ns,13.5ns,16.5ns)
+                )
+            }
+       ZBAR = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3.5ns,12.5ns,15ns),
+                 SELECT & TRN_HL, DELAY(4ns,12.5ns,16.5ns),
+                 STROBE & TRN_LH, DELAY(2.5ns,8.5ns,10ns),
+                 STROBE & TRN_HL, DELAY(3ns,10ns,10.5ns),
+                 DATA & TRN_LH, DELAY(3.5ns,11ns,12ns),
+                 DATA & TRN_HL, DELAY(4ns,11ns,12.5ns),
+                 DELAY(5ns,13.5ns,17.5ns)
+                )
+              }

.ENDS 74ACT151
*
*
* ----------------------------------------------------------- 74ALS151 ------
*  Data Selectors/Multiplexers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-129 to 2-132
*  jds    2/16/94
*
.SUBCKT 74ALS151  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS151 LOGICEXP (12,2) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+        D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~W_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(7ns,-1,24ns),
+                 SELECT & TRN_HL, DELAY(7ns,-1,23ns),
+                 STROBE & TRN_LH, DELAY(5ns,-1,19ns),
+                 STROBE & TRN_HL, DELAY(5ns,-1,23ns),
+                 DATA & TRN_LH, DELAY(3ns,-1,15ns),
+                 DATA & TRN_HL, DELAY(4ns,-1,15ns),
+                 DELAY(8ns,-1,25ns)
+                )
+            }
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4ns,-1,18ns),
+                 SELECT & TRN_HL, DELAY(8ns,-1,24ns),
+                 STROBE & TRN_LH, DELAY(4ns,-1,18ns),
+                 STROBE & TRN_HL, DELAY(4ns,-1,19ns),
+                 DATA & TRN_LH, DELAY(3ns,-1,10ns),
+                 DATA & TRN_HL, DELAY(5ns,-1,15ns),
+                 DELAY(9ns,-1,25ns)
+                )
+            }

.ENDS 74ALS151
*
*
* ----------------------------------------------------------- 74AS151 ------
*  Data Selectors/Multiplexers
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-129 to 2-132
*  jds    2/16/94
*
.SUBCKT 74AS151  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS151 LOGICEXP (12,2) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+        D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~W_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4ns,-1,12ns),
+                 SELECT & TRN_HL, DELAY(4ns,-1,12ns),
+                 STROBE & TRN_LH, DELAY(1.5ns,-1,6ns),
+                 STROBE & TRN_HL, DELAY(3ns,-1,10ns),
+                 DATA & TRN_LH, DELAY(2ns,-1,6.5ns),
+                 DATA & TRN_HL, DELAY(1ns,-1,4.5ns),
+                 DELAY(5ns,-1,13ns)
+                )
+            }
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4.5ns,-1,14.5ns),
+                 SELECT & TRN_HL, DELAY(4.5ns,-1,15ns),
+                 STROBE & TRN_LH, DELAY(4.5ns,-1,14ns),
+                 STROBE & TRN_HL, DELAY(3ns,-1,11ns),
+                 DATA & TRN_LH, DELAY(3ns,-1,10.5ns),
+                 DATA & TRN_HL, DELAY(3ns,-1,11ns),
+                 DELAY(5.5ns,-1,16ns)
+                )
+            }

.ENDS 74AS151
*
*
* ----------------------------------------------------------- 74F151 ------
*  8-Input Multiplexers
*
*  Philips FAST TTL Logic Series Data Book, 1992
*  jds    2/17/94   Pages 180 - 184
*
.SUBCKT 74F151  I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Y YBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F151 LOGICEXP (12,2) DPWR DGND
+        I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Y_O YBAR_O
+        D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      s2bar = {(~S2)}
+      a0 = {(I0 & s0bar & s1bar & s2bar & e)}
+      a1 = {(I1 & S0 & s1bar & s2bar & e)}
+      a2 = {(I2 & s0bar & S1 & s2bar & e)}
+      a3 = {(I3 & S0 & S1 & s2bar & e)}
+      a4 = {(I4 & s0bar & s1bar & S2 & e)}
+      a5 = {(I5 & S0 & s1bar & S2 & e)}
+      a6 = {(I6 & s0bar & S1 & S2 & e)}
+      a7 = {(I7 & S0 & S1 & S2 & e)}
+
+      YBAR_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~YBAR_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    Y_O YBAR_O
+    I0 I1 I2 I3 I4 I5 I6 I7
+    S0 S1 S2 EBAR
+    Y YBAR
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0) }
+       STROBE= { CHANGED(EBAR,0) }
+       DATA={ CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+              CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) }
+
+    PINDLY:
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4ns,7ns,9.5ns),
+                 SELECT & TRN_HL, DELAY(4.5ns,7ns,9ns),
+                 STROBE & TRN_LH, DELAY(6ns,8ns,10ns),
+                 STROBE & TRN_HL, DELAY(4ns,5.5ns,7ns),
+                 DATA & TRN_LH, DELAY(3.0ns,4.5ns,6.5ns),
+                 DATA & TRN_HL, DELAY(3.0ns,4.5ns,6.5ns),
+                 DELAY(7ns,9ns,10.5ns)
+                )
+            }
+       YBAR = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4ns,6.5ns,9ns),
+                 SELECT & TRN_HL, DELAY(2ns,4.5ns,7ns),
+                 STROBE & TRN_LH, DELAY(3.5ns,5ns,6.5ns),
+                 STROBE & TRN_HL, DELAY(4ns,5.5ns,7.5ns),
+                 DATA & TRN_LH, DELAY(2ns,4ns,6ns),
+                 DATA & TRN_HL, DELAY(1ns,2.5ns,4ns),
+                 DELAY(5ns,7.5ns,10ns)
+                )
+              }

.ENDS 74F151
*
*
* ----------------------------------------------------------- 74F151A ------
*  8-Input Multiplexers
*
*  Philips FAST TTL Logic Series Data Book, 1992
*  jds    2/17/94   Pages 180 - 184
*
.SUBCKT 74F151A  I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Y YBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F151A LOGICEXP (12,2) DPWR DGND
+        I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Y_O YBAR_O
+        D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      s2bar = {(~S2)}
+      a0 = {(I0 & s0bar & s1bar & s2bar & e)}
+      a1 = {(I1 & S0 & s1bar & s2bar & e)}
+      a2 = {(I2 & s0bar & S1 & s2bar & e)}
+      a3 = {(I3 & S0 & S1 & s2bar & e)}
+      a4 = {(I4 & s0bar & s1bar & S2 & e)}
+      a5 = {(I5 & S0 & s1bar & S2 & e)}
+      a6 = {(I6 & s0bar & S1 & S2 & e)}
+      a7 = {(I7 & S0 & S1 & S2 & e)}
+
+      YBAR_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~YBAR_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    Y_O YBAR_O
+    I0 I1 I2 I3 I4 I5 I6 I7
+    S0 S1 S2 EBAR
+    Y YBAR
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0) }
+       STROBE= { CHANGED(EBAR,0) }
+       DATA={ CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+              CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) }
+
+    PINDLY:
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4.5ns,6.5ns,10ns),
+                 SELECT & TRN_HL, DELAY(4ns,6ns,8ns),
+                 STROBE & TRN_LH, DELAY(4ns,6.5ns,9ns),
+                 STROBE & TRN_HL, DELAY(3ns,5ns,7ns),
+                 DATA & TRN_LH, DELAY(2.5ns,4.5ns,7ns),
+                 DATA & TRN_HL, DELAY(2.5ns,4.5ns,7ns),
+                 DELAY(5.5ns,7.5ns,11ns)
+                )
+            }
+       YBAR = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3.5ns,5.5ns,8ns),
+                 SELECT & TRN_HL, DELAY(2.5ns,4.5ns,7ns),
+                 STROBE & TRN_LH, DELAY(2.5ns,4.5ns,6.5ns),
+                 STROBE & TRN_HL, DELAY(2ns,3.5ns,5.5ns),
+                 DATA & TRN_LH, DELAY(2ns,4ns,7ns),
+                 DATA & TRN_HL, DELAY(1ns,2ns,4.5ns),
+                 DELAY(4.5ns,6.5ns,9ns)
+                )
+              }

.ENDS 74F151A
*
*
* ----------------------------------------------------------- 74F151B ------
*  1-OF-8 Data Selectors/Multiplexers
*
*  The F Logic Data Book, 1994, TI Pages 2-81 to 2-84
*  bss    12/11/95
*
.SUBCKT 74F151B  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F151B LOGICEXP (12,2) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+        D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      Y_O = { ( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      W_O = { (~Y_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3.8ns,5.2ns,9ns),
+                 SELECT & TRN_HL, DELAY(2.9ns,4.3ns,7.5ns),
+                 STROBE & TRN_LH, DELAY(3ns,4.1ns,6.1ns),
+                 STROBE & TRN_HL, DELAY(2.8ns,3.5ns,6ns),
+                 DATA & TRN_LH, DELAY(2.7ns,3.6ns,6.5ns),
+                 DATA & TRN_HL, DELAY(1.2ns,1.9ns,4ns),
+                 DELAY(4.8ns,6.2ns,10ns))}
+
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(4.5ns,6ns,10.5ns),
+                 SELECT & TRN_HL, DELAY(4ns,5.6ns,9ns),
+                 STROBE & TRN_LH, DELAY(4.4ns,5.3ns,9.5ns),
+                 STROBE & TRN_HL, DELAY(3.5ns,4.5ns,7ns),
+                 DATA & TRN_LH, DELAY(2.9ns,3.7ns,6.5ns),
+                 DATA & TRN_HL, DELAY(3.3ns,4.2ns,7ns),
+                 DELAY(5.5ns,7ns,11.5ns))}

.ENDS 74F151B
*
*
* ----------------------------------------------------------- 74HC151 ------
*  Data Selectors/Multiplexers
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-197 to 2-200
*  jds    2/16/94
*
.SUBCKT 74HC151  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC151 LOGICEXP (12,2) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+        D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~W_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+     W Y = {
+            CASE(
+                 SELECT, DELAY(-1,30ns,50ns),
+                 STROBE, DELAY(-1,15ns,25ns),
+                 DATA, DELAY(-1,23ns,39ns),
+                 DELAY(-1,31ns,51ns)
+                )
+            }

.ENDS 74HC151
*
*
* ----------------------------------------------------------- 74HCT151 ------
*  8-Input Multiplexers
*
*  Philips High Speed CMOS Logic Family Data Book, 1994
*  jds    2/25/94   Pages 291 - 295
*
.SUBCKT 74HCT151  I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Y YBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT151 LOGICEXP (12,2) DPWR DGND
+        I0 I1 I2 I3 I4 I5 I6 I7 S0 S1 S2 EBAR Y_O YBAR_O
+        D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      s2bar = {(~S2)}
+      a0 = {(I0 & s0bar & s1bar & s2bar & e)}
+      a1 = {(I1 & S0 & s1bar & s2bar & e)}
+      a2 = {(I2 & s0bar & S1 & s2bar & e)}
+      a3 = {(I3 & S0 & S1 & s2bar & e)}
+      a4 = {(I4 & s0bar & s1bar & S2 & e)}
+      a5 = {(I5 & S0 & s1bar & S2 & e)}
+      a6 = {(I6 & s0bar & S1 & S2 & e)}
+      a7 = {(I7 & S0 & S1 & S2 & e)}
+
+      YBAR_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~YBAR_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    Y_O YBAR_O
+    I0 I1 I2 I3 I4 I5 I6 I7
+    S0 S1 S2 EBAR
+    Y YBAR
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) | CHANGED(S2,0) }
+       STROBE= { CHANGED(EBAR,0) }
+       DATA={ CHANGED(I0,0) | CHANGED(I1,0) | CHANGED(I2,0) | CHANGED(I3,0) |
+              CHANGED(I4,0) | CHANGED(I5,0) | CHANGED(I6,0) | CHANGED(I7,0) }
+
+    PINDLY:
+       Y = {
+            CASE(
+                 SELECT, DELAY(-1,23ns,41ns),
+                 STROBE, DELAY(-1,16ns,29ns),
+                 DATA, DELAY(-1,22ns,38ns),
+                 DELAY(-1,24ns,42ns)
+                )
+            }
+       YBAR = {
+            CASE(
+                 SELECT, DELAY(-1,25ns,43ns),
+                 STROBE, DELAY(-1,21ns,36ns),
+                 DATA, DELAY(-1,22ns,38ns),
+                 DELAY(-1,26ns,44ns)
+                )
+              }

.ENDS 74HCT151
*
*
* ----------------------------------------------------------- 74LS151 ------
*  Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, TI Pages 2-457 to 2-464
*  jds    2/16/94
*
.SUBCKT 74LS151  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS151 LOGICEXP (12,2) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+        D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~W_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,14ns,23ns),
+                 SELECT & TRN_HL, DELAY(-1,20ns,32ns),
+                 STROBE & TRN_LH, DELAY(-1,15ns,24ns),
+                 STROBE & TRN_HL, DELAY(-1,18ns,30ns),
+                 DATA & TRN_LH, DELAY(-1,13ns,21ns),
+                 DATA & TRN_HL, DELAY(-1,12ns,20ns),
+                 DELAY(-1,20ns,33ns)
+                )
+            }
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,27ns,43ns),
+                 SELECT & TRN_HL, DELAY(-1,18ns,30ns),
+                 STROBE & TRN_LH, DELAY(-1,26ns,42ns),
+                 STROBE & TRN_HL, DELAY(-1,20ns,32ns),
+                 DATA & TRN_LH, DELAY(-1,20ns,32ns),
+                 DATA & TRN_HL, DELAY(-1,16ns,26ns),
+                 DELAY(-1,28ns,44ns)
+                )
+            }

.ENDS 74LS151
*
*
* ----------------------------------------------------------- 74S151 ------
*  Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, TI Pages 2-457 to 2-464
*  jds    2/16/94
*
.SUBCKT 74S151  D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S151 LOGICEXP (12,2) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C GBAR Y_O W_O
+        D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar & g)}
+      a1 = {(D1 & A & bbar & cbar & g)}
+      a2 = {(D2 & abar & B & cbar & g)}
+      a3 = {(D3 & A & B & cbar & g)}
+      a4 = {(D4 & abar & bbar & C & g)}
+      a5 = {(D5 & A & bbar & C & g)}
+      a6 = {(D6 & abar & B & C & g)}
+      a7 = {(D7 & A & B & C & g)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }
+      Y_O = { (~W_O) }

Udly PINDLY (2,0,12) DPWR DGND
+    W_O Y_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C GBAR
+    W Y
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       STROBE= { CHANGED(GBAR,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+       W = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,10ns,15ns),
+                 SELECT & TRN_HL, DELAY(-1,9ns,13.5ns),
+                 STROBE & TRN_LH, DELAY(-1,9ns,13ns),
+                 STROBE & TRN_HL, DELAY(-1,8.5ns,12ns),
+                 DATA & TRN_LH, DELAY(-1,4.5ns,7ns),
+                 DATA & TRN_HL, DELAY(-1,4.5ns,7ns),
+                 DELAY(-1,11ns,16ns)
+                )
+            }
+       Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,12ns,18ns),
+                 SELECT & TRN_HL, DELAY(-1,12ns,18ns),
+                 STROBE & TRN_LH, DELAY(-1,11ns,16.5ns),
+                 STROBE & TRN_HL, DELAY(-1,12ns,18ns),
+                 DATA & TRN_LH, DELAY(-1,8ns,12ns),
+                 DATA & TRN_HL, DELAY(-1,8ns,12ns),
+                 DELAY(-1,13ns,19ns)
+                )
+            }

.ENDS 74S151
*
*
* ----------------------------------------------------------- 74HC152 ------
*  8 Line to 1 Line Data Selectors/Multiplexers
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-201 2-204
*  jds    2/25/94
*
.SUBCKT 74HC152  D0 D1 D2 D3 D4 D5 D6 D7 A B C W
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC152 LOGICEXP (11,1) DPWR DGND
+        D0 D1 D2 D3 D4 D5 D6 D7 A B C W_O
+        D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = {(~A)}
+      bbar = {(~B)}
+      cbar = {(~C)}
+      a0 = {(D0 & abar & bbar & cbar)}
+      a1 = {(D1 & A & bbar & cbar)}
+      a2 = {(D2 & abar & B & cbar)}
+      a3 = {(D3 & A & B & cbar)}
+      a4 = {(D4 & abar & bbar & C)}
+      a5 = {(D5 & A & bbar & C)}
+      a6 = {(D6 & abar & B & C)}
+      a7 = {(D7 & A & B & C)}
+
+      W_O = { ~( a0 | a1 | a2 | a3 | a4 | a5 | a6 | a7 ) }

Udly PINDLY (1,0,11) DPWR DGND
+    W_O
+    D0 D1 D2 D3 D4 D5 D6 D7
+    A B C
+    W
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) }
+       DATA={ CHANGED(D0,0) | CHANGED(D1,0) | CHANGED(D2,0) | CHANGED(D3,0) |
+              CHANGED(D4,0) | CHANGED(D5,0) | CHANGED(D6,0) | CHANGED(D7,0) }
+
+    PINDLY:
+     W   = {
+            CASE(
+                 SELECT, DELAY(-1,18ns,34ns),
+                 DATA, DELAY(-1,14ns,26ns),
+                 DELAY(-1,19ns,35ns)
+                )
+            }

.ENDS 74HC152
*
*
* ----------------------------------------------------------- 74153 ------
*  4 Line to 1 Line Multiplexer
*
*  The TTL Logic Data Book, 1988, TI Pages 2-465 to 2-470
*  jds    2/25/94
*
.SUBCKT 74153  1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y 2Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74153 LOGICEXP (12,2) DPWR DGND
+      1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y_O 2Y_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      1g = {(~1GBAR)}
+      2g = {(~2GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      a0 = {(1C0 & abar & bbar & 1g)}
+      a1 = {(1C1 & A & bbar & 1g)}
+      a2 = {(1C2 & abar & B & 1g)}
+      a3 = {(1C3 & A & B & 1g)}
+      b0 = {(2C0 & abar & bbar & 2g)}
+      b1 = {(2C1 & A & bbar & 2g)}
+      b2 = {(2C2 & abar & B & 2g)}
+      b3 = {(2C3 & A & B & 2g)}
+
+      1Y_O = { ( a0 | a1 | a2 | a3) }
+      2Y_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    1Y_O 2Y_O
+    1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+    A B 1GBAR 2GBAR
+    1Y 2Y
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) }
+       STROBE1= { CHANGED(1GBAR,0) }
+       STROBE2= { CHANGED(2GBAR,0) }
+       DATA1={ CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) | CHANGED(1C3,0) }
+       DATA2={ CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) | CHANGED(2C3,0) }
+
+    PINDLY:
+       1Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,22ns,34ns),
+                 SELECT & TRN_HL, DELAY(-1,22ns,34ns),
+                 STROBE1 & TRN_LH, DELAY(-1,19ns,30ns),
+                 STROBE1 & TRN_HL, DELAY(-1,15ns,23ns),
+                 DATA1 & TRN_LH, DELAY(-1,12ns,18ns),
+                 DATA1 & TRN_HL, DELAY(-1,15ns,23ns),
+                 DELAY(-1,23ns,35ns)
+                )
+            }
+       2Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,22ns,34ns),
+                 SELECT & TRN_HL, DELAY(-1,22ns,34ns),
+                 STROBE2 & TRN_LH, DELAY(-1,19ns,30ns),
+                 STROBE2 & TRN_HL, DELAY(-1,15ns,23ns),
+                 DATA2 & TRN_LH, DELAY(-1,12ns,18ns),
+                 DATA2 & TRN_HL, DELAY(-1,15ns,23ns),
+                 DELAY(-1,23ns,35ns)
+                )
+            }

.ENDS 74153
*
*
* ----------------------------------------------------------- 74AC153 ------
*  4 Line to 1 Line Multiplexer
*
*  The Fact Advanced CMOS Logic, 1989, National Semiconductor
*  jds    2/25/94     Pages 4-68 to 4-72
*
.SUBCKT 74AC153  I0A I1A I2A I3A I0B I1B I2B I3B S0 S1 EABAR EBBAR ZA ZB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC153 LOGICEXP (12,2) DPWR DGND
+      I0A I1A I2A I3A I0B I1B I2B I3B S0 S1 EABAR EBBAR ZA_O ZB_O
+      D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      ea = {(~EABAR)}
+      eb = {(~EBBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      a0 = {(I0A & s0bar & s1bar & ea)}
+      a1 = {(I1A & S0 & s1bar & ea)}
+      a2 = {(I2A & s0bar & S1 & ea)}
+      a3 = {(I3A & S0 & S1 & ea)}
+      b0 = {(I0B & s0bar & s1bar & eb)}
+      b1 = {(I1B & S0 & s1bar & eb)}
+      b2 = {(I2B & s0bar & S1 & eb)}
+      b3 = {(I3B & S0 & S1 & eb)}
+
+      ZA_O = { ( a0 | a1 | a2 | a3) }
+      ZB_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    ZA_O ZB_O
+    I0A I1A I2A I3A I0B I1B I2B I3B
+    S0 S1 EABAR EBBAR
+    ZA ZB
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) }
+       STROBE1= { CHANGED(EABAR,0) }
+       STROBE2= { CHANGED(EBBAR,0) }
+       DATA1={ CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I2A,0) | CHANGED(I3A,0) }
+       DATA2={ CHANGED(I0B,0) | CHANGED(I1B,0) | CHANGED(I2B,0) | CHANGED(I3B,0) }
+
+    PINDLY:
+       ZA = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(2ns,6.5ns,11ns),
+                 SELECT & TRN_HL, DELAY(2ns,6.5ns,11ns),
+                 STROBE1 & TRN_LH, DELAY(1.5ns,5.5ns,9.5ns),
+                 STROBE1 & TRN_HL, DELAY(2ns,5ns,8ns),
+                 DATA1 & TRN_LH, DELAY(1.5ns,5.5ns,9ns),
+                 DATA1 & TRN_HL, DELAY(1.5ns,5.5ns,8.5ns),
+                 DELAY(3ns,7.5ns,12ns)
+                )
+            }
+       ZB = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(2ns,6.5ns,11ns),
+                 SELECT & TRN_HL, DELAY(2ns,6.5ns,11ns),
+                 STROBE2 & TRN_LH, DELAY(1.5ns,5.5ns,9.5ns),
+                 STROBE2 & TRN_HL, DELAY(2ns,5ns,8ns),
+                 DATA2 & TRN_LH, DELAY(1.5ns,5.5ns,9ns),
+                 DATA2 & TRN_HL, DELAY(1.5ns,5.5ns,8.5ns),
+                 DELAY(3ns,7.5ns,12ns)
+                )
+            }

.ENDS 74AC153
*
*
* ----------------------------------------------------------- 74ACT153 ------
*  4 Line to 1 Line Multiplexer
*
*  The Fact Advanced CMOS Logic, 1989, National Semiconductor
*  jds    2/25/94     Pages 4-68 to 4-72
*
.SUBCKT 74ACT153  I0A I1A I2A I3A I0B I1B I2B I3B S0 S1 EABAR EBBAR ZA ZB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ACT153 LOGICEXP (12,2) DPWR DGND
+      I0A I1A I2A I3A I0B I1B I2B I3B S0 S1 EABAR EBBAR ZA_O ZB_O
+      D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      ea = {(~EABAR)}
+      eb = {(~EBBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      a0 = {(I0A & s0bar & s1bar & ea)}
+      a1 = {(I1A & S0 & s1bar & ea)}
+      a2 = {(I2A & s0bar & S1 & ea)}
+      a3 = {(I3A & S0 & S1 & ea)}
+      b0 = {(I0B & s0bar & s1bar & eb)}
+      b1 = {(I1B & S0 & s1bar & eb)}
+      b2 = {(I2B & s0bar & S1 & eb)}
+      b3 = {(I3B & S0 & S1 & eb)}
+
+      ZA_O = { ( a0 | a1 | a2 | a3) }
+      ZB_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    ZA_O ZB_O
+    I0A I1A I2A I3A I0B I1B I2B I3B
+    S0 S1 EABAR EBBAR
+    ZA ZB
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) }
+       STROBE1= { CHANGED(EABAR,0) }
+       STROBE2= { CHANGED(EBBAR,0) }
+       DATA1={ CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I2A,0) | CHANGED(I3A,0) }
+       DATA2={ CHANGED(I0B,0) | CHANGED(I1B,0) | CHANGED(I2B,0) | CHANGED(I3B,0) }
+
+    PINDLY:
+       ZA = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3ns,7ns,11.5ns),
+                 SELECT & TRN_HL, DELAY(3ns,7ns,11.5ns),
+                 STROBE1 & TRN_LH, DELAY(2ns,6.5ns,10.5ns),
+                 STROBE1 & TRN_HL, DELAY(3ns,6ns,9.5ns),
+                 DATA1 & TRN_LH, DELAY(2.5ns,5.5ns,9.5ns),
+                 DATA1 & TRN_HL, DELAY(2ns,5.5ns,9.5ns),
+                 DELAY(4ns,8ns,12.5ns)
+                )
+            }
+       ZB = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3ns,7ns,11.5ns),
+                 SELECT & TRN_HL, DELAY(3ns,7ns,11.5ns),
+                 STROBE2 & TRN_LH, DELAY(2ns,6.5ns,10.5ns),
+                 STROBE2 & TRN_HL, DELAY(3ns,6ns,9.5ns),
+                 DATA2 & TRN_LH, DELAY(2.5ns,5.5ns,9.5ns),
+                 DATA2 & TRN_HL, DELAY(2ns,5.5ns,9.5ns),
+                 DELAY(4ns,8ns,12.5ns)
+                )
+            }

.ENDS 74ACT153
*
*
* ----------------------------------------------------------- 74ALS153 ------
*  4 Line to 1 Line Multiplexer
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-133 to 2-136
*  jds    2/25/94
*
.SUBCKT 74ALS153  1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y 2Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS153 LOGICEXP (12,2) DPWR DGND
+      1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y_O 2Y_O
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      1g = {(~1GBAR)}
+      2g = {(~2GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      a0 = {(1C0 & abar & bbar & 1g)}
+      a1 = {(1C1 & A & bbar & 1g)}
+      a2 = {(1C2 & abar & B & 1g)}
+      a3 = {(1C3 & A & B & 1g)}
+      b0 = {(2C0 & abar & bbar & 2g)}
+      b1 = {(2C1 & A & bbar & 2g)}
+      b2 = {(2C2 & abar & B & 2g)}
+      b3 = {(2C3 & A & B & 2g)}
+
+      1Y_O = { ( a0 | a1 | a2 | a3) }
+      2Y_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    1Y_O 2Y_O
+    1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+    A B 1GBAR 2GBAR
+    1Y 2Y
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) }
+       STROBE1= { CHANGED(1GBAR,0) }
+       STROBE2= { CHANGED(2GBAR,0) }
+       DATA1={ CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) | CHANGED(1C3,0) }
+       DATA2={ CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) | CHANGED(2C3,0) }
+
+    PINDLY:
+       1Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(5ns,-1,21ns),
+                 SELECT & TRN_HL, DELAY(5ns,-1,21ns),
+                 STROBE1 & TRN_LH, DELAY(5ns,-1,18ns),
+                 STROBE1 & TRN_HL, DELAY(5ns,-1,18ns),
+                 DATA1 & TRN_LH, DELAY(3ns,-1,10ns),
+                 DATA1 & TRN_HL, DELAY(4ns,-1,15ns),
+                 DELAY(6ns,-1,22ns)
+                )
+            }
+       2Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(5ns,-1,21ns),
+                 SELECT & TRN_HL, DELAY(5ns,-1,21ns),
+                 STROBE2 & TRN_LH, DELAY(5ns,-1,18ns),
+                 STROBE2 & TRN_HL, DELAY(5ns,-1,18ns),
+                 DATA2 & TRN_LH, DELAY(3ns,-1,10ns),
+                 DATA2 & TRN_HL, DELAY(4ns,-1,15ns),
+                 DELAY(6ns,-1,22ns)
+                )
+            }

.ENDS 74ALS153
*
*
* ----------------------------------------------------------- 74AS153 ------
*  4 Line to 1 Line Multiplexer
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-133 to 2-136
*  jds    2/25/94
*
.SUBCKT 74AS153  1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y 2Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS153 LOGICEXP (12,2) DPWR DGND
+      1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y_O 2Y_O
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      1g = {(~1GBAR)}
+      2g = {(~2GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      a0 = {(1C0 & abar & bbar & 1g)}
+      a1 = {(1C1 & A & bbar & 1g)}
+      a2 = {(1C2 & abar & B & 1g)}
+      a3 = {(1C3 & A & B & 1g)}
+      b0 = {(2C0 & abar & bbar & 2g)}
+      b1 = {(2C1 & A & bbar & 2g)}
+      b2 = {(2C2 & abar & B & 2g)}
+      b3 = {(2C3 & A & B & 2g)}
+
+      1Y_O = { ( a0 | a1 | a2 | a3) }
+      2Y_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    1Y_O 2Y_O
+    1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+    A B 1GBAR 2GBAR
+    1Y 2Y
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) }
+       STROBE1= { CHANGED(1GBAR,0) }
+       STROBE2= { CHANGED(2GBAR,0) }
+       DATA1={ CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) | CHANGED(1C3,0) }
+       DATA2={ CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) | CHANGED(2C3,0) }
+
+    PINDLY:
+       1Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3ns,-1,12.5ns),
+                 SELECT & TRN_HL, DELAY(3ns,-1,11ns),
+                 STROBE1 & TRN_LH, DELAY(3ns,-1,11.5ns),
+                 STROBE1 & TRN_HL, DELAY(2ns,-1,9ns),
+                 DATA1 & TRN_LH, DELAY(2ns,-1,7ns),
+                 DATA1 & TRN_HL, DELAY(2ns,-1,8ns),
+                 DELAY(4ns,-1,13.5ns)
+                )
+            }
+       2Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(3ns,-1,12.5ns),
+                 SELECT & TRN_HL, DELAY(3ns,-1,11ns),
+                 STROBE2 & TRN_LH, DELAY(3ns,-1,11.5ns),
+                 STROBE2 & TRN_HL, DELAY(2ns,-1,9ns),
+                 DATA2 & TRN_LH, DELAY(2ns,-1,7ns),
+                 DATA2 & TRN_HL, DELAY(2ns,-1,8ns),
+                 DELAY(4ns,-1,13.5ns)
+                )
+            }

.ENDS 74AS153
*
*
* ----------------------------------------------------------- 74F153 ------
*  4 Line to 1 Line Multiplexer
*
*  The Fast TTL Logic Series, 1992, Philips
*  jds    2/25/94     Pages 185 - 188
*
.SUBCKT 74F153  I0A I1A I2A I3A I0B I1B I2B I3B S0 S1 EABAR EBBAR YA YB
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F153 LOGICEXP (12,2) DPWR DGND
+      I0A I1A I2A I3A I0B I1B I2B I3B S0 S1 EABAR EBBAR YA_O YB_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      ea = {(~EABAR)}
+      eb = {(~EBBAR)}
+      s0bar = {(~S0)}
+      s1bar = {(~S1)}
+      a0 = {(I0A & s0bar & s1bar & ea)}
+      a1 = {(I1A & S0 & s1bar & ea)}
+      a2 = {(I2A & s0bar & S1 & ea)}
+      a3 = {(I3A & S0 & S1 & ea)}
+      b0 = {(I0B & s0bar & s1bar & eb)}
+      b1 = {(I1B & S0 & s1bar & eb)}
+      b2 = {(I2B & s0bar & S1 & eb)}
+      b3 = {(I3B & S0 & S1 & eb)}
+
+      YA_O = { ( a0 | a1 | a2 | a3) }
+      YB_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    YA_O YB_O
+    I0A I1A I2A I3A I0B I1B I2B I3B
+    S0 S1 EABAR EBBAR
+    YA YB
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(S0,0) | CHANGED(S1,0) }
+       STROBE1= { CHANGED(EABAR,0) }
+       STROBE2= { CHANGED(EBBAR,0) }
+       DATA1={ CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I2A,0) | CHANGED(I3A,0) }
+       DATA2={ CHANGED(I0B,0) | CHANGED(I1B,0) | CHANGED(I2B,0) | CHANGED(I3B,0) }
+
+    PINDLY:
+       YA = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(5ns,8ns,10.5ns),
+                 SELECT & TRN_HL, DELAY(5ns,8ns,10.5ns),
+                 STROBE1 & TRN_LH, DELAY(5ns,7.5ns,9ns),
+                 STROBE1 & TRN_HL, DELAY(4ns,5.5ns,7ns),
+                 DATA1 & TRN_LH, DELAY(3ns,4.5ns,7ns),
+                 DATA1 & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 DELAY(6ns,9ns,11.5ns)
+                )
+            }
+       YB = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(5ns,8ns,10.5ns),
+                 SELECT & TRN_HL, DELAY(5ns,8ns,10.5ns),
+                 STROBE2 & TRN_LH, DELAY(5ns,7.5ns,9ns),
+                 STROBE2 & TRN_HL, DELAY(4ns,5.5ns,7ns),
+                 DATA2 & TRN_LH, DELAY(3ns,4.5ns,7ns),
+                 DATA2 & TRN_HL, DELAY(3ns,5ns,7.5ns),
+                 DELAY(6ns,9ns,11.5ns)
+                )
+            }

.ENDS 74F153
*
*
* ----------------------------------------------------------- 74HC153 ------
*  4 Line to 1 Line Multiplexer
*
*  The High Speed CMOS Logic, 1989, TI Pages 2-205 to 2-208
*  jds    2/25/94
*
.SUBCKT 74HC153  1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y 2Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC153 LOGICEXP (12,2) DPWR DGND
+      1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y_O 2Y_O
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      1g = {(~1GBAR)}
+      2g = {(~2GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      a0 = {(1C0 & abar & bbar & 1g)}
+      a1 = {(1C1 & A & bbar & 1g)}
+      a2 = {(1C2 & abar & B & 1g)}
+      a3 = {(1C3 & A & B & 1g)}
+      b0 = {(2C0 & abar & bbar & 2g)}
+      b1 = {(2C1 & A & bbar & 2g)}
+      b2 = {(2C2 & abar & B & 2g)}
+      b3 = {(2C3 & A & B & 2g)}
+
+      1Y_O = { ( a0 | a1 | a2 | a3) }
+      2Y_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    1Y_O 2Y_O
+    1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+    A B 1GBAR 2GBAR
+    1Y 2Y
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) }
+       STROBE1= { CHANGED(1GBAR,0) }
+       STROBE2= { CHANGED(2GBAR,0) }
+       DATA1={ CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) | CHANGED(1C3,0) }
+       DATA2={ CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) | CHANGED(2C3,0) }
+
+    PINDLY:
+       1Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,21ns,30ns),
+                 SELECT & TRN_HL, DELAY(-1,21ns,30ns),
+                 STROBE1 & TRN_LH, DELAY(-1,11ns,19ns),
+                 STROBE1 & TRN_HL, DELAY(-1,11ns,19ns),
+                 DATA1 & TRN_LH, DELAY(-1,17ns,28ns),
+                 DATA1 & TRN_HL, DELAY(-1,17ns,28ns),
+                 DELAY(-1,22ns,31ns)
+                )
+            }
+       2Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,21ns,30ns),
+                 SELECT & TRN_HL, DELAY(-1,21ns,30ns),
+                 STROBE2 & TRN_LH, DELAY(-1,11ns,19ns),
+                 STROBE2 & TRN_HL, DELAY(-1,11ns,19ns),
+                 DATA2 & TRN_LH, DELAY(-1,17ns,28ns),
+                 DATA2 & TRN_HL, DELAY(-1,17ns,28ns),
+                 DELAY(-1,22ns,31ns)
+                )
+            }

.ENDS 74HC153

*------------------------------------------------------------74HCT153------

* Dual 4-Input Multiplexer
* Philips High Speed CMOS Logic Family, 1993, pages 5-297 to 5-301
* jat 9/4/95

.SUBCKT 74HCT153 1EBAR 2EBAR S0 S1 1I0 1I1 1I2 1I3 2I0 2I1 2I2 2I3 1Y 2Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,2) DPWR DGND
+ 1EBAR 2EBAR 1I0 1I1 1I2 1I3 2I0 2I1 2I2 2I3 S0 S1
+ 1YO 2YO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {~1EBAR & ((1I0 & ~S1 & ~S0) | (1I1 & ~S1 & S0) | (1I2 & S1 & ~S0) |
+          (1I3 & S1 & S0))}
+   2YO = {~2EBAR & ((2I0 & ~S1 & ~S0) | (2I1 & ~S1 & S0) | (2I2 & S1 & ~S0) |
+          (2I3 & S1 & S0))}

U2 PINDLY(2,0,12) DPWR DGND
+ 1YO 2YO
+ 1EBAR 2EBAR S0 S1 1I0 1I1 1I2 1I3 2I0 2I1 2I2 2I3
+ 1Y 2Y
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENABS = {CHANGED(1EBAR,0) | CHANGED(2EBAR,0)}
+   SEL = {CHANGED(S0,0) | CHANGED(S1,0)}
+   DATA = {CHANGED(1I0,0) | CHANGED(1I1,0) | CHANGED(1I2,0) | CHANGED(1I3,0) |
+           CHANGED(2I0,0) | CHANGED(2I1,0) | CHANGED(2I2,0) | CHANGED(2I3,0)}
+ PINDLY:
+    1Y 2Y = {
+       CASE(
+         ENABS & TRN_LH, DELAY(-1,14NS,27NS),
+         ENABS & TRN_HL, DELAY(-1,14NS,27NS),
+         SEL & TRN_LH, DELAY(-1,20NS,34NS),
+         SEL & TRN_HL, DELAY(-1,20NS,34NS),
+         DATA & TRN_LH, DELAY(-1,13NS,24NS),
+         DATA & TRN_HL, DELAY(-1,19NS,34NS),
+         DELAY(-1,21NS,35NS))}

.ENDS 74HCT153

* ----------------------------------------------------------- 74LS153 ------
*  4 Line to 1 Line Multiplexer
*
*  The TTL Logic Data Book, 1988, TI Pages 2-465 to 2-470
*  jds    2/25/94
*
.SUBCKT 74LS153  1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y 2Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS153 LOGICEXP (12,2) DPWR DGND
+      1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y_O 2Y_O
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      1g = {(~1GBAR)}
+      2g = {(~2GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      a0 = {(1C0 & abar & bbar & 1g)}
+      a1 = {(1C1 & A & bbar & 1g)}
+      a2 = {(1C2 & abar & B & 1g)}
+      a3 = {(1C3 & A & B & 1g)}
+      b0 = {(2C0 & abar & bbar & 2g)}
+      b1 = {(2C1 & A & bbar & 2g)}
+      b2 = {(2C2 & abar & B & 2g)}
+      b3 = {(2C3 & A & B & 2g)}
+
+      1Y_O = { ( a0 | a1 | a2 | a3) }
+      2Y_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    1Y_O 2Y_O
+    1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+    A B 1GBAR 2GBAR
+    1Y 2Y
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) }
+       STROBE1= { CHANGED(1GBAR,0) }
+       STROBE2= { CHANGED(2GBAR,0) }
+       DATA1={ CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) | CHANGED(1C3,0) }
+       DATA2={ CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) | CHANGED(2C3,0) }
+
+    PINDLY:
+       1Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,19ns,29ns),
+                 SELECT & TRN_HL, DELAY(-1,25ns,38ns),
+                 STROBE1 & TRN_LH, DELAY(-1,16ns,24ns),
+                 STROBE1 & TRN_HL, DELAY(-1,21ns,32ns),
+                 DATA1 & TRN_LH, DELAY(-1,10ns,15ns),
+                 DATA1 & TRN_HL, DELAY(-1,17ns,26ns),
+                 DELAY(-1,36ns,39ns)
+                )
+            }
+       2Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,19ns,29ns),
+                 SELECT & TRN_HL, DELAY(-1,35ns,38ns),
+                 STROBE2 & TRN_LH, DELAY(-1,16ns,24ns),
+                 STROBE2 & TRN_HL, DELAY(-1,21ns,32ns),
+                 DATA2 & TRN_LH, DELAY(-1,10ns,15ns),
+                 DATA2 & TRN_HL, DELAY(-1,17ns,26ns),
+                 DELAY(-1,36ns,39ns)
+                )
+            }

.ENDS 74LS153
*
*
* ----------------------------------------------------------- 74S153 ------
*  4 Line to 1 Line Multiplexer
*
*  The TTL Logic Data Book, 1988, TI Pages 2-465 to 2-470
*  jds    2/25/94
*
.SUBCKT 74S153  1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y 2Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S153 LOGICEXP (12,2) DPWR DGND
+      1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3 A B 1GBAR 2GBAR 1Y_O 2Y_O
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      1g = {(~1GBAR)}
+      2g = {(~2GBAR)}
+      abar = {(~A)}
+      bbar = {(~B)}
+      a0 = {(1C0 & abar & bbar & 1g)}
+      a1 = {(1C1 & A & bbar & 1g)}
+      a2 = {(1C2 & abar & B & 1g)}
+      a3 = {(1C3 & A & B & 1g)}
+      b0 = {(2C0 & abar & bbar & 2g)}
+      b1 = {(2C1 & A & bbar & 2g)}
+      b2 = {(2C2 & abar & B & 2g)}
+      b3 = {(2C3 & A & B & 2g)}
+
+      1Y_O = { ( a0 | a1 | a2 | a3) }
+      2Y_O = { ( b0 | b1 | b2 | b3) }

Udly PINDLY (2,0,12) DPWR DGND
+    1Y_O 2Y_O
+    1C0 1C1 1C2 1C3 2C0 2C1 2C2 2C3
+    A B 1GBAR 2GBAR
+    1Y 2Y
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       SELECT= { CHANGED(A,0) | CHANGED(B,0) }
+       STROBE1= { CHANGED(1GBAR,0) }
+       STROBE2= { CHANGED(2GBAR,0) }
+       DATA1={ CHANGED(1C0,0) | CHANGED(1C1,0) | CHANGED(1C2,0) | CHANGED(1C3,0) }
+       DATA2={ CHANGED(2C0,0) | CHANGED(2C1,0) | CHANGED(2C2,0) | CHANGED(2C3,0) }
+
+    PINDLY:
+       1Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,11.5ns,18ns),
+                 SELECT & TRN_HL, DELAY(-1,12ns,18ns),
+                 STROBE1 & TRN_LH, DELAY(-1,10ns,15ns),
+                 STROBE1 & TRN_HL, DELAY(-1,9ns,13.5ns),
+                 DATA1 & TRN_LH, DELAY(-1,6ns,9ns),
+                 DATA1 & TRN_HL, DELAY(-1,6ns,9ns),
+                 DELAY(-1,13ns,19ns)
+                )
+            }
+       2Y = {
+            CASE(
+                 SELECT & TRN_LH, DELAY(-1,11.5ns,18ns),
+                 SELECT & TRN_HL, DELAY(-1,12ns,18ns),
+                 STROBE2 & TRN_LH, DELAY(-1,10ns,15ns),
+                 STROBE2 & TRN_HL, DELAY(-1,9ns,13.5ns),
+                 DATA2 & TRN_LH, DELAY(-1,6ns,9ns),
+                 DATA2 & TRN_HL, DELAY(-1,6ns,9ns),
+                 DELAY(-1,13ns,19ns)
+                )
+            }

.ENDS 74S153
*
*
* ----------------------------------------------------------- 74154 ------
*  4-Line to 16-Line Decoders/Demultiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/25/94     Pages 2-471 to 2-474
*
.SUBCKT 74154  O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+              O10 O11 O12 O13 O14 O15
+              G1BAR G2BAR A B C D
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74154 LOGICEXP (6,16) DPWR DGND
+      G1BAR G2BAR A B C D
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = { (~A) }
+      bbar = { (~B) }
+      cbar = { (~C) }
+      dbar = { (~D) }
+      g = { (~(G1BAR | G2BAR)) }
+
+      O_0o = {~(abar & bbar & cbar & dbar & g)}
+      O_1o = {~(A & bbar & cbar & dbar & g)}
+      O_2o = {~(abar & B & cbar & dbar & g)}
+      O_3o = {~(A & B & cbar & dbar & g)}
+      O_4o = {~(abar & bbar & C & dbar & g)}
+      O_5o = {~(A & bbar & C & dbar & g)}
+      O_6o = {~(abar & B & C & dbar & g)}
+      O_7o = {~(A & B & C & dbar & g)}
+      O_8o = {~(abar & bbar & cbar & D & g)}
+      O_9o = {~(A & bbar & cbar & D & g)}
+      O_10o = {~(abar & B & cbar & D & g)}
+      O_11o = {~(A & B & cbar & D & g)}
+      O_12o = {~(abar & bbar & C & D & g)}
+      O_13o = {~(A & bbar & C & D & g)}
+      O_14o = {~(abar & B & C & D & g)}
+      O_15o = {~(A & B & C & D & g)}

Udly PINDLY (16,0,6) DPWR DGND
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      G1BAR G2BAR A B C D
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15
+      IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       STROBE= { CHANGED(G1BAR,0) | CHANGED(G2BAR,0) }
+       DATA={ CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15   = {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,24ns,36ns),
+                 DATA & TRN_HL, DELAY(-1,22ns,33ns),
+                 STROBE & TRN_LH, DELAY(-1,20ns,30ns),
+                 STROBE & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,25ns,37ns)
+                )
+            }

.ENDS 74154
*
*
* ----------------------------------------------------------- 74F154 ------
*  4-Line to 16-Line Decoders/Demultiplexers
*
*  The Fast TTL Logic Series, 1992, Philips
*  jds    2/25/94     Pages 189 - 192
*
.SUBCKT 74F154   Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+                  Q8BAR Q9BAR Q10BAR Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR
+                  E1BAR E2BAR A0 A1 A2 A3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F154 LOGICEXP (6,16) DPWR DGND
+      E1BAR E2BAR A0 A1 A2 A3
+      Q0BARo Q1BARo Q2BARo Q3BARo Q4BARo Q5BARo Q6BARo Q7BARo
+      Q8BARo Q9BARo Q10BARo Q11BARo Q12BARo Q13BARo Q14BARo Q15BARo
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      a0bar = { (~A0) }
+      a1bar = { (~A1) }
+      a2bar = { (~A2) }
+      a3bar = { (~A3) }
+      e = { (~(E1BAR | E2BAR)) }
+
+      Q0BARo = {~(a0bar & a1bar & a2bar & a3bar & e)}
+      Q1BARo = {~(A0 & a1bar & a2bar & a3bar & e)}
+      Q2BARo = {~(a0bar & A1 & a2bar & a3bar & e)}
+      Q3BARo = {~(A0 & A1 & a2bar & a3bar & e)}
+      Q4BARo = {~(a0bar & a1bar & A2 & a3bar & e)}
+      Q5BARo = {~(A0 & a1bar & A2 & a3bar & e)}
+      Q6BARo = {~(a0bar & A1 & A2 & a3bar & e)}
+      Q7BARo = {~(A0 & A1 & A2 & a3bar & e)}
+      Q8BARo = {~(a0bar & a1bar & a2bar & A3 & e)}
+      Q9BARo = {~(A0 & a1bar & a2bar & A3 & e)}
+      Q10BARo = {~(a0bar & A1 & a2bar & A3 & e)}
+      Q11BARo = {~(A0 & A1 & a2bar & A3 & e)}
+      Q12BARo = {~(a0bar & a1bar & A2 & A3 & e)}
+      Q13BARo = {~(A0 & a1bar & A2 & A3 & e)}
+      Q14BARo = {~(a0bar & A1 & A2 & A3 & e)}
+      Q15BARo = {~(A0 & A1 & A2 & A3 & e)}

Udly PINDLY (16,0,6) DPWR DGND
+      Q0BARo Q1BARo Q2BARo Q3BARo Q4BARo Q5BARo Q6BARo Q7BARo
+      Q8BARo Q9BARo Q10BARo Q11BARo Q12BARo Q13BARo Q14BARo Q15BARo
+      E1BAR E2BAR A0 A1 A2 A3
+      Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+      Q8BAR Q9BAR Q10BAR Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR
+      IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       STROBE= { CHANGED(E1BAR,0) | CHANGED(E2BAR,0) }
+       DATA={ CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) }
+
+    PINDLY:
+      Q0BAR Q1BAR Q2BAR Q3BAR Q4BAR Q5BAR Q6BAR Q7BAR
+      Q8BAR Q9BAR Q10BAR Q11BAR Q12BAR Q13BAR Q14BAR Q15BAR = {
+            CASE(
+                 DATA & TRN_LH, DELAY(2ns,5ns,9.5ns),
+                 DATA & TRN_HL, DELAY(3.5ns,6.5ns,10ns),
+                 STROBE & TRN_LH, DELAY(2ns,4ns,7.5ns),
+                 STROBE & TRN_HL, DELAY(4ns,6ns,9ns),
+                 DELAY(5ns,7.5ns,11ns)
+                )
+            }

.ENDS 74F154
*
*
* ----------------------------------------------------------- 74HC154 ------
*  4-Line to 16-Line Decoders/Demultiplexers
*
*  The High Speed CMOS Logic Data Book, 1989, Texas Instruments
*  jds    2/25/94     Pages 2-209 to 2-212
*
.SUBCKT 74HC154  O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+              O10 O11 O12 O13 O14 O15
+              G1BAR G2BAR A B C D
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC154 LOGICEXP (6,16) DPWR DGND
+      G1BAR G2BAR A B C D
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = { (~A) }
+      bbar = { (~B) }
+      cbar = { (~C) }
+      dbar = { (~D) }
+      g = { (~(G1BAR | G2BAR)) }
+
+      O_0o = {~(abar & bbar & cbar & dbar & g)}
+      O_1o = {~(A & bbar & cbar & dbar & g)}
+      O_2o = {~(abar & B & cbar & dbar & g)}
+      O_3o = {~(A & B & cbar & dbar & g)}
+      O_4o = {~(abar & bbar & C & dbar & g)}
+      O_5o = {~(A & bbar & C & dbar & g)}
+      O_6o = {~(abar & B & C & dbar & g)}
+      O_7o = {~(A & B & C & dbar & g)}
+      O_8o = {~(abar & bbar & cbar & D & g)}
+      O_9o = {~(A & bbar & cbar & D & g)}
+      O_10o = {~(abar & B & cbar & D & g)}
+      O_11o = {~(A & B & cbar & D & g)}
+      O_12o = {~(abar & bbar & C & D & g)}
+      O_13o = {~(A & bbar & C & D & g)}
+      O_14o = {~(abar & B & C & D & g)}
+      O_15o = {~(A & B & C & D & g)}

Udly PINDLY (16,0,6) DPWR DGND
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      G1BAR G2BAR A B C D
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15
+      IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       STROBE= { CHANGED(G1BAR,0) | CHANGED(G2BAR,0) }
+       DATA={ CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15   = {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,24ns,36ns),
+                 DATA & TRN_HL, DELAY(-1,24ns,36ns),
+                 STROBE & TRN_LH, DELAY(-1,24ns,36ns),
+                 STROBE & TRN_HL, DELAY(-1,24ns,36ns),
+                 DELAY(-1,25ns,37ns)
+                )
+            }

.ENDS 74HC154
*
*
* ----------------------------------------------------------- 74HCT154 ------
*  4-Line to 16-Line Decoders/Demultiplexers
*
*  The High Speed CMOS Logic Family, 1994, Philips
*  jds    2/25/94     Pages 303 - 307
*
.SUBCKT 74HCT154   Y0BAR Y1BAR Y2BAR Y3BAR Y4BAR Y5BAR Y6BAR Y7BAR
+                  Y8BAR Y9BAR Y10BAR Y11BAR Y12BAR Y13BAR Y14BAR Y15BAR
+                  E1BAR E2BAR A0 A1 A2 A3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT154 LOGICEXP (6,16) DPWR DGND
+      E1BAR E2BAR A0 A1 A2 A3
+      Y0BARo Y1BARo Y2BARo Y3BARo Y4BARo Y5BARo Y6BARo Y7BARo
+      Y8BARo Y9BARo Y10BARo Y11BARo Y12BARo Y13BARo Y14BARo Y15BARo
+      D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      a0bar = { (~A0) }
+      a1bar = { (~A1) }
+      a2bar = { (~A2) }
+      a3bar = { (~A3) }
+      e = { (~(E1BAR | E2BAR)) }
+
+      Y0BARo = {~(a0bar & a1bar & a2bar & a3bar & e)}
+      Y1BARo = {~(A0 & a1bar & a2bar & a3bar & e)}
+      Y2BARo = {~(a0bar & A1 & a2bar & a3bar & e)}
+      Y3BARo = {~(A0 & A1 & a2bar & a3bar & e)}
+      Y4BARo = {~(a0bar & a1bar & A2 & a3bar & e)}
+      Y5BARo = {~(A0 & a1bar & A2 & a3bar & e)}
+      Y6BARo = {~(a0bar & A1 & A2 & a3bar & e)}
+      Y7BARo = {~(A0 & A1 & A2 & a3bar & e)}
+      Y8BARo = {~(a0bar & a1bar & a2bar & A3 & e)}
+      Y9BARo = {~(A0 & a1bar & a2bar & A3 & e)}
+      Y10BARo = {~(a0bar & A1 & a2bar & A3 & e)}
+      Y11BARo = {~(A0 & A1 & a2bar & A3 & e)}
+      Y12BARo = {~(a0bar & a1bar & A2 & A3 & e)}
+      Y13BARo = {~(A0 & a1bar & A2 & A3 & e)}
+      Y14BARo = {~(a0bar & A1 & A2 & A3 & e)}
+      Y15BARo = {~(A0 & A1 & A2 & A3 & e)}

Udly PINDLY (16,0,6) DPWR DGND
+      Y0BARo Y1BARo Y2BARo Y3BARo Y4BARo Y5BARo Y6BARo Y7BARo
+      Y8BARo Y9BARo Y10BARo Y11BARo Y12BARo Y13BARo Y14BARo Y15BARo
+      E1BAR E2BAR A0 A1 A2 A3
+      Y0BAR Y1BAR Y2BAR Y3BAR Y4BAR Y5BAR Y6BAR Y7BAR
+      Y8BAR Y9BAR Y10BAR Y11BAR Y12BAR Y13BAR Y14BAR Y15BAR
+      IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       STROBE= { CHANGED(E1BAR,0) | CHANGED(E2BAR,0) }
+       DATA={ CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) }
+
+    PINDLY:
+      Y0BAR Y1BAR Y2BAR Y3BAR Y4BAR Y5BAR Y6BAR Y7BAR
+      Y8BAR Y9BAR Y10BAR Y11BAR Y12BAR Y13BAR Y14BAR Y15BAR = {
+            CASE(
+                 DATA, DELAY(-1,16ns,35ns),
+                 STROBE, DELAY(-1,15ns,32ns),
+                 DELAY(-1,15ns,31ns)
+                )
+            }

.ENDS 74HCT154
*
*
* ----------------------------------------------------------- 74LS154 ------
*  4-Line to 16-Line Decoders/Demultiplexers
*
*  The LS/S/TTL Logic Data Book, 1989, National Semiconductor
*  jds    2/25/94     Pages 2-164 to 2-166
*
.SUBCKT 74LS154  O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+              O10 O11 O12 O13 O14 O15
+              G1BAR G2BAR A B C D
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS154 LOGICEXP (6,16) DPWR DGND
+      G1BAR G2BAR A B C D
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = { (~A) }
+      bbar = { (~B) }
+      cbar = { (~C) }
+      dbar = { (~D) }
+      g = { (~(G1BAR | G2BAR)) }
+
+      O_0o = {~(abar & bbar & cbar & dbar & g)}
+      O_1o = {~(A & bbar & cbar & dbar & g)}
+      O_2o = {~(abar & B & cbar & dbar & g)}
+      O_3o = {~(A & B & cbar & dbar & g)}
+      O_4o = {~(abar & bbar & C & dbar & g)}
+      O_5o = {~(A & bbar & C & dbar & g)}
+      O_6o = {~(abar & B & C & dbar & g)}
+      O_7o = {~(A & B & C & dbar & g)}
+      O_8o = {~(abar & bbar & cbar & D & g)}
+      O_9o = {~(A & bbar & cbar & D & g)}
+      O_10o = {~(abar & B & cbar & D & g)}
+      O_11o = {~(A & B & cbar & D & g)}
+      O_12o = {~(abar & bbar & C & D & g)}
+      O_13o = {~(A & bbar & C & D & g)}
+      O_14o = {~(abar & B & C & D & g)}
+      O_15o = {~(A & B & C & D & g)}

Udly PINDLY (16,0,6) DPWR DGND
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      G1BAR G2BAR A B C D
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15
+      IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       STROBE= { CHANGED(G1BAR,0) | CHANGED(G2BAR,0) }
+       DATA={ CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15   = {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,-1,30ns),
+                 DATA & TRN_HL, DELAY(-1,-1,30ns),
+                 STROBE & TRN_LH, DELAY(-1,-1,20ns),
+                 STROBE & TRN_HL, DELAY(-1,-1,25ns),
+                 DELAY(-1,-1,31ns)
+                )
+            }

.ENDS 74LS154
*
*
* ----------------------------------------------------------- 74155 ------
*  Dual 2-Line to 4-Line Decoders/Demultiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/25/94     Pages 4-475 to 4-482
*
.SUBCKT 74155   1C 2CBAR 1GBAR 2GBAR A B
+               1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74155 LOGICEXP (6,8) DPWR DGND
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = {(~A)}
+      bbar = {(~B)}
+      i1 = { (~(1GBAR | ~1C)) }
+      i2 = { (~(2GBAR | 2CBAR)) }
+      1Y0_O = { (~(abar & bbar & i1)) }
+      1Y1_O = { (~(A & bbar & i1)) }
+      1Y2_O = { (~(abar & B & i1)) }
+      1Y3_O = { (~(A & B & i1)) }
+      2Y0_O = { (~(abar & bbar & i2)) }
+      2Y1_O = { (~(A & bbar & i2)) }
+      2Y2_O = { (~(abar & B & i2)) }
+      2Y3_O = { (~(A & B & i2)) }

Udly PINDLY (8,0,6) DPWR DGND
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+      IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      STROBE1= { CHANGED(1GBAR,0) }
+      STROBE2= { CHANGED(2GBAR,0) }
+      TWOCBAR= { CHANGED(2CBAR,0) }
+      DATAA= { CHANGED(A,0) }
+      DATAB={ CHANGED(B,0) }
+      ONEC= { CHANGED(1C,0) }
+
+    PINDLY:
+      1Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE1) & TRN_LH, DELAY(-1,13ns,20ns),
+                 (DATAA | DATAB | STROBE1) & TRN_HL, DELAY(-1,18ns,27ns),
+                 ONEC  & TRN_LH, DELAY(-1,16ns,24ns),
+                 ONEC & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,21ns,31ns)
+                )
+            }
+      1Y1  = {
+            CASE(
+                 DATAA & TRN_LH, DELAY(-1,21ns,32ns),
+                 DATAA & TRN_HL, DELAY(-1,21ns,32ns),
+                 (DATAB | STROBE1) & TRN_LH, DELAY(-1,13ns,20ns),
+                 (DATAB | STROBE1) & TRN_HL, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_LH, DELAY(-1,16ns,24ns),
+                 ONEC & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }
+      1Y2  = {
+            CASE(
+                 DATAB & TRN_LH, DELAY(-1,21ns,32ns),
+                 DATAB & TRN_HL, DELAY(-1,21ns,32ns),
+                 (DATAA | STROBE1) & TRN_LH, DELAY(-1,13ns,20ns),
+                 (DATAA | STROBE1) & TRN_HL, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_LH, DELAY(-1,16ns,24ns),
+                 ONEC & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }
+      1Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,21ns,32ns),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,21ns,32ns),
+                 STROBE1 & TRN_LH, DELAY(-1,13ns,20ns),
+                 STROBE1 & TRN_HL, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_LH, DELAY(-1,16ns,24ns),
+                 ONEC & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }
+      2Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,13ns,20ns),
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,19ns,28ns)
+                )
+            }
+      2Y1  = {
+            CASE(
+                 DATAA & TRN_LH, DELAY(-1,21ns,32ns),
+                 DATAA & TRN_HL, DELAY(-1,21ns,32ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,13ns,20ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }
+      2Y2  = {
+            CASE(
+                 DATAB & TRN_LH, DELAY(-1,21ns,32ns),
+                 DATAB & TRN_HL, DELAY(-1,21ns,32ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,13ns,20ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }
+      2Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,21ns,32ns),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,21ns,32ns),
+                 STROBE2 | TWOCBAR & TRN_LH, DELAY(-1,13ns,20ns),
+                 STROBE2 & TWOCBAR & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,22ns,33ns)
+                )
+            }

.ENDS 74155
*
*
*---------------------------------------------------------74HC155------

* The 74HC155 Dual 2-To-4 Line Decoder/Demultiplexers
* National Semiconductor CMOS Logic Databook, 1988, pages 3-135 to 3-137
* jat 8/8/95

.SUBCKT 74HC155
+ C1 C2 G1 G2 A B 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,4) DPWR DGND
+ G1 G2 C1 C2 A B
+ MODE1 MODE2 ABAR BBAR
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+        MODE1 = {(~G1) & C1}
+        MODE2 = {(~G2) & (~C2)}
+        ABAR = {~A}
+        BBAR = {~B}

U2 NANDA(3,8) DPWR DGND
+ BBAR ABAR MODE1 BBAR A MODE1 B ABAR MODE1 B A MODE1
+ BBAR ABAR MODE2 BBAR A MODE2 B ABAR MODE2 B A MODE2
+ 1Y_0 1Y_1 1Y_2 1Y_3 2Y_0 2Y_1 2Y_2 2Y_3
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,0,2) DPWR DGND
+ 1Y_0 1Y_1 1Y_2 1Y_3 2Y_0 2Y_1 2Y_2 2Y_3
+ A B
+ 1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          SELECT = {CHANGED(A,0) | CHANGED(B,0)}
+ PINDLY:
+          1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3 = {
+            CASE(
+               SELECT & (TRN_LH | TRN_HL), DELAY(-1,22NS,35NS),
+               DELAY(-1,23NS,36NS))}

.ENDS 74HC155

*---------------------------------------------------------74LS155------

* The 74LS155 Dual 1-of-4 Line Decoder/Demultiplexer
* Motorola FAST and LS TTL Logic Data Handbook, 1992, pages 5-150 to 5-153
* jat 8/6/96

.SUBCKT 74LS155
+ A1 A0 EA EABAR EB1BAR EB2BAR O0ABAR O1ABAR O2ABAR O3ABAR O0BBAR O1BBAR
+ O2BBAR O3BBAR
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(6,8) DPWR DGND
+ EA EABAR A0 A1 EB1BAR EB2BAR
+ O0ABARO O1ABARO O2ABARO O3ABARO O0BBARO O1BBARO O2BBARO O3BBARO
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   ENABA = {EA & ~EABAR}
+   ENABB = {~EB1BAR & ~EB2BAR}
+   O0ABARO = {~(ENABA & ~A0 & ~A1)}
+   O1ABARO = {~(ENABA & A0 & ~A1)}
+   O2ABARO = {~(ENABA & ~A0 & A1)}
+   O3ABARO = {~(ENABA & A0 & A1)}
+   O0BBARO = {~(ENABB & ~A0 & ~A1)}
+   O1BBARO = {~(ENABB & A0 & ~A1)}
+   O2BBARO = {~(ENABB & ~A0 & A1)}
+   O3BBARO = {~(ENABB & A0 & A1)}

U2 PINDLY(8,0,6) DPWR DGND
+ O0ABARO O1ABARO O2ABARO O3ABARO O0BBARO O1BBARO O2BBARO O3BBARO
+ A0 A1 EA EABAR EB1BAR EB2BAR
+ O0ABAR O1ABAR O2ABAR O3ABAR O0BBAR O1BBAR O2BBAR O3BBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENABBAR = {CHANGED(EABAR,0) | CHANGED(EB1BAR,0) | CHANGED(EB2BAR,0)}
+   ENAB = {CHANGED(EA,0)}
+   ADDRESS = {CHANGED(A0,0) | CHANGED(A1,0)}
+ PINDLY:
+          O0ABAR O1ABAR O2ABAR O3ABAR O0BBAR O1BBAR O2BBAR O3BBAR = {
+            CASE(
+              ENABBAR & TRN_LH, DELAY(-1,10NS,15NS),
+              ENABBAR & TRN_HL, DELAY(-1,19NS,30NS),
+              ENAB & (TRN_LH | TRN_HL), DELAY(-1,18NS,27NS),
+              ADDRESS & TRN_LH, DELAY(-1,17NS,26NS),
+              ADDRESS & TRN_HL, DELAY(-1,19NS,30NS),
+              DELAY(-1,20NS,31NS))}

.ENDS 74LS155

* ----------------------------------------------------------- 74LS155A ------
*  Dual 2-Line to 4-Line Decoders/Demultiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/25/94     Pages 4-475 to 4-482
*
.SUBCKT 74LS155A   1C 2CBAR 1GBAR 2GBAR A B
+               1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS155A LOGICEXP (6,8) DPWR DGND
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = {(~A)}
+      bbar = {(~B)}
+      i1 = { (~(1GBAR | ~1C)) }
+      i2 = { (~(2GBAR | 2CBAR)) }
+      1Y0_O = { (~(abar & bbar & i1)) }
+      1Y1_O = { (~(A & bbar & i1)) }
+      1Y2_O = { (~(abar & B & i1)) }
+      1Y3_O = { (~(A & B & i1)) }
+      2Y0_O = { (~(abar & bbar & i2)) }
+      2Y1_O = { (~(A & bbar & i2)) }
+      2Y2_O = { (~(abar & B & i2)) }
+      2Y3_O = { (~(A & B & i2)) }

Udly PINDLY (8,0,6) DPWR DGND
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+      IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      STROBE1= { CHANGED(1GBAR,0) }
+      STROBE2= { CHANGED(2GBAR,0) }
+      TWOCBAR= { CHANGED(2CBAR,0) }
+      DATAA= { CHANGED(A,0) }
+      DATAB={ CHANGED(B,0) }
+      ONEC= { CHANGED(1C,0) }
+
+    PINDLY:
+      1Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE1) & TRN_LH, DELAY(-1,10ns,15ns),
+                 (DATAA | DATAB | STROBE1) & TRN_HL, DELAY(-1,19ns,30ns),
+                 ONEC, DELAY(-1,18ns,27ns),
+                 DELAY(-1,19ns,31ns)
+                )
+            }
+      1Y1  = {
+            CASE(
+                 DATAA & TRN_LH, DELAY(-1,17ns,26ns),
+                 DATAA & TRN_HL, DELAY(-1,19ns,30ns),
+                 (DATAB | STROBE1) & TRN_LH, DELAY(-1,10ns,15ns),
+                 (DATAB | STROBE1) & TRN_HL, DELAY(-1,19ns,30ns),
+                 ONEC, DELAY(-1,18ns,27ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+      1Y2  = {
+            CASE(
+                 DATAB & TRN_LH, DELAY(-1,17ns,26ns),
+                 DATAB & TRN_HL, DELAY(-1,19ns,30ns),
+                 (DATAA | STROBE1) & TRN_LH, DELAY(-1,10ns,15ns),
+                 (DATAA | STROBE1) & TRN_HL, DELAY(-1,19ns,30ns),
+                 ONEC, DELAY(-1,18ns,27ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+      1Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,17ns,26ns),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,19ns,30ns),
+                 STROBE1 & TRN_LH, DELAY(-1,10ns,15ns),
+                 STROBE1 & TRN_HL, DELAY(-1,19ns,30ns),
+                 ONEC, DELAY(-1,18ns,27ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+      2Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,10ns,15ns),
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,19ns,30ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+      2Y1  = {
+            CASE(
+                 DATAA & TRN_LH, DELAY(-1,17ns,26ns),
+                 DATAA & TRN_HL, DELAY(-1,19ns,30ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,10ns,15ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,19ns,30ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+      2Y2  = {
+            CASE(
+                 DATAB & TRN_LH, DELAY(-1,17ns,26ns),
+                 DATAB & TRN_HL, DELAY(-1,19ns,30ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,10ns,15ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,19ns,30ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }
+      2Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,17ns,26ns),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,19ns,30ns),
+                 STROBE2 | TWOCBAR & TRN_LH, DELAY(-1,10ns,15ns),
+                 STROBE2 & TWOCBAR & TRN_HL, DELAY(-1,19ns,30ns),
+                 DELAY(-1,20ns,31ns)
+                )
+            }

.ENDS 74LS155A
*
*
* ----------------------------------------------------------- 74156 ------
*  Dual 2-Line to 4-Line Decoders/Demultiplexers
*  Open Collector Outputs
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/25/94     Pages 4-475 to 4-482
*
.SUBCKT 74156   1C 2CBAR 1GBAR 2GBAR A B
+               1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74156 LOGICEXP (6,8) DPWR DGND
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      D0_GATE IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = {(~A)}
+      bbar = {(~B)}
+      i1 = { (~(1GBAR | ~1C)) }
+      i2 = { (~(2GBAR | 2CBAR)) }
+      1Y0_O = { (~(abar & bbar & i1)) }
+      1Y1_O = { (~(A & bbar & i1)) }
+      1Y2_O = { (~(abar & B & i1)) }
+      1Y3_O = { (~(A & B & i1)) }
+      2Y0_O = { (~(abar & bbar & i2)) }
+      2Y1_O = { (~(A & bbar & i2)) }
+      2Y2_O = { (~(abar & B & i2)) }
+      2Y3_O = { (~(A & B & i2)) }

Udly PINDLY (8,0,6) DPWR DGND
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+      IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      STROBE1= { CHANGED(1GBAR,0) }
+      STROBE2= { CHANGED(2GBAR,0) }
+      TWOCBAR= { CHANGED(2CBAR,0) }
+      DATAA= { CHANGED(A,0) }
+      DATAB={ CHANGED(B,0) }
+      ONEC= { CHANGED(1C,0) }
+
+    PINDLY:
+      1Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE1) & TRN_LH, DELAY(-1,15ns,23ns),
+                 (DATAA | DATAB | STROBE1) & TRN_HL, DELAY(-1,20ns,30ns),
+                 ONEC & TRN_LH, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_HL, DELAY(-1,22ns,23ns),
+                 DELAY(-1,23ns,31ns)
+                )
+            }
+      1Y1  = {
+            CASE(
+                 DATAA, DELAY(-1,23ns,34ns),
+                 (DATAB | STROBE1) & TRN_LH, DELAY(-1,15ns,23ns),
+                 (DATAB | STROBE1) & TRN_HL, DELAY(-1,20ns,30ns),
+                 ONEC & TRN_LH, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_HL, DELAY(-1,22ns,23ns),
+                 DELAY(-1,24ns,35ns)
+                )
+            }
+      1Y2  = {
+            CASE(
+                 DATAB, DELAY(-1,23ns,34ns),
+                 (DATAA | STROBE1) & TRN_LH, DELAY(-1,15ns,23ns),
+                 (DATAA | STROBE1) & TRN_HL, DELAY(-1,20ns,30ns),
+                 ONEC & TRN_LH, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_HL, DELAY(-1,22ns,23ns),
+                 DELAY(-1,24ns,35ns)
+                )
+            }
+      1Y3 = {
+            CASE(
+                 DATAA | DATAB, DELAY(-1,23ns,34ns),
+                 STROBE1 & TRN_LH, DELAY(-1,10ns,15ns),
+                 STROBE1 & TRN_HL, DELAY(-1,20ns,30ns),
+                 ONEC & TRN_LH, DELAY(-1,18ns,27ns),
+                 ONEC & TRN_HL, DELAY(-1,22ns,23ns),
+                 DELAY(-1,24ns,35ns)
+                )
+            }
+      2Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,15ns,23ns),
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,21ns,31ns)
+                )
+            }
+      2Y1  = {
+            CASE(
+                 DATAA, DELAY(-1,23ns,34ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,15ns,23ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,24ns,35ns)
+                )
+            }
+      2Y2  = {
+            CASE(
+                 DATAB, DELAY(-1,23ns,34ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,15ns,23ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,24ns,35ns)
+                )
+            }
+      2Y3 = {
+            CASE(
+                 DATAA | DATAB, DELAY(-1,23ns,34ns),
+                 STROBE2 | TWOCBAR & TRN_LH, DELAY(-1,15ns,23ns),
+                 STROBE2 & TWOCBAR & TRN_HL, DELAY(-1,20ns,30ns),
+                 DELAY(-1,24ns,35ns)
+                )
+            }

.ENDS 74156
*
*
* ----------------------------------------------------------- 74ALS156 ------
*  Dual 2-Line to 4-Line Decoders/Demultiplexers
*  Open Collector Outputs
*
*  The ALS/AS Logic Data Book, 1986, Texas Instruments
*  jds    2/28/94     Pages 2-137 to 2-140
*
.SUBCKT 74ALS156   1C 2CBAR 1GBAR 2GBAR A B
+               1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS156 LOGICEXP (6,8) DPWR DGND
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      D0_GATE IO_ALS00_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = {(~A)}
+      bbar = {(~B)}
+      i1 = { (~(1GBAR | ~1C)) }
+      i2 = { (~(2GBAR | 2CBAR)) }
+      1Y0_O = { (~(abar & bbar & i1)) }
+      1Y1_O = { (~(A & bbar & i1)) }
+      1Y2_O = { (~(abar & B & i1)) }
+      1Y3_O = { (~(A & B & i1)) }
+      2Y0_O = { (~(abar & bbar & i2)) }
+      2Y1_O = { (~(A & bbar & i2)) }
+      2Y2_O = { (~(abar & B & i2)) }
+      2Y3_O = { (~(A & B & i2)) }

Udly PINDLY (8,0,6) DPWR DGND
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+      IO_ALS00_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      STROBE1= { CHANGED(1GBAR,0) }
+      STROBE2= { CHANGED(2GBAR,0) }
+      TWOCBAR= { CHANGED(2CBAR,0) }
+      DATAA= { CHANGED(A,0) }
+      DATAB={ CHANGED(B,0) }
+      ONEC= { CHANGED(1C,0) }
+
+    PINDLY:
+      1Y0 1Y1 1Y2 1Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,30ns,-1),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,12ns,-1),
+                 ONEC & TRN_LH, DELAY(-1,38ns,-1),
+                 ONEC & TRN_HL, DELAY(-1,12ns,-1),
+                 STROBE1 & TRN_LH, DELAY(-1,24ns,-1),
+                 STROBE1 & TRN_HL, DELAY(-1,13ns,-1),
+                 DELAY(-1,39ns,-1)
+                )
+            }
+      2Y0 2Y1 2Y2 2Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,30ns,-1),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,12ns,-1),
+                 (TWOCBAR | STROBE2) & TRN_LH, DELAY(-1,24ns,-1),
+                 (TWOCBAR | STROBE2) & TRN_HL, DELAY(-1,13ns,-1),
+                 DELAY(-1,31ns,-1)
+                )
+            }

.ENDS 74ALS156
*
*
* ----------------------------------------------------------- 74LS156 ------
*  Dual 2-Line to 4-Line Decoders/Demultiplexers
*  Open Collector Outputs
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/28/94     Pages 4-475 to 4-482
*
.SUBCKT 74LS156   1C 2CBAR 1GBAR 2GBAR A B
+               1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS156 LOGICEXP (6,8) DPWR DGND
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      D0_GATE IO_LS_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = {(~A)}
+      bbar = {(~B)}
+      i1 = { (~(1GBAR | ~1C)) }
+      i2 = { (~(2GBAR | 2CBAR)) }
+      1Y0_O = { (~(abar & bbar & i1)) }
+      1Y1_O = { (~(A & bbar & i1)) }
+      1Y2_O = { (~(abar & B & i1)) }
+      1Y3_O = { (~(A & B & i1)) }
+      2Y0_O = { (~(abar & bbar & i2)) }
+      2Y1_O = { (~(A & bbar & i2)) }
+      2Y2_O = { (~(abar & B & i2)) }
+      2Y3_O = { (~(A & B & i2)) }

Udly PINDLY (8,0,6) DPWR DGND
+      1Y0_O 1Y1_O 1Y2_O 1Y3_O 2Y0_O 2Y1_O 2Y2_O 2Y3_O
+      1C 2CBAR 1GBAR 2GBAR A B
+      1Y0 1Y1 1Y2 1Y3 2Y0 2Y1 2Y2 2Y3
+      IO_LS_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      STROBE1= { CHANGED(1GBAR,0) }
+      STROBE2= { CHANGED(2GBAR,0) }
+      TWOCBAR= { CHANGED(2CBAR,0) }
+      DATAA= { CHANGED(A,0) }
+      DATAB={ CHANGED(B,0) }
+      ONEC= { CHANGED(1C,0) }
+
+    PINDLY:
+      1Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE1) & TRN_LH, DELAY(-1,25ns,40ns),
+                 (DATAA | DATAB | STROBE1) & TRN_HL, DELAY(-1,34ns,51ns),
+                 ONEC, DELAY(-1,32ns,48ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      1Y1  = {
+            CASE(
+                 DATAA & TRN_LH, DELAY(-1,31ns,46ns),
+                 DATAA & TRN_HL, DELAY(-1,34ns,51ns),
+                 (DATAB | STROBE1) & TRN_LH, DELAY(-1,25ns,40ns),
+                 (DATAB | STROBE1) & TRN_HL, DELAY(-1,34ns,51ns),
+                 ONEC, DELAY(-1,32ns,48ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      1Y2  = {
+            CASE(
+                 DATAB & TRN_LH, DELAY(-1,31ns,46ns),
+                 DATAB & TRN_HL, DELAY(-1,34ns,51ns),
+                 (DATAA | STROBE1) & TRN_LH, DELAY(-1,25ns,40ns),
+                 (DATAA | STROBE1) & TRN_HL, DELAY(-1,34ns,51ns),
+                 ONEC, DELAY(-1,32ns,48ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      1Y3 = {
+            CASE(
+                 (DATAA | DATAB) & TRN_LH, DELAY(-1,31ns,46ns),
+                 (DATAA | DATAB) & TRN_HL, DELAY(-1,34ns,51ns),
+                 STROBE1 & TRN_LH, DELAY(-1,25ns,40ns),
+                 STROBE1 & TRN_HL, DELAY(-1,34ns,51ns),
+                 ONEC, DELAY(-1,32ns,48ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      2Y0 = {
+            CASE(
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,25ns,40ns),
+                 (DATAA | DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,34ns,51ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      2Y1  = {
+            CASE(
+                 DATAA & TRN_LH, DELAY(-1,31ns,46ns),
+                 DATAA & TRN_HL, DELAY(-1,34ns,51ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,25ns,40ns),
+                 (DATAB | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,34ns,51ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      2Y2  = {
+            CASE(
+                 DATAB & TRN_LH, DELAY(-1,31ns,46ns),
+                 DATAB & TRN_HL, DELAY(-1,34ns,51ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_LH, DELAY(-1,25ns,40ns),
+                 (DATAA | STROBE2 | TWOCBAR) & TRN_HL, DELAY(-1,34ns,51ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }
+      2Y3 = {
+            CASE(
+                 DATAA | DATAB, DELAY(-1,31ns,46ns),
+                 STROBE2 | TWOCBAR & TRN_LH, DELAY(-1,25ns,40ns),
+                 STROBE2 & TWOCBAR & TRN_HL, DELAY(-1,34ns,51ns),
+                 DELAY(-1,35ns,52ns)
+                )
+            }

.ENDS 74LS156
*
*
* ----------------------------------------------------------- 74157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/28/94     Pages 2-483 to 2-488
*
.SUBCKT 74157   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74157 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { (i1a | i1b) }
+      2Y_O = { (i2a | i2b) }
+      3Y_O = { (i3a | i3b) }
+      4Y_O = { (i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA , DELAY(-1,9ns,14ns),
+                 STROBE & TRN_LH, DELAY(-1,13ns,20ns),
+                 STROBE & TRN_HL, DELAY(-1,14ns,21ns),
+                 SELECT & TRN_LH, DELAY(-1,15ns,23ns),
+                 SELECT & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,19ns,28ns)
+                )
+            }

.ENDS 74157
*
*
* ----------------------------------------------------------- 74AC157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    3/01/94     Pages 4-73 to 4-78
*
.SUBCKT 74AC157   I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+               ZA ZB ZC ZD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC157 LOGICEXP (10,4) DPWR DGND
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      ZA_O ZB_O ZC_O ZD_O
+      D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      sbar = {(~S)}
+      inI0A = { (I0A & sbar & e) }
+      inI1A = { (I1A & S & e) }
+      inI0B = { (I0B & sbar & e) }
+      inI1B = { (I1B & S & e) }
+      inI0C = { (I0C & sbar & e) }
+      inI1C = { (I1C & S & e) }
+      inI0D = { (I0D & sbar & e) }
+      inI1D = { (I1D & S & e) }
+      ZA_O = { (inI0A | inI1A) }
+      ZB_O = { (inI0B | inI1B) }
+      ZC_O = { (inI0C | inI1C) }
+      ZD_O = { (inI0D | inI1D) }

Udly PINDLY (4,0,10) DPWR DGND
+      ZA_O ZB_O ZC_O ZD_O
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      ZA ZB ZC ZD
+      IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I0B,0) | CHANGED(I1B,0) |
+              CHANGED(I0C,0) | CHANGED(I1C,0) | CHANGED(I0D,0) | CHANGED(I1D,0) }
+      STROBE= { CHANGED(EBAR,0) }
+      SELECT= { CHANGED(S,0) }
+
+    PINDLY:
+      ZA ZB ZC ZD= {
+            CASE(
+                 DATA, DELAY(1.5ns,4ns,6ns),
+                 STROBE, DELAY(1.5ns,5.5ns,9ns),
+                 SELECT & TRN_LH, DELAY(1.5ns,5.5ns,9ns),
+                 SELECT & TRN_HL, DELAY(1.5ns,5ns,8.5ns),
+                 DELAY(2.5ns,6.5ns,10ns)
+                )
+            }

.ENDS 74AC157
*
*
* ----------------------------------------------------------- 74ACT157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    3/01/94     Pages 4-73 to 4-78
*
.SUBCKT 74ACT157   I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+               ZA ZB ZC ZD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ACT157 LOGICEXP (10,4) DPWR DGND
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      ZA_O ZB_O ZC_O ZD_O
+      D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      sbar = {(~S)}
+      inI0A = { (I0A & sbar & e) }
+      inI1A = { (I1A & S & e) }
+      inI0B = { (I0B & sbar & e) }
+      inI1B = { (I1B & S & e) }
+      inI0C = { (I0C & sbar & e) }
+      inI1C = { (I1C & S & e) }
+      inI0D = { (I0D & sbar & e) }
+      inI1D = { (I1D & S & e) }
+      ZA_O = { (inI0A | inI1A) }
+      ZB_O = { (inI0B | inI1B) }
+      ZC_O = { (inI0C | inI1C) }
+      ZD_O = { (inI0D | inI1D) }

Udly PINDLY (4,0,10) DPWR DGND
+      ZA_O ZB_O ZC_O ZD_O
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      ZA ZB ZC ZD
+      IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I0B,0) | CHANGED(I1B,0) |
+              CHANGED(I0C,0) | CHANGED(I1C,0) | CHANGED(I0D,0) | CHANGED(I1D,0) }
+      STROBE= { CHANGED(EBAR,0) }
+      SELECT= { CHANGED(S,0) }
+
+    PINDLY:
+      ZA ZB ZC ZD= {
+            CASE(
+                 DATA & TRN_LH, DELAY(1.5ns,4ns,7ns),
+                 DATA & TRN_HL, DELAY(1.5ns,4.5ns,7.5ns),
+                 STROBE & TRN_LH, DELAY(1.5ns,6ns,10ns),
+                 STROBE & TRN_HL, DELAY(1.5ns,5ns,8.5ns),
+                 SELECT & TRN_LH, DELAY(2ns,5.5ns,9ns),
+                 SELECT & TRN_HL, DELAY(2ns,5.5ns,9.5ns),
+                 DELAY(3ns,7ns,11ns)
+                )
+            }

.ENDS 74ACT157
*
*
* ----------------------------------------------------------- 74ALS157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The ALS/AS Logic Data Book, 1986, Texas Instruments
*  jds    3/01/94     Pages 2-141 to 2-148
*
.SUBCKT 74ALS157   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS157 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { (i1a | i1b) }
+      2Y_O = { (i2a | i2b) }
+      3Y_O = { (i3a | i3b) }
+      4Y_O = { (i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,9ns,-1),
+                 DATA & TRN_HL, DELAY(-1,6ns,-1),
+                 STROBE & TRN_LH, DELAY(-1,14ns,-1),
+                 STROBE & TRN_HL, DELAY(-1,10ns,-1),
+                 SELECT & TRN_LH, DELAY(-1,15ns,-1),
+                 SELECT & TRN_HL, DELAY(-1,9ns,-1),
+                 DELAY(-1,16ns,-1)
+                )
+            }

.ENDS 74ALS157
*
*
* ----------------------------------------------------------- 74AS157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The ALS/AS Logic Data Book, 1986, Texas Instruments
*  jds    3/01/94     Pages 2-141 to 2-148
*
.SUBCKT 74AS157   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS157 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { (i1a | i1b) }
+      2Y_O = { (i2a | i2b) }
+      3Y_O = { (i3a | i3b) }
+      4Y_O = { (i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA & TRN_LH, DELAY(1ns,-1,6ns),
+                 DATA & TRN_HL, DELAY(1ns,-1,5.5ns),
+                 STROBE & TRN_LH, DELAY(2ns,-1,10.5ns),
+                 STROBE & TRN_HL, DELAY(2ns,-1,7.5ns),
+                 SELECT & TRN_LH, DELAY(2ns,-1,11ns),
+                 SELECT & TRN_HL, DELAY(2ns,-1,10ns),
+                 DELAY(3ns,-1,12ns)
+                )
+            }

.ENDS 74AS157
*
*
* ----------------------------------------------------------- 74F157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The FAST TTL Series Logic Data Book, 1992, Philips
*  jds    3/01/94     Pages 193 to 197
*
.SUBCKT 74F157   I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+               YA YB YC YD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F157 LOGICEXP (10,4) DPWR DGND
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA_O YB_O YC_O YD_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      sbar = {(~S)}
+      inI0A = { (I0A & sbar & e) }
+      inI1A = { (I1A & S & e) }
+      inI0B = { (I0B & sbar & e) }
+      inI1B = { (I1B & S & e) }
+      inI0C = { (I0C & sbar & e) }
+      inI1C = { (I1C & S & e) }
+      inI0D = { (I0D & sbar & e) }
+      inI1D = { (I1D & S & e) }
+      YA_O = { (inI0A | inI1A) }
+      YB_O = { (inI0B | inI1B) }
+      YC_O = { (inI0C | inI1C) }
+      YD_O = { (inI0D | inI1D) }

Udly PINDLY (4,0,10) DPWR DGND
+      YA_O YB_O YC_O YD_O
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA YB YC YD
+      IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I0B,0) | CHANGED(I1B,0) |
+              CHANGED(I0C,0) | CHANGED(I1C,0) | CHANGED(I0D,0) | CHANGED(I1D,0) }
+      STROBE= { CHANGED(EBAR,0) }
+      SELECT= { CHANGED(S,0) }
+
+    PINDLY:
+      YA YB YC YD= {
+            CASE(
+                 DATA & TRN_LH, DELAY(3.5ns,4.5ns,7ns),
+                 DATA & TRN_HL, DELAY(2.5ns,3.5ns,5.5ns),
+                 STROBE & TRN_LH, DELAY(5ns,7.5ns,10ns),
+                 STROBE & TRN_HL, DELAY(3.8ns,5ns,7ns),
+                 SELECT & TRN_LH, DELAY(4.5ns,8ns,13ns),
+                 SELECT & TRN_HL, DELAY(3.5ns,6ns,8ns),
+                 DELAY(6ns,8.5ns,14ns)
+                )
+            }

.ENDS 74F157
*
*
* ----------------------------------------------------------- 74F157A ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The FAST TTL Series Logic Data Book, 1992, Philips
*  jds    3/01/94     Pages 193 to 197
*
.SUBCKT 74F157A   I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+               YA YB YC YD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F157A LOGICEXP (10,4) DPWR DGND
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA_O YB_O YC_O YD_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      sbar = {(~S)}
+      inI0A = { (I0A & sbar & e) }
+      inI1A = { (I1A & S & e) }
+      inI0B = { (I0B & sbar & e) }
+      inI1B = { (I1B & S & e) }
+      inI0C = { (I0C & sbar & e) }
+      inI1C = { (I1C & S & e) }
+      inI0D = { (I0D & sbar & e) }
+      inI1D = { (I1D & S & e) }
+      YA_O = { (inI0A | inI1A) }
+      YB_O = { (inI0B | inI1B) }
+      YC_O = { (inI0C | inI1C) }
+      YD_O = { (inI0D | inI1D) }

Udly PINDLY (4,0,10) DPWR DGND
+      YA_O YB_O YC_O YD_O
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA YB YC YD
+      IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I0B,0) | CHANGED(I1B,0) |
+              CHANGED(I0C,0) | CHANGED(I1C,0) | CHANGED(I0D,0) | CHANGED(I1D,0) }
+      STROBE= { CHANGED(EBAR,0) }
+      SELECT= { CHANGED(S,0) }
+
+    PINDLY:
+      YA YB YC YD= {
+            CASE(
+                 DATA & TRN_LH, DELAY(3.5ns,4.5ns,6.5ns),
+                 DATA & TRN_HL, DELAY(2.5ns,3.5ns,5ns),
+                 STROBE & TRN_LH, DELAY(6ns,7.5ns,9ns),
+                 STROBE & TRN_HL, DELAY(4ns,5ns,6.5ns),
+                 SELECT & TRN_LH, DELAY(5.5ns,7.5ns,10ns),
+                 SELECT & TRN_HL, DELAY(4.5ns,6ns,7.5ns),
+                 DELAY(7ns,8.5ns,11ns)
+                )
+            }

.ENDS 74F157A
*
*
* ----------------------------------------------------------- 74HC157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The High Speed CMOS Logic Data Book, 1989, Texas Instruments
*  jds    3/01/94     Pages 2-213 to 2-216
*
.SUBCKT 74HC157   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC157 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { (i1a | i1b) }
+      2Y_O = { (i2a | i2b) }
+      3Y_O = { (i3a | i3b) }
+      4Y_O = { (i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA , DELAY(-1,13ns,25ns),
+                 STROBE, DELAY(-1,16ns,23ns),
+                 SELECT, DELAY(-1,18ns,25ns),
+                 DELAY(-1,19ns,26ns)
+                )
+            }

.ENDS 74HC157

*------------------------------------------------------------74HC157A------

* Quad 2-Input Data Selector/Multiplexers
* Motorola High Speed CMOS Data, 1993, pages 5-152 to 5-155
* jat 9/4/96

.SUBCKT 74HC157A A0 B0 A1 B1 A2 B2 A3 B3 OUTENAB SELECT Y0 Y1 Y2 Y3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) DPWR DGND
+ A0 B0 A1 B1 A2 B2 A3 B3 OUTENAB SELECT
+ Y0O Y1O Y2O Y3O
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   SELA = {~OUTENAB & ~SELECT}
+   SELB = {~OUTENAB & SELECT}
+   Y0O = {(A0 & SELA) | (B0 & SELB)}
+   Y1O = {(A1 & SELA) | (B1 & SELB)}
+   Y2O = {(A2 & SELA) | (B2 & SELB)}
+   Y3O = {(A3 & SELA) | (B3 & SELB)}

U2 PINDLY(4,0,10) DPWR DGND
+ Y0O Y1O Y2O Y3O
+ A0 B0 A1 B1 A2 B2 A3 B3 OUTENAB SELECT
+ Y0 Y1 Y2 Y3
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENAB = {CHANGED(OUTENAB,0)}
+   SEL = {CHANGED(SELECT,0)}
+   DATA = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) |
+           CHANGED(B0,0) | CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0)}
+ PINDLY:
+    Y0 Y1 Y2 Y3 = {
+       CASE(
+         ENAB & TRN_LH, DELAY(-1,-1,20NS),
+         ENAB & TRN_HL, DELAY(-1,-1,20NS),
+         SEL & TRN_LH, DELAY(-1,-1,22NS),
+         SEL & TRN_HL, DELAY(-1,-1,22NS),
+         DATA & TRN_LH, DELAY(-1,-1,21NS),
+         DATA & TRN_HL, DELAY(-1,-1,21NS),
+         DELAY(-1,-1,23NS))}

.ENDS 74HC157A

*------------------------------------------------------------74HCT157------

* Quad 2-Input Multiplexer
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 309 to 313
* jat 9/5/96

.SUBCKT 74HCT157 1I0 1I1 2I0 2I1 3I0 3I1 4I0 4I1 EBAR S 1Y 2Y 3Y 4Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) DPWR DGND
+ 1I0 1I1 2I0 2I1 3I0 3I1 4I0 4I1 EBAR S
+ 1YO 2YO 3YO 4YO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YO = {~EBAR & ((1I1 & S) | (1I0 & ~S))}
+   2YO = {~EBAR & ((2I1 & S) | (2I0 & ~S))}
+   3YO = {~EBAR & ((3I1 & S) | (3I0 & ~S))}
+   4YO = {~EBAR & ((4I1 & S) | (4I0 & ~S))}

U2 PINDLY(4,0,10) DPWR DGND
+ 1YO 2YO 3YO 4YO
+ 1I0 1I1 2I0 2I1 3I0 3I1 4I0 4I1 EBAR S
+ 1Y 2Y 3Y 4Y
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENAB = {CHANGED(EBAR,0)}
+   SEL = {CHANGED(S,0)}
+   DATA = {CHANGED(1I1,0) | CHANGED(2I1,0) | CHANGED(3I1,0) | CHANGED(4I1,0) |
+           CHANGED(1I0,0) | CHANGED(2I0,0) | CHANGED(3I0,0) | CHANGED(4I0,0)}
+ PINDLY:
+    1Y 2Y 3Y 4Y = {
+       CASE(
+         ENAB & TRN_LH, DELAY(-1,15NS,26NS),
+         ENAB & TRN_HL, DELAY(-1,15NS,26NS),
+         SEL & TRN_LH, DELAY(-1,22NS,37NS),
+         SEL & TRN_HL, DELAY(-1,22NS,37NS),
+         DATA & TRN_LH, DELAY(-1,16NS,27NS),
+         DATA & TRN_HL, DELAY(-1,16NS,27NS),
+         DELAY(-1,23NS,38NS))}

.ENDS 74HCT157

*------------------------------------------------------------74HCT157A------

* Quad 2-Input Data Selector/Multiplexers
* Motorola High Speed CMOS Data, 1993, pages 5-156 to 5-159
* jat 9/4/96

.SUBCKT 74HCT157A A0 B0 A1 B1 A2 B2 A3 B3 OUTENAB SELECT Y0 Y1 Y2 Y3
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) DPWR DGND
+ A0 B0 A1 B1 A2 B2 A3 B3 OUTENAB SELECT
+ Y0O Y1O Y2O Y3O
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   SELA = {~OUTENAB & ~SELECT}
+   SELB = {~OUTENAB & SELECT}
+   Y0O = {(A0 & SELA) | (B0 & SELB)}
+   Y1O = {(A1 & SELA) | (B1 & SELB)}
+   Y2O = {(A2 & SELA) | (B2 & SELB)}
+   Y3O = {(A3 & SELA) | (B3 & SELB)}

U2 PINDLY(4,0,10) DPWR DGND
+ Y0O Y1O Y2O Y3O
+ A0 B0 A1 B1 A2 B2 A3 B3 OUTENAB SELECT
+ Y0 Y1 Y2 Y3
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENAB = {CHANGED(OUTENAB,0)}
+   SEL = {CHANGED(SELECT,0)}
+   DATA = {CHANGED(A0,0) | CHANGED(A1,0) | CHANGED(A2,0) | CHANGED(A3,0) |
+           CHANGED(B0,0) | CHANGED(B1,0) | CHANGED(B2,0) | CHANGED(B3,0)}
+ PINDLY:
+    Y0 Y1 Y2 Y3 = {
+       CASE(
+         ENAB & TRN_LH, DELAY(-1,-1,30NS),
+         ENAB & TRN_HL, DELAY(-1,-1,30NS),
+         SEL & TRN_LH, DELAY(-1,-1,37NS),
+         SEL & TRN_HL, DELAY(-1,-1,37NS),
+         DATA & TRN_LH, DELAY(-1,-1,27NS),
+         DATA & TRN_HL, DELAY(-1,-1,27NS),
+         DELAY(-1,-1,38NS))}

.ENDS 74HCT157A

* ----------------------------------------------------------- 74LS157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    3/01/94     Pages 2-483 to 2-488
*
.SUBCKT 74LS157   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS157 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { (i1a | i1b) }
+      2Y_O = { (i2a | i2b) }
+      3Y_O = { (i3a | i3b) }
+      4Y_O = { (i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA , DELAY(-1,9ns,14ns),
+                 STROBE & TRN_LH, DELAY(-1,13ns,20ns),
+                 STROBE & TRN_HL, DELAY(-1,14ns,21ns),
+                 SELECT & TRN_LH, DELAY(-1,15ns,23ns),
+                 SELECT & TRN_HL, DELAY(-1,18ns,27ns),
+                 DELAY(-1,19ns,28ns)
+                )
+            }

.ENDS 74LS157
*
*
* ----------------------------------------------------------- 74S157 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    3/01/94     Pages 2-483 to 2-488
*
.SUBCKT 74S157   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S157 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { (i1a | i1b) }
+      2Y_O = { (i2a | i2b) }
+      3Y_O = { (i3a | i3b) }
+      4Y_O = { (i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,5ns,7.5ns),
+                 DATA & TRN_HL, DELAY(-1,4.5ns,6.5ns),
+                 STROBE & TRN_LH, DELAY(-1,8.5ns,12.5ns),
+                 STROBE & TRN_HL, DELAY(-1,7.5ns,12ns),
+                 SELECT, DELAY(-1,9.5ns,15ns),
+                 DELAY(-1,9.5ns,16ns)
+                )
+            }

.ENDS 74S157
*
*
*------------------------------------------------------------74AC158------

* Quadruple 2-Line to 1-Line Data Selector/Multiplexer
* TI Advanced CMOS Logic Databook, 1993, pages 2-205 to 2-208
* jat 12/19/95

.SUBCKT 74AC158 1A 1B 2A 2B 3A 3B 4A 4B OEBAR ABARB 1Y 2Y 3Y 4Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) DPWR DGND
+ 1A 1B 2A 2B 3A 3B 4A 4B OEBAR ABARB
+ 1YO 2YO 3YO 4YO
+ D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   SEL1 = {~(OEBAR | ABARB)}
+   SEL2 = {(~OEBAR) & ABARB}
+   1YO = {~((1A & SEL1) | (1B & SEL2))}
+   2YO = {~((2A & SEL1) | (2B & SEL2))}
+   3YO = {~((3A & SEL1) | (3B & SEL2))}
+   4YO = {~((4A & SEL1) | (4B & SEL2))}

U2 PINDLY(4,0,10) DPWR DGND
+ 1YO 2YO 3YO 4YO
+ 1A 1B 2A 2B 3A 3B 4A 4B OEBAR ABARB
+ 1Y 2Y 3Y 4Y
+ IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENABLE = {CHANGED(OEBAR,0)}
+   SELECT = {CHANGED(ABARB,0)}
+   DATA = {CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(3A,0) | CHANGED(3B,0) |
+           CHANGED(2A,0) | CHANGED(2B,0) | CHANGED(4A,0) | CHANGED(4B,0)}
+ PINDLY:
+    1Y 2Y 3Y 4Y = {
+       CASE(
+         ENABLE & TRN_LH, DELAY(1.5NS,3.7NS,6.4NS),
+         ENABLE & TRN_HL, DELAY(1.5NS,4.2NS,6.9NS),
+         SELECT& TRN_LH, DELAY(1.5NS,4.1NS,6.9NS),
+         SELECT & TRN_HL, DELAY(1.5NS,4.9NS,7.2NS),
+         DATA & TRN_LH, DELAY(1.5NS,3.6NS,6.4NS),
+         DATA & TRN_HL, DELAY(1.5NS,3.9NS,6.6NS),
+         DELAY(2.5NS,5.9NS,8.2NS))}

.ENDS 74AC158

*------------------------------------------------------------74ACT158------

* Quadruple 2-Line to 1-Line Data Selector/Multiplexer
* TI Advanced CMOS Logic Databook, 1993, pages 2-209 to 2-211
* jat 12/19/95

.SUBCKT 74ACT158 1A 1B 2A 2B 3A 3B 4A 4B OEBAR ABARB 1Y 2Y 3Y 4Y
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) DPWR DGND
+ 1A 1B 2A 2B 3A 3B 4A 4B OEBAR ABARB
+ 1YO 2YO 3YO 4YO
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   SEL1 = {~(OEBAR | ABARB)}
+   SEL2 = {(~OEBAR) & ABARB}
+   1YO = {~((1A & SEL1) | (1B & SEL2))}
+   2YO = {~((2A & SEL1) | (2B & SEL2))}
+   3YO = {~((3A & SEL1) | (3B & SEL2))}
+   4YO = {~((4A & SEL1) | (4B & SEL2))}

U2 PINDLY(4,0,10) DPWR DGND
+ 1YO 2YO 3YO 4YO
+ 1A 1B 2A 2B 3A 3B 4A 4B OEBAR ABARB
+ 1Y 2Y 3Y 4Y
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENABLE = {CHANGED(OEBAR,0)}
+   SELECT = {CHANGED(ABARB,0)}
+   DATA = {CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(3A,0) | CHANGED(3B,0) |
+           CHANGED(2A,0) | CHANGED(2B,0) | CHANGED(4A,0) | CHANGED(4B,0)}
+ PINDLY:
+    1Y 2Y 3Y 4Y = {
+       CASE(
+         ENABLE & TRN_LH, DELAY(2.5NS,5.1NS,6.8NS),
+         ENABLE & TRN_HL, DELAY(2.5NS,6.1NS,8.9NS),
+         SELECT& TRN_LH, DELAY(2.3NS,5.3NS,7.7NS),
+         SELECT & TRN_HL, DELAY(2.9NS,6.7NS,9.8NS),
+         DATA & TRN_LH, DELAY(2NS,5.1NS,7.6NS),
+         DATA & TRN_HL, DELAY(2.7NS,5.9NS,8.3NS),
+         DELAY(3.9NS,7.7NS,10.8NS))}

.ENDS 74ACT158

* ----------------------------------------------------------- 74ALS158 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The ALS/AS Logic Data Book, 1986, Texas Instruments
*  jds    3/01/94     Pages 2-141 to 2-148
*
.SUBCKT 74ALS158   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS158 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { ~(i1a | i1b) }
+      2Y_O = { ~(i2a | i2b) }
+      3Y_O = { ~(i3a | i3b) }
+      4Y_O = { ~(i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,9ns,-1),
+                 DATA & TRN_HL, DELAY(-1,5ns,-1),
+                 STROBE | SELECT, DELAY(-1,13ns,-1),
+                 DELAY(-1,14ns,-1)
+                )
+            }

.ENDS 74ALS158
*
*
* ----------------------------------------------------------- 74AS158 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The ALS/AS Logic Data Book, 1986, Texas Instruments
*  jds    3/01/94     Pages 2-141 to 2-148
*
.SUBCKT 74AS158   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS158 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { ~(i1a | i1b) }
+      2Y_O = { ~(i2a | i2b) }
+      3Y_O = { ~(i3a | i3b) }
+      4Y_O = { ~(i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA & TRN_LH, DELAY(1ns,-1,5ns),
+                 DATA & TRN_HL, DELAY(1ns,-1,4.5ns),
+                 STROBE & TRN_LH, DELAY(2ns,-1,6.5ns),
+                 STROBE & TRN_HL, DELAY(2ns,-1,10ns),
+                 SELECT & TRN_LH, DELAY(2ns,-1,9.5ns),
+                 SELECT & TRN_HL, DELAY(2ns,-1,10.5ns),
+                 DELAY(3ns,-1,11.5ns)
+                )
+            }

.ENDS 74AS158
*
*
* ----------------------------------------------------------- 74F158 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The FAST TTL Series Logic Data Book, 1992, Philips
*  jds    3/01/94     Pages 193 to 197
*
.SUBCKT 74F158   I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+               YA YB YC YD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F158 LOGICEXP (10,4) DPWR DGND
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA_O YB_O YC_O YD_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      sbar = {(~S)}
+      inI0A = { (I0A & sbar & e) }
+      inI1A = { (I1A & S & e) }
+      inI0B = { (I0B & sbar & e) }
+      inI1B = { (I1B & S & e) }
+      inI0C = { (I0C & sbar & e) }
+      inI1C = { (I1C & S & e) }
+      inI0D = { (I0D & sbar & e) }
+      inI1D = { (I1D & S & e) }
+      YA_O = { ~(inI0A | inI1A) }
+      YB_O = { ~(inI0B | inI1B) }
+      YC_O = { ~(inI0C | inI1C) }
+      YD_O = { ~(inI0D | inI1D) }

Udly PINDLY (4,0,10) DPWR DGND
+      YA_O YB_O YC_O YD_O
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA YB YC YD
+      IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I0B,0) | CHANGED(I1B,0) |
+              CHANGED(I0C,0) | CHANGED(I1C,0) | CHANGED(I0D,0) | CHANGED(I1D,0) }
+      STROBE= { CHANGED(EBAR,0) }
+      SELECT= { CHANGED(S,0) }
+
+    PINDLY:
+      YA YB YC YD= {
+            CASE(
+                 DATA & TRN_LH, DELAY(3ns,4ns,5.9ns),
+                 DATA & TRN_HL, DELAY(1.5ns,2.5ns,4.5ns),
+                 STROBE & TRN_LH, DELAY(4.5ns,6ns,8ns),
+                 STROBE & TRN_HL, DELAY(3.5ns,5.5ns,8.5ns),
+                 SELECT & TRN_LH, DELAY(4ns,6.5ns,8.5ns),
+                 SELECT & TRN_HL, DELAY(4ns,5.5ns,9ns),
+                 DELAY(5.5ns,7.5ns,10ns)
+                )
+            }

.ENDS 74F158
*
*
* ----------------------------------------------------------- 74F158A ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The FAST TTL Series Logic Data Book, 1992, Philips
*  jds    3/01/94     Pages 193 to 197
*
.SUBCKT 74F158A   I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+               YA YB YC YD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F158A LOGICEXP (10,4) DPWR DGND
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA_O YB_O YC_O YD_O
+      D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      e = {(~EBAR)}
+      sbar = {(~S)}
+      inI0A = { (I0A & sbar & e) }
+      inI1A = { (I1A & S & e) }
+      inI0B = { (I0B & sbar & e) }
+      inI1B = { (I1B & S & e) }
+      inI0C = { (I0C & sbar & e) }
+      inI1C = { (I1C & S & e) }
+      inI0D = { (I0D & sbar & e) }
+      inI1D = { (I1D & S & e) }
+      YA_O = { ~(inI0A | inI1A) }
+      YB_O = { ~(inI0B | inI1B) }
+      YC_O = { ~(inI0C | inI1C) }
+      YD_O = { ~(inI0D | inI1D) }

Udly PINDLY (4,0,10) DPWR DGND
+      YA_O YB_O YC_O YD_O
+      I0A I1A I0B I1B I0C I1C I0D I1D S EBAR
+      YA YB YC YD
+      IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(I0A,0) | CHANGED(I1A,0) | CHANGED(I0B,0) | CHANGED(I1B,0) |
+              CHANGED(I0C,0) | CHANGED(I1C,0) | CHANGED(I0D,0) | CHANGED(I1D,0) }
+      STROBE= { CHANGED(EBAR,0) }
+      SELECT= { CHANGED(S,0) }
+
+    PINDLY:
+      YA YB YC YD= {
+            CASE(
+                 DATA & TRN_LH, DELAY(3ns,4ns,6ns),
+                 DATA & TRN_HL, DELAY(1.5ns,2.5ns,4ns),
+                 STROBE & TRN_LH, DELAY(4.5ns,5.5ns,7ns),
+                 STROBE & TRN_HL, DELAY(5ns,6ns,7.5ns),
+                 SELECT & TRN_LH, DELAY(4.5ns,6.5ns,8.5ns),
+                 SELECT & TRN_HL, DELAY(4ns,5.5ns,7.5ns),
+                 DELAY(6ns,7.5ns,9.5ns)
+                )
+            }

.ENDS 74F158A
*
*
* ----------------------------------------------------------- 74HC158 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The High Speed CMOS Logic Data Book, 1989, Texas Instruments
*  jds    3/01/94     Pages 2-213 to 2-216
*
.SUBCKT 74HC158   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC158 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { ~(i1a | i1b) }
+      2Y_O = { ~(i2a | i2b) }
+      3Y_O = { ~(i3a | i3b) }
+      4Y_O = { ~(i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA , DELAY(-1,13ns,25ns),
+                 STROBE, DELAY(-1,16ns,23ns),
+                 SELECT, DELAY(-1,18ns,25ns),
+                 DELAY(-1,19ns,26ns)
+                )
+            }

.ENDS 74HC158

*------------------------------------------------------------74HCT158------

* Quad 2-Input Multiplexer; Inverting
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 315 to 319
* jat 9/5/96

.SUBCKT 74HCT158 1I0 1I1 2I0 2I1 3I0 3I1 4I0 4I1 EBAR S 1YBAR 2YBAR 3YBAR 4YBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(10,4) DPWR DGND
+ 1I0 1I1 2I0 2I1 3I0 3I1 4I0 4I1 EBAR S
+ 1YBARO 2YBARO 3YBARO 4YBARO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   1YBARO = {~(~EBAR & ((1I1 & S) | (1I0 & ~S)))}
+   2YBARO = {~(~EBAR & ((2I1 & S) | (2I0 & ~S)))}
+   3YBARO = {~(~EBAR & ((3I1 & S) | (3I0 & ~S)))}
+   4YBARO = {~(~EBAR & ((4I1 & S) | (4I0 & ~S)))}

U2 PINDLY(4,0,10) DPWR DGND
+ 1YBARO 2YBARO 3YBARO 4YBARO
+ 1I0 1I1 2I0 2I1 3I0 3I1 4I0 4I1 EBAR S
+ 1YBAR 2YBAR 3YBAR 4YBAR
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   ENAB = {CHANGED(EBAR,0)}
+   SEL = {CHANGED(S,0)}
+   DATA = {CHANGED(1I1,0) | CHANGED(2I1,0) | CHANGED(3I1,0) | CHANGED(4I1,0) |
+           CHANGED(1I0,0) | CHANGED(2I0,0) | CHANGED(3I0,0) | CHANGED(4I0,0)}
+ PINDLY:
+    1YBAR 2YBAR 3YBAR 4YBAR = {
+       CASE(
+         ENAB & TRN_LH, DELAY(-1,19NS,35NS),
+         ENAB & TRN_HL, DELAY(-1,19NS,35NS),
+         SEL & TRN_LH, DELAY(-1,19NS,35NS),
+         SEL & TRN_HL, DELAY(-1,19NS,35NS),
+         DATA & TRN_LH, DELAY(-1,16NS,30NS),
+         DATA & TRN_HL, DELAY(-1,16NS,30NS),
+         DELAY(-1,20NS,36NS))}

.ENDS 74HCT158

* ----------------------------------------------------------- 74LS158 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    3/01/94     Pages 2-483 to 2-488
*
.SUBCKT 74LS158   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS158 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { ~(i1a | i1b) }
+      2Y_O = { ~(i2a | i2b) }
+      3Y_O = { ~(i3a | i3b) }
+      4Y_O = { ~(i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,7ns,12ns),
+                 DATA & TRN_HL, DELAY(-1,10ns,15ns),
+                 STROBE & TRN_LH, DELAY(-1,11ns,17ns),
+                 STROBE & TRN_HL, DELAY(-1,18ns,24ns),
+                 SELECT & TRN_LH, DELAY(-1,13ns,20ns),
+                 SELECT & TRN_HL, DELAY(-1,16ns,24ns),
+                 DELAY(-1,19ns,25ns)
+                )
+            }

.ENDS 74LS158
*
*
* ----------------------------------------------------------- 74S158 ------
*  Quadruple 2-Line to 1-Line Data Selectors/Multiplexers
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    3/01/94     Pages 2-483 to 2-488
*
.SUBCKT 74S158   1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+               1Y 2Y 3Y 4Y
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S158 LOGICEXP (10,4) DPWR DGND
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y_O 2Y_O 3Y_O 4Y_O
+      D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      g = {(~GBAR)}
+      a/bbar = {(~ABAR/B)}
+      i1a = { (1A & a/bbar & g) }
+      i1b = { (1B & ABAR/B & g) }
+      i2a = { (2A & a/bbar & g) }
+      i2b = { (2B & ABAR/B & g) }
+      i3a = { (3A & a/bbar & g) }
+      i3b = { (3B & ABAR/B & g) }
+      i4a = { (4A & a/bbar & g) }
+      i4b = { (4B & ABAR/B & g) }
+      1Y_O = { ~(i1a | i1b) }
+      2Y_O = { ~(i2a | i2b) }
+      3Y_O = { ~(i3a | i3b) }
+      4Y_O = { ~(i4a | i4b) }

Udly PINDLY (4,0,10) DPWR DGND
+      1Y_O 2Y_O 3Y_O 4Y_O
+      1A 1B 2A 2B 3A 3B 4A 4B ABAR/B GBAR
+      1Y 2Y 3Y 4Y
+      IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+      DATA= { CHANGED(1A,0) | CHANGED(1B,0) | CHANGED(2A,0) | CHANGED(2B,0) |
+              CHANGED(3A,0) | CHANGED(3B,0) | CHANGED(4A,0) | CHANGED(4B,0) }
+      STROBE= { CHANGED(GBAR,0) }
+      SELECT= { CHANGED(ABAR/B,0) }
+
+    PINDLY:
+      1Y 2Y 3Y 4Y= {
+            CASE(
+                 DATA, DELAY(-1,4ns,6ns),
+                 STROBE & TRN_LH, DELAY(-1,6.5ns,11.5ns),
+                 STROBE & TRN_HL, DELAY(-1,7ns,12ns),
+                 SELECT, DELAY(-1,8ns,12ns),
+                 DELAY(-1,9ns,13ns)
+                )
+            }

.ENDS 74S158
*
*
* ----------------------------------------------------------- 74159 ------
*  4-Line to 16-Line Decoders/Demultiplexers
*  with Open Collector Outputs
*
*  The TTL Logic Data Book, 1988, Texas Instruments
*  jds    2/25/94     Pages 2-489 to 2-491
*
.SUBCKT 74159  O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+              O10 O11 O12 O13 O14 O15
+              G1BAR G2BAR A B C D
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74159 LOGICEXP (6,16) DPWR DGND
+      G1BAR G2BAR A B C D
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      D0_GATE IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      abar = { (~A) }
+      bbar = { (~B) }
+      cbar = { (~C) }
+      dbar = { (~D) }
+      g = { (~(G1BAR & G2BAR)) }
+
+      O_0o = {~(abar & bbar & cbar & dbar & g)}
+      O_1o = {~(A & bbar & cbar & dbar & g)}
+      O_2o = {~(abar & B & cbar & dbar & g)}
+      O_3o = {~(A & B & cbar & dbar & g)}
+      O_4o = {~(abar & bbar & C & dbar & g)}
+      O_5o = {~(A & bbar & C & dbar & g)}
+      O_6o = {~(abar & B & C & dbar & g)}
+      O_7o = {~(A & B & C & dbar & g)}
+      O_8o = {~(abar & bbar & cbar & D & g)}
+      O_9o = {~(A & bbar & cbar & D & g)}
+      O_10o = {~(abar & B & cbar & D & g)}
+      O_11o = {~(A & B & cbar & D & g)}
+      O_12o = {~(abar & bbar & C & D & g)}
+      O_13o = {~(A & bbar & C & D & g)}
+      O_14o = {~(abar & B & C & D & g)}
+      O_15o = {~(A & B & C & D & g)}

Udly PINDLY (16,0,6) DPWR DGND
+      O_0o O_1o O_2o O_3o O_4o O_5o O_6o O_7o O_8o O_9o
+      O_10o O_11o O_12o O_13o O_14o O_15o
+      G1BAR G2BAR A B C D
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15
+      IO_STD_OC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       STROBE= { CHANGED(G1BAR,0) | CHANGED(G2BAR,0) }
+       DATA={ CHANGED(A,0) | CHANGED(B,0) | CHANGED(C,0) | CHANGED(D,0) }
+
+    PINDLY:
+      O0 O1 O2 O3 O4 O5 O6 O7 O8 O9
+      O10 O11 O12 O13 O14 O15   = {
+            CASE(
+                 DATA & TRN_LH, DELAY(-1,23ns,36ns),
+                 DATA & TRN_HL, DELAY(-1,24ns,36ns),
+                 STROBE & TRN_LH, DELAY(-1,15ns,25ns),
+                 STROBE & TRN_HL, DELAY(-1,22ns,36ns),
+                 DELAY(-1,25ns,37ns)
+                )
+            }

.ENDS 74159
*
*
* ----------------------------------------------------------- 74160 ------
*  Synchronous 4-Bit Decade Counter w/ Async Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/23/94
*
.SUBCKT 74160 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74160 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_STD

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,11ns,16ns),
+                   ENABLET & TRN_LH, DELAY(-1,11ns,16ns),
+                   CLOCK & TRN_LH, DELAY(-1,23ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                   DELAY(-1,24ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,26ns,38ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,20ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,15ns,23ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,17ns,25ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,19ns,29ns),
+                       DELAY(-1,27ns,39ns)
+                       )
+                     }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLRBAR LOADBAR CLK ENP A B C D
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(5) = A B C D ENP
+        SETUPTIME = 20n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS

.ENDS 74160

*------------------------------------------------------------74AC160----

* Synchronous Presettable BCD Decade Counter
* Motorola FACT Data, 1993, pages 5-109 to 5-121
* jat 8/22/96

.SUBCKT 74AC160
+ MRBAR PEBAR CEP CET CP P0 P1 P2 P3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,5) DPWR DGND
+ PEBAR CET CEP P0 P1 P2 P3 QAO QBO QCO QDO QDBARO
+ DA DB DC DD TCO
+ D0_GATE IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {PEBAR & CET & CEP}
+   XORA = {(PEBAR & QAO) ^ MODE}
+   DA = {XORA | (~PEBAR & P0)}
+   ANDB1 = {(~(MODE & QAO)) & PEBAR & QBO}
+   ANDB2 = {(~(PEBAR & QBO)) & MODE & QAO & QDBARO}
+   DB = {ANDB1 | ANDB2 | (~PEBAR & P1)}
+   XORC = {(PEBAR & QCO) ^ (MODE & QAO & QBO)}
+   DC = {XORC | (~PEBAR & P2)}
+   ANDD1 = {(~(MODE & QAO)) & PEBAR & QDO}
+   ANDD2 = {(~(PEBAR & QDO)) & MODE & QAO & QBO & QCO}
+   DD = {ANDD1 | ANDD2 | (~PEBAR & P3)}
+   TCO = {CET & QAO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CP
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ QAO QBO QCO QDO TCO
+ MRBAR CP ENT
+ Q0 Q1 Q2 Q3 TC
+ IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+  CLEAR = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(1.5NS,-1,9.5NS),
+     EDGE & (TRN_LH | TRN_HL), DELAY(1.5NS,-1,9NS),
+     DELAY(2.5NS,-1,10.5NS))}
+  TC = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(2.5NS,-1,12NS),
+     EDGE & (TRN_LH | TRN_HL), DELAY(2NS,-1,11NS),
+     TRICKLE & TRN_LH, DELAY(1.5NS,-1,7.5NS),
+     TRICKLE & TRN_HL, DELAY(2NS,-1,9NS),
+     DELAY(3.5NS,-1,13NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP PEBAR CEP CET MRBAR P0 P1 P2 P3
+ IO_AC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 110MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 3NS
+  MIN_LO = 3NS
+  WHEN = {PEBAR=='0}
+ WIDTH:
+  NODE = CP
+  MIN_HI = 4.5NS
+  MIN_LO = 4.5NS
+  WHEN = {PEBAR=='1 & CEP=='1 & CET=='1 & MRBAR=='1}
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 4.5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = P0 P1 P2 P3
+  SETUPTIME = 8.5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CET CEP
+  SETUPTIME = 4.5NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 7.5NS
+  HOLDTIME = 0.5NS

.ENDS 74AC160

*------------------------------------------------------------74ACT160----

* Synchronous Presettable BCD Decade Counter
* Motorola FACT Data, 1993, pages 5-109 to 5-121
* jat 8/27/96

.SUBCKT 74ACT160
+ MRBAR PEBAR CEP CET CP P0 P1 P2 P3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,5) DPWR DGND
+ PEBAR CET CEP P0 P1 P2 P3 QAO QBO QCO QDO QDBARO MRBAR
+ DA DB DC DD TCO
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {PEBAR & CET & CEP}
+   XORA = {(PEBAR & QAO) ^ MODE}
+   DA = {XORA | (~PEBAR & P0)}
+   ANDB1 = {(~(MODE & QAO)) & PEBAR & QBO}
+   ANDB2 = {(~(PEBAR & QBO)) & MODE & QAO & QDBARO}
+   DB = {ANDB1 | ANDB2 | (~PEBAR & P1)}
+   XORC = {(PEBAR & QCO) ^ (MODE & QAO & QBO)}
+   DC = {XORC | (~PEBAR & P2)}
+   ANDD1 = {(~(MODE & QAO)) & PEBAR & QDO}
+   ANDD2 = {(~(PEBAR & QDO)) & MODE & QAO & QBO & QCO}
+   DD = {ANDD1 | ANDD2 | (~PEBAR & P3)}
+   TCO = {CET & QAO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CP
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ QAO QBO QCO QDO TCO
+ MRBAR CP ENT
+ Q0 Q1 Q2 Q3 TC
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+  CLEAR = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(1.5NS,6NS,9.5NS),
+     EDGE & (TRN_LH | TRN_HL), DELAY(2NS,6NS,10NS),
+     DELAY(3NS,-1,11NS))}
+  TC = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(2.5NS,-1,13NS),
+     EDGE & (TRN_LH | TRN_HL), DELAY(2NS,8NS,12NS),
+     TRICKLE & TRN_LH, DELAY(2NS,6NS,8.5NS),
+     TRICKLE & TRN_HL, DELAY(2NS,7NS,9.5NS),
+     DELAY(3.5NS,-1,14NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP PEBAR CEP CET MRBAR P0 P1 P2 P3
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 120MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 3NS
+  MIN_LO = 3NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = P0 P1 P2 P3
+  SETUPTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CET CEP
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = PEBAR MRBAR
+  SETUPTIME = 4NS

.ENDS 74ACT160

*------------------------------------------------------------74ALS160----

* BCD Decade Counter with Asynchrnous Reset
* Motorola Schottky TTL Logic Databook, 1983, pages 5-42 to 5-50
* jat 8/20/96

.SUBCKT 74ALS160
+ CLRBAR LOADBAR ENT ENP CLK A B C D QA QB QC QD RCO
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,5) DPWR DGND
+ LOADBAR ENT ENP A B C D QAO QBO QCO QDO QDBARO
+ DA DB DC DD RCOO
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {LOADBAR & ENT & ENP}
+   XORA = {(LOADBAR & QAO) ^ MODE}
+   DA = {XORA | (~LOADBAR & A)}
+   ANDB1 = {(~(MODE & QAO)) & LOADBAR & QBO}
+   ANDB2 = {(~(LOADBAR & QBO)) & MODE & QAO & QDBARO}
+   DB = {ANDB1 | ANDB2 | (~LOADBAR & B)}
+   XORC = {(LOADBAR & QCO) ^ (MODE & QAO & QBO)}
+   DC = {XORC | (~LOADBAR & C)}
+   ANDD1 = {(~(MODE & QAO)) & LOADBAR & QDO}
+   ANDD2 = {(~(LOADBAR & QDO)) & MODE & QAO & QBO & QCO}
+   DD = {ANDD1 | ANDD2 | (~LOADBAR & D)}
+   RCOO = {ENT & QAO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ CLRBAR ENT CLK
+ QA QB QC QD RCO
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLK,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+  CLEAR = {CHANGED_HL(CLRBAR,0)}
+ PINDLY:
+  QA QB QC QD = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(8NS,-1,28NS),
+     EDGE & TRN_LH, DELAY(4NS,-1,22NS),
+     EDGE & TRN_HL, DELAY(6NS,-1,28NS),
+     DELAY(9NS,-1,29NS))}
+  RCO = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(11NS,-1,30NS),
+     EDGE & TRN_LH, DELAY(8NS,-1,23NS),
+     EDGE & TRN_HL, DELAY(7NS,-1,20NS),
+     TRICKLE & TRN_LH, DELAY(5NS,-1,20NS),
+     TRICKLE & TRN_HL, DELAY(4NS,-1,16NS),
+     DELAY(12NS,-1,31NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLK CLRBAR A B C D ENT ENP
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 15NS
+  MIN_LO = 15NS
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 16NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = A B C D
+  SETUPTIME = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(2) = ENT ENP
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 15NS

.ENDS 74ALS160

* ----------------------------------------------------------- 74AS160 ------
*  Synchronous 4-Bit Decade Counter w/ Async Clear
*
*  The ALS/AS TTL Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/23/94
*
.SUBCKT 74AS160 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS160 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_AS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_AS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   CLEAR & TRN_HL, DELAY(2ns,-1,12.5ns),
+                   ENABLET & TRN_HL, DELAY(1.5ns,-1,9ns),
+                   ENABLET & TRN_LH, DELAY(1ns,-1,8.5ns),
+                   CLOCK & LOADRisHIGH & TRN_LH, DELAY(1ns,-1,8ns),
+                   CLOCK & LOADRisLO & TRN_LH, DELAY(3ns,-1,16.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,-1,12.5ns),
+                   DELAY(4ns,-1,17.5ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(2ns,-1,13ns),
+                       CLOCK & TRN_LH, DELAY(1ns,-1,7ns),
+                       CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                       DELAY(3ns,-1,14ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_AS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 75MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 6.7ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 8ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(6) = A B C D ENP ENT
+        SETUPTIME = 8ns
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 8ns
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 9ns
+        WHEN = { (CLRBAR == '1) }

.ENDS 74AS160
*
*
* ----------------------------------------------------------- 74ALS160B ------
*  Synchronous 4-Bit Decade Counter w/ Async Clear
*
*  The TTL Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/23/94
*
.SUBCKT 74ALS160B A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS160B LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_ALS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   CLEAR & TRN_HL, DELAY(11ns,-1,23ns),
+                   ENABLET & TRN_HL, DELAY(3ns,-1,13ns),
+                   ENABLET & TRN_LH, DELAY(3ns,-1,13ns),
+                   CLOCK & TRN_LH, DELAY(5ns,-1,20ns),
+                   CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                   DELAY(6ns,-1,21ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(8ns,-1,24ns),
+                       CLOCK & TRN_LH, DELAY(4ns,-1,15ns),
+                       CLOCK & TRN_HL, DELAY(6ns,-1,20ns),
+                       DELAY(9ns,-1,25ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 12.5ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 15ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(6) = A B C D ENP ENT
+        SETUPTIME = 15ns
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 15ns
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 10ns
+        WHEN = { (CLRBAR == '1) }

.ENDS 74ALS160B
*
*
* ----------------------------------------------------------- 74F160A ------
*  Synchronous 4-Bit Decade Counter w/ Async Clear
*
*  The Philips FAST Logic Data Book, 1986, Pages 2-149 to 2-158
*  jds    3/24/94
*
.SUBCKT 74F160A D0 D1 D2 D3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F160A LOGICEXP (13, 10) DPWR DGND
+        D0 D1 D2 D3 CP CEP CET PEBAR Q0_O Q1_O Q2_O Q3_O Q3BAR_O
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~PEBAR) }
+      TC_O = { ( CET & Q0_O & Q3_O ) }
+      ia2 = { (~(load & D0)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & D1 )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt & Q3BAR_O)) }
+      ic2 = { (~(load & D2)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & D3)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & Q0_O & Q1_O & Q2_O) | (pnt & Q0_O & Q3_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI MRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar Q3BAR_O
+    D0_EFF IO_F

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5ns,4ns,6.5ns),
+                   ENABLET & TRN_HL, DELAY(2.5ns,5ns,7ns),
+                   CLOCK & TRN_LH, DELAY(4.5ns,8ns,10.5ns),
+                   CLOCK & TRN_HL, DELAY(4.5ns,7.5ns,9.5ns),
+                   DELAY(5.5ns,9ns,11.5ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(6.5ns,9ns,12ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(2ns,4.5ns,7ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(4ns,7ns,10ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(2ns,4.5ns,7.5ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(4ns,6ns,8.5ns),
+                       DELAY(5ns,10ns,13ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 130MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 4ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 5n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = CET CEP
+        SETUPTIME_LO = 6n
+        SETUPTIME_HI = 11n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME_HI = 11ns
+        SETUPTIME_LO = 7ns
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 5ns

.ENDS 74F160A
*
*
* ----------------------------------------------------------- 74HC160 ------
*  Synchronous 4-Bit Decade Counter w/ Async Clear
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-217 to 2-228
*  jds    3/24/94
*
.SUBCKT 74HC160 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC160 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_HC

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,17ns,39ns),
+                   ENABLET & TRN_LH, DELAY(-1,17ns,39ns),
+                   CLOCK & TRN_LH, DELAY(-1,24ns,43ns),
+                   CLOCK & TRN_HL, DELAY(-1,24ns,43ns),
+                   CLEAR & TRN_HL, DELAY(-1,22ns,44ns),
+                   DELAY(-1,25ns,45ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,21ns,42ns),
+                       CLOCK & TRN_LH, DELAY(-1,25ns,41ns),
+                       CLOCK & TRN_HL, DELAY(-1,25ns,41ns),
+                       DELAY(-1,26ns,43ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+         MIN_LO = 16ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 16n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 30n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 34NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 27NS

.ENDS 74HC160

*------------------------------------------------------------74HCT160----

* Presettable Synchronous BCD Decade Counter; Asynchronous Reset
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 321 to 327
* jat 9/5/96

.SUBCKT 74HCT160
+ MRBAR PEBAR CEP CET CP D0 D1 D2 D3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(15,5) DPWR DGND
+ PEBAR CET CEP D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ DATA0 DATA1 DATA2 DATA3 TCO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CE = {~(CET & CEP)}
+   XNOR0 = {~(Q0BARO ^ ~CE)}
+   XNOR1 = {(CE & Q1O) | (~CE & (Q3BARO & (Q1O ^ Q0O)))}
+   XNOR2 = {(CE & Q2O) | (~CE & ((Q3BARO & Q2O & (Q1BARO | Q0BARO)) | (Q2BARO & Q1O & Q0O)))}
+   XNOR3 = {(CE & Q3O) | (~CE & ((Q3O & Q0BARO) | (Q3BARO & Q2O & Q1O & Q0O)))}
+   DATA0 = {(~PEBAR & D0) | (PEBAR & XNOR0)}
+   DATA1 = {(~PEBAR & D1) | (PEBAR & XNOR1)}
+   DATA2 = {(~PEBAR & D2) | (PEBAR & XNOR2)}
+   DATA3 = {(~PEBAR & D3) | (PEBAR & XNOR3)}
+   TCO = {CET & Q0O & Q1BARO & Q2BARO & Q3O}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CP
+ DATA0 DATA1 DATA2 DATA3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO
+ MRBAR CP CET
+ Q0 Q1 Q2 Q3 TC
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  TRICKLE = {CHANGED(CET,0)}
+  CLEAR = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(-1,27NS,50NS),
+     EDGE & (TRN_LH | TRN_HL), DELAY(-1,25NS,43NS),
+     DELAY(-1,28NS,51NS))}
+  TC = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(-1,30NS,50NS),
+     EDGE & TRN_LH, DELAY(-1,23NS,39NS),
+     EDGE & TRN_HL, DELAY(-1,28NS,48NS),
+     TRICKLE & TRN_LH, DELAY(-1,9NS,17NS),
+     TRICKLE & TRN_HL, DELAY(-1,17NS,35NS),
+     DELAY(-1,31NS,51NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP PEBAR CEP CET MRBAR D0 D1 D2 D3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 28MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 8NS
+  MIN_LO = 8NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 11NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CET CEP
+  SETUPTIME = 30NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 18NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 9NS

.ENDS 74HCT160

* ----------------------------------------------------------- 74LS160A ------
*  Synchronous 4-Bit Decade Counter w/ Async Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/24/94
*
.SUBCKT 74LS160A A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS160A LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_LS

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,9ns,14ns),
+                   ENABLET & TRN_LH, DELAY(-1,9ns,14ns),
+                   CLOCK & TRN_LH, DELAY(-1,20ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,18ns,35ns),
+                   DELAY(-1,21ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,20ns,28ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,18ns,27ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,18ns,27ns),
+                       DELAY(-1,21ns,29ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 20n
+        HOLDTIME = 3n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(3) = LOADBAR ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS

.ENDS 74LS160A
*
*
* ----------------------------------------------------------- 74161 ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/25/94
*
.SUBCKT 74161 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74161 LOGICEXP (12, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & QA_O & QB_O & QC_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_STD

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,11ns,16ns),
+                   ENABLET & TRN_LH, DELAY(-1,11ns,16ns),
+                   CLOCK & TRN_LH, DELAY(-1,23ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                   DELAY(-1,24ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,26ns,38ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,20ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,15ns,23ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,17ns,25ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,19ns,29ns),
+                       DELAY(-1,27ns,39ns)
+                       )
+                     }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLRBAR LOADBAR CLK ENP A B C D
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(5) = A B C D ENP
+        SETUPTIME = 20n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS

.ENDS 74161

*------------------------------------------------------------74161A-------

* Synchronous 4-Bit Counters
* National LS/S/TTL Logic Data Handbook, 1989, pgaes 4-159 to 4-166
* jat 8/7/96

.SUBCKT 74161A DATAA DATAB DATAC DATAD CLRBAR CLOCK ENABP ENABT LDBAR
+ QA QB QC QD RCO
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,10) DPWR DGND
+ CLOCK DATAA DATAB DATAC DATAD CLRBAR LDBAR ENABP ENABT QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ CLOCKBAR JA JB JC JD KA KB KC KD RCOO
+ D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CLOCKBAR = {~CLOCK}
+  ENAB = {(CLRBAR & LDBAR) & ENABP & ENABT}
+  LOADENAB = {~(CLRBAR & LDBAR)}
+  JA = {(DATAA & CLRBAR & LOADENAB) | (ENAB & QABAR)}
+  KA = {(QA & ENAB) | (LOADENAB & ~JA)}
+  JB = {(DATAB & CLRBAR & LOADENAB) | (ENAB & QA & QBBAR)}
+  KB = {(QB & QA & ENAB) | (LOADENAB & ~JB)}
+  JC = {(DATAC & CLRBAR & LOADENAB) | (ENAB & QA & QB & QCBAR)}
+  KC = {(QC & QB & QA & ENAB) | (LOADENAB & ~JC)}
+  JD = {(DATAD & CLRBAR & LOADENAB) | (ENAB & QA & QB & QC & QDBAR)}
+  KD = {(QD & QC & QB & QA & ENAB) | (LOADENAB & ~JD)}
+  RCOO = {~(ENABT & QABAR & QBBAR & QCBAR & QDBAR)}

U2 JKFF(4) DPWR DGND
+ $D_HI CLRBAR CLOCKBAR
+ JA JB JC JD KA KB KC KD
+ QAO QBO QCO QDO QABAR QBBAR QCBAR QDBAR
+ D0_EFF IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,4) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ CLOCK CLRBAR ENABT LDBAR
+ QA QB QC QD RCO
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CLOCK,0)}
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   TT = {CHANGED(ENABT,0)}
+ PINDLY:
+   QA QB QC QD = {
+      CASE(
+         CLEAR & TRN_HL, DELAY(-1,-1,36NS),
+         EDGE & (LDBAR == '0) & TRN_LH, DELAY(-1,-1,21NS),
+         EDGE & (LDBAR == '0) & TRN_HL, DELAY(-1,-1,32NS),
+         EDGE & (LDBAR == '1) & TRN_LH, DELAY(-1,-1,20NS),
+         EDGE & (LDBAR == '1) & TRN_HL, DELAY(-1,-1,32NS),
+         DELAY(-1,-1,33NS))}
+   RCO = {
+      CASE(
+         TT & (TRN_LH | TRN_HL), DELAY(-1,-1,16NS),
+         EDGE & TRN_LH, DELAY(-1,-1,27NS),
+         EDGE & TRN_HL, DELAY(-1,-1,24NS),
+         DELAY(-1,-1,28NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLOCK CLRBAR DATA DATAB DATAC DATAD ENABP LDBAR
+ IO_STD IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 25MEG
+ WIDTH:
+  NODE = CLOCK
+  MIN_LO = 25NS
+  MIN_HI = 25NS
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(4) = DATA DATAB DATAC DATAD
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = ENABP
+  SETUPTIME = 34NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LDBAR
+  SETUPTIME = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 20NS

.ENDS 74161A

* ----------------------------------------------------------- 74AC161 ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    3/25/94                                                                   Pages 4-83 to 4-90
*
.SUBCKT 74AC161 P0 P1 P2 P3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC161 LOGICEXP (12, 10) DPWR DGND
+        P0 P1 P2 P3 CP CEP CET PEBAR Q0_O Q1_O Q2_O Q3_O
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_AC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~PEBAR) }
+      TC_O = { ( CET & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ia2 = { (~(load & P0)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & P1 )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt)) }
+      ic2 = { (~(load & P2)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & P3)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & Q0_O & Q1_O & Q2_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI MRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar qdbar
+    D0_EFF IO_AC

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5s,3.5ns,6.5ns),
+                   ENABLET & TRN_HL, DELAY(2ns,5ns,8.5ns),
+                   CLOCK & TRN_LH, DELAY(2ns,6ns,10.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,6.5ns,11ns),
+                   CLEAR & TRN_HL, DELAY(2.5ns,8.5ns,13ns),
+                   DELAY(3.5ns,12ns,14ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(1.5ns,5ns,9ns),
+                       CLOCK & TRN_HL, DELAY(1.5ns,5ns,9.5ns),
+                       CLEAR & TRN_LH, DELAY(1.5ns,5.5ns,9.5ns),
+                       DELAY(2.5ns,6.5ns,10.5ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET P0 P1 P2 P3
+          IO_AC
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 167MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 2ns
+         MIN_LO = 2ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 2.5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 3.5n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME = 2NS
+        HOLDTIME = 2NS
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 1NS
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        HOLDTIME = 3.5NS

.ENDS 74AC161
*
*
* ----------------------------------------------------------- 74ACT161 ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, Pages 4-83 to 4-90
*  jds    3/24/94
*
.SUBCKT 74ACT161 P0 P1 P2 P3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ACT161 LOGICEXP (12, 10) DPWR DGND
+        P0 P1 P2 P3 CP CEP CET PEBAR Q0_O Q1_O Q2_O Q3_O
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_ACT IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~PEBAR) }
+      TC_O = { ( CET & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ia2 = { (~(load & P0)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & P1 )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt)) }
+      ic2 = { (~(load & P2)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & P3)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & Q0_O & Q1_O & Q2_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI MRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar qdbar
+    D0_EFF IO_ACT

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5s,7.5ns,9ns),
+                   ENABLET & TRN_HL, DELAY(1.5ns,8ns,10ns),
+                   CLOCK & TRN_LH, DELAY(2ns,11ns,13.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,11ns,13ns),
+                   CLEAR & TRN_HL, DELAY(2.5ns,10ns,11.5ns),
+                   DELAY(3.5ns,12ns,14.5ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(1.5ns,8ns,10ns),
+                       CLOCK & TRN_HL, DELAY(1.5ns,8ns,10ns),
+                       CLEAR & TRN_LH, DELAY(1.5ns,8ns,9.5ns),
+                       DELAY(2.5ns,9ns,11ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET P0 P1 P2 P3
+          IO_ACT
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 125MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 2ns
+         MIN_LO = 2ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 3n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 7n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        HOLDTIME = 2NS
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME = 6NS
+        HOLDTIME = 3.5NS

.ENDS 74ACT161

*------------------------------------------------------------74ALS161----

* 4-Bit Binary Counter with Asynchrnous Reset
* Motorola Schottky TTL Logic Databook, 1983, pages 5-42 to 5-50
* jat 8/20/96

.SUBCKT 74ALS161
+ CLRBAR LOADBAR ENT ENP CLK A B C D QA QB QC QD RCO
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(11,5) DPWR DGND
+ LOADBAR ENT ENP A B C D QAO QBO QCO QDO
+ DA DB DC DD RCOO
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {LOADBAR & ENT & ENP}
+   XORA = {(LOADBAR & QAO) ^ MODE}
+   DA = {XORA | (~LOADBAR & A)}
+   XORB = {(LOADBAR & QBO) ^ (MODE & QAO)}
+   DB = {XORB | (~LOADBAR & B)}
+   XORC = {(LOADBAR & QCO) ^ (MODE & QAO & QBO)}
+   DC = {XORC | (~LOADBAR & C)}
+   XORD = {(LOADBAR & QDO) ^ (MODE & QAO & QBO & QCO)}
+   DD = {XORD | (~LOADBAR & D)}
+   RCOO = {ENT & QAO & QBO & QCO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI CLRBAR CLK
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ CLRBAR ENT CLK
+ QA QB QC QD RCO
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLK,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+  CLEAR = {CHANGED_HL(CLRBAR,0)}
+ PINDLY:
+  QA QB QC QD = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(8NS,-1,28NS),
+     EDGE & TRN_LH, DELAY(4NS,-1,22NS),
+     EDGE & TRN_HL, DELAY(6NS,-1,26NS),
+     DELAY(9NS,-1,29NS))}
+  RCO = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(11NS,-1,28NS),
+     EDGE & TRN_LH, DELAY(8NS,-1,23NS),
+     EDGE & TRN_HL, DELAY(7NS,-1,20NS),
+     TRICKLE & TRN_LH, DELAY(5NS,-1,20NS),
+     TRICKLE & TRN_HL, DELAY(4NS,-1,16NS),
+     DELAY(12NS,-1,29NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLK CLRBAR A B C D ENT ENP
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 15NS
+  MIN_LO = 15NS
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 16NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = A B C D
+  SETUPTIME = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(2) = ENT ENP
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 15NS

.ENDS 74ALS161

* ----------------------------------------------------------- 74ALS161B ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/25/94
*
.SUBCKT 74ALS161B A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS161B LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & QA_O & QB_O & QC_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_ALS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(3ns,-1,13ns),
+                   ENABLET & TRN_LH, DELAY(3ns,-1,13ns),
+                   CLOCK & TRN_LH, DELAY(5ns,-1,20ns),
+                   CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                   CLEAR & TRN_HL, DELAY(11ns,-1,23ns),
+                   DELAY(6ns,-1,24ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(8ns,-1,24ns),
+                       CLOCK & TRN_LH, DELAY(4ns,-1,15ns),
+                       CLOCK & TRN_HL, DELAY(6ns,-1,20ns),
+                       DELAY(9ns,-1,25ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 12.5ns
+         MIN_LO = 12.5ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 15n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 15n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 15NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 10NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 15NS

.ENDS 74ALS161B
*
*
* ----------------------------------------------------------- 74AS161 ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/25/94
*
.SUBCKT 74AS161 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS161 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_AS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & QA_O & QB_O & QC_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_AS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   CLEAR & TRN_HL, DELAY(2ns,-1,12.5ns),
+                   ENABLET & TRN_HL, DELAY(1.5ns,-1,9ns),
+                   ENABLET & TRN_LH, DELAY(1ns,-1,8.5ns),
+                   CLOCK & LOADRisHIGH & TRN_LH, DELAY(1ns,-1,8ns),
+                   CLOCK & LOADRisLO & TRN_LH, DELAY(3ns,-1,16.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,-1,12.5ns),
+                   DELAY(4ns,-1,17.5ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(2ns,-1,13ns),
+                       CLOCK & TRN_LH, DELAY(1ns,-1,7ns),
+                       CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                       DELAY(3ns,-1,14ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_AS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 75MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 6.7ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 8ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(6) = A B C D ENP ENT
+        SETUPTIME = 8ns
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 8ns
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 9ns
+        WHEN = { (CLRBAR == '1) }

.ENDS 74AS161
*
*
* ----------------------------------------------------------- 74F161A ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  The Philips FAST Logic Data Book, 1992, Pages 198 - 209
*   jds    3/25/94
*
.SUBCKT 74F161A D0 D1 D2 D3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F161A LOGICEXP (13, 10) DPWR DGND
+        D0 D1 D2 D3 CP CEP CET PEBAR Q0_O Q1_O Q2_O Q3_O MRBAR
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~PEBAR) }
+      TC_O = { ( CET & Q0_O & Q1_O & Q2_O & Q3_O) }
+      ia2 = { (~(load & D0)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & D1 )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt)) }
+      ic2 = { (~(load & D2)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & D3)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & Q0_O & Q1_O & Q2_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }



uf0  JKff(4)  DPWR DGND
+    $D_HI MRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar qdbar
+    D0_EFF IO_F

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5ns,3.5ns,6.5ns),
+                   ENABLET & TRN_HL, DELAY(2.5ns,5ns,7.5ns),
+                   CLOCK & TRN_LH, DELAY(5ns,7.5ns,10.5ns),
+                   CLOCK & TRN_HL, DELAY(4.5ns,7.5ns,10.5ns),
+                   CLEAR & TRN_HL, DELAY(5ns,8.5ns,10ns),
+                   DELAY(6ns,9.5ns,11.5ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(6ns,8.5ns,12ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(2ns,4ns,6.5ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(4ns,6.5ns,10ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(2ns,4.5ns,6ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(3.5ns,5.5ns,8.5ns),
+                       DELAY(7ns,9.5ns,13ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 130MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 4ns
+         MIN_LO = 6ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 4.5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 5n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME_HI = 10.5ns
+        SETUPTIME_LO = 6ns
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 6ns
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME_HI = 9ns
+        SETUPTIME_LO = 6.5ns

.ENDS 74F161A
*
*
* ----------------------------------------------------------- 74HC161 ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-217 to 2-228
*  jds    3/24/94
*
.SUBCKT 74HC161 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC161 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & QA_O & QB_O & QC_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_HC

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,17ns,39ns),
+                   ENABLET & TRN_LH, DELAY(-1,17ns,39ns),
+                   CLOCK & TRN_LH, DELAY(-1,24ns,43ns),
+                   CLOCK & TRN_HL, DELAY(-1,24ns,43ns),
+                   CLEAR & TRN_HL, DELAY(-1,22ns,44ns),
+                   DELAY(-1,25ns,45ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,21ns,42ns),
+                       CLOCK & TRN_LH, DELAY(-1,25ns,41ns),
+                       CLOCK & TRN_HL, DELAY(-1,25ns,41ns),
+                       DELAY(-1,26ns,43ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+         MIN_LO = 16ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 16n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 30n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 34NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 27NS

.ENDS 74HC161

*------------------------------------------------------------74HC161A----

* Presettable Counter
* Motorola High-Speed CMOS Logic Data, 1993, pages 5-171 to 5-181
* jat 9/5/96

.SUBCKT 74HC161A
+ RESET LOAD ENP ENT CLOCK P0 P1 P2 P3 Q0 Q1 Q2 Q3 RCO
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(15,5) DPWR DGND
+ LOAD ENT ENP P0 P1 P2 P3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ DATA0 DATA1 DATA2 DATA3 RCOO
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CE = {~(ENT & ENP)}
+   XNOR0 = {~(Q0BARO ^ ~CE)}
+   XNOR1 = {~(Q1BARO ^ (~(CE | Q0BARO)))}
+   XNOR2 = {~(Q2BARO ^ (~(CE | Q1BARO | Q0BARO)))}
+   NOR3 = {~(CE | Q2BARO | Q1BARO | Q0BARO)}
+   OR3 = {(NOR3 & Q3BARO) | (~(NOR3 | Q3BARO))}
+   DATA0 = {(~LOAD & P0) | (LOAD & XNOR0)}
+   DATA1 = {(~LOAD & P1) | (LOAD & XNOR1)}
+   DATA2 = {(~LOAD & P2) | (LOAD & XNOR2)}
+   DATA3 = {(~LOAD & P3) | (LOAD & OR3)}
+   RCOO = {ENT & Q0O & Q1O & Q2O & Q3O}

U2 DFF(4) DPWR DGND
+ $D_HI RESET CLOCK
+ DATA0 DATA1 DATA2 DATA3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O RCOO
+ RESET CLOCK ENT
+ Q0 Q1 Q2 Q3 RCO
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLOCK,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+  CLEAR = {CHANGED_HL(RESET,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(-1,-1,20NS),
+     EDGE & TRN_LH, DELAY(-1,-1,20NS),
+     EDGE & TRN_HL, DELAY(-1,-1,22NS),
+     DELAY(-1,-1,23NS))}
+  RCO = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(-1,-1,22NS),
+     EDGE & TRN_LH, DELAY(-1,-1,22NS),
+     EDGE & TRN_HL, DELAY(-1,-1,22NS),
+     TRICKLE & TRN_LH, DELAY(-1,-1,16NS),
+     TRICKLE & TRN_HL, DELAY(-1,-1,18NS),
+     DELAY(-1,-1,23NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CLOCK RESET P0 P1 P2 P3 LOAD ENT ENP
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLOCK
+  MIN_HI = 12NS
+  MIN_LO = 12NS
+ WIDTH:
+  NODE = RESET
+  MIN_LO = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(4) = P0 P1 P2 P3
+  SETUPTIME = 15NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(2) = ENT ENP
+  SETUPTIME = 20NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LOAD
+  SETUPTIME = 15NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = RESET
+  SETUPTIME_HI = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LOAD
+  SETUPTIME_HI = 15NS

.ENDS 74HC161A

*------------------------------------------------------------74HCT161----

* Presettable Synchronous 4 Bit Binary Counter; Asynchronous Reset
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 329 to 334
* jat 9/5/96

.SUBCKT 74HCT161
+ MRBAR PEBAR CEP CET CP D0 D1 D2 D3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(15,5) DPWR DGND
+ PEBAR CET CEP D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ DATA0 DATA1 DATA2 DATA3 TCO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CE = {~(CET & CEP)}
+   XNOR0 = {~(Q0BARO ^ ~CE)}
+   XNOR1 = {~(Q1BARO ^ (~(CE | Q0BARO)))}
+   XNOR2 = {~(Q2BARO ^ (~(CE | Q1BARO | Q0BARO)))}
+   NOR3 = {~(CE | Q2BARO | Q1BARO | Q0BARO)}
+   OR3 = {(NOR3 & Q3BARO) | (~(NOR3 | Q3BARO))}
+   DATA0 = {(~PEBAR & D0) | (PEBAR & XNOR0)}
+   DATA1 = {(~PEBAR & D1) | (PEBAR & XNOR1)}
+   DATA2 = {(~PEBAR & D2) | (PEBAR & XNOR2)}
+   DATA3 = {(~PEBAR & D3) | (PEBAR & OR3)}
+   TCO = {CET & Q0O & Q1O & Q2O & Q3O}

U2 DFF(4) DPWR DGND
+ $D_HI MRBAR CP
+ DATA0 DATA1 DATA2 DATA3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO
+ MRBAR CP CET
+ Q0 Q1 Q2 Q3 TC
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  TRICKLE = {CHANGED(CET,0)}
+  CLEAR = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(-1,29NS,46NS),
+     EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,43NS),
+     DELAY(-1,30NS,47NS))}
+  TC = {
+   CASE(
+     CLEAR & TRN_HL, DELAY(-1,30NS,51NS),
+     EDGE & TRN_LH, DELAY(-1,28NS,48NS),
+     EDGE & TRN_HL, DELAY(-1,28NS,48NS),
+     TRICKLE & TRN_LH, DELAY(-1,17NS,35NS),
+     TRICKLE & TRN_HL, DELAY(-1,17NS,35NS),
+     DELAY(-1,31NS,52NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP PEBAR CEP CET MRBAR D0 D1 D2 D3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 41MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ WIDTH:
+  NODE = MRBAR
+  MIN_LO = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 8NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CET CEP
+  SETUPTIME = 17NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 17NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME_HI = 6NS

.ENDS 74HCT161

* ----------------------------------------------------------- 74LS161A ------
*  Synchronous 4-Bit Binary Counter w/ Async Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/25/94
*
.SUBCKT 74LS161A A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS161A LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~LOADBAR) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O) }
+      ia2 = { (~(load & A)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B )) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (pnt & QA_O & QB_O & QC_O)) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_LS

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,9ns,14ns),
+                   ENABLET & TRN_LH, DELAY(-1,9ns,14ns),
+                   CLOCK & TRN_LH, DELAY(-1,20ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,18ns,35ns),
+                   DELAY(-1,21ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,20ns,28ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,18ns,27ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,18ns,27ns),
+                       DELAY(-1,21ns,29ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 20n
+        HOLDTIME = 3n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(3) = LOADBAR ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS

.ENDS 74LS161A

*------------------------------------------------------------74S161-------

* Synchronous 4-Bit Counters
* National LS/S/TTL Logic Data Handbook, 1989, pages 3-71 to 3-76
* jat 8/7/96

.SUBCKT 74S161 DATAA DATAB DATAC DATAD CLRBAR CLOCK ENABP ENABT LDBAR
+ QA QB QC QD RCO
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,10) DPWR DGND
+ CLOCK DATAA DATAB DATAC DATAD CLRBAR LDBAR ENABP ENABT QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ CLOCKBAR JA JB JC JD KA KB KC KD RCOO
+ D0_GATE IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CLOCKBAR = {~CLOCK}
+  ENAB = {(CLRBAR & LDBAR) & ENABP & ENABT}
+  LOADENAB = {~(CLRBAR & LDBAR)}
+  JA = {(DATAA & CLRBAR & LOADENAB) | (ENAB & QABAR)}
+  KA = {(QA & ENAB) | (LOADENAB & ~JA)}
+  JB = {(DATAB & CLRBAR & LOADENAB) | (ENAB & QA & QBBAR)}
+  KB = {(QB & QA & ENAB) | (LOADENAB & ~JB)}
+  JC = {(DATAC & CLRBAR & LOADENAB) | (ENAB & QA & QB & QCBAR)}
+  KC = {(QC & QB & QA & ENAB) | (LOADENAB & ~JC)}
+  JD = {(DATAD & CLRBAR & LOADENAB) | (ENAB & QA & QB & QC & QDBAR)}
+  KD = {(QD & QC & QB & QA & ENAB) | (LOADENAB & ~JD)}
+  RCOO = {~(ENABT & QABAR & QBBAR & QCBAR & QDBAR)}

U2 JKFF(4) DPWR DGND
+ $D_HI CLRBAR CLOCKBAR
+ JA JB JC JD KA KB KC KD
+ QAO QBO QCO QDO QABAR QBBAR QCBAR QDBAR
+ D0_EFF IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,3) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ CLOCK CLRBAR ENABT
+ QA QB QC QD RCO
+ IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CLOCK,0)}
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   TT = {CHANGED(ENABT,0)}
+ PINDLY:
+   QA QB QC QD = {
+      CASE(
+         CLEAR & TRN_HL, DELAY(-1,-1,20NS),
+         EDGE & TRN_LH, DELAY(-1,-1,15NS),
+         EDGE & TRN_HL, DELAY(-1,-1,15NS),
+         DELAY(-1,-1,21NS))}
+   RCO = {
+      CASE(
+         TT & (TRN_LH | TRN_HL), DELAY(-1,-1,15NS),
+         EDGE & TRN_LH, DELAY(-1,-1,25NS),
+         EDGE & TRN_HL, DELAY(-1,-1,25NS),
+         DELAY(-1,-1,26NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CLOCK CLRBAR DATA DATAB DATAC DATAD ENABP ENABT LDBAR
+ IO_S IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 40MEG
+ WIDTH:
+  NODE = CLOCK
+  MIN_LO = 10NS
+  MIN_HI = 10NS
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 10NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(4) = DATA DATAB DATAC DATAD
+  SETUPTIME = 4NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(2) = ENABP ENABT
+  SETUPTIME = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LDBAR
+  SETUPTIME = 14NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LDBAR
+  SETUPTIME_HI = 12NS

.ENDS 74S161

* ----------------------------------------------------------- 74162 ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/23/94
*
.SUBCKT 74162 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74162 LOGICEXP (14, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_STD

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,11ns,16ns),
+                   ENABLET & TRN_LH, DELAY(-1,11ns,16ns),
+                   CLOCK & TRN_LH, DELAY(-1,23ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                   DELAY(-1,24ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,26ns,38ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,20ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,15ns,23ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,17ns,25ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,19ns,29ns),
+                       DELAY(-1,27ns,39ns)
+                       )
+                     }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLRBAR LOADBAR CLK ENP A B C D
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(5) = A B C D ENP
+        SETUPTIME = 20n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS

.ENDS 74162
*
*
*------------------------------------------------------------74AC162----
*
* The 74AC162 Synchronous Presettable BCD Decade Counter
* Motorola FACT Data, 1993, pages 5-109 to 5-121
* logic diagram from Philips Semiconductors FAST TTL Data Handbook,1992,p204
* jat 8/3/95

.SUBCKT 74AC162
+ SRBAR PEBAR CEP CET CP P0 P1 P2 P3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) DPWR DGND
+ PEBAR CET CEP Q_0 Q_1 Q_2 Q_3 SRBAR P0 P1 P2 P3 Q_0BAR Q_1BAR Q_2BAR Q_3BAR
+ D0 D1 D2 D3 T_C
+ D0_GATE IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   PE = {~PEBAR}
+   MODE = {PEBAR & CET & CEP}
+   XNOR0 = {(Q_0 & SRBAR & PEBAR) ^ (SRBAR & MODE)}
+   XNOR1 = {(Q_1 & SRBAR & PEBAR) ^ (Q_0 & SRBAR & MODE)}
+   XNOR2 = {(Q_2 & SRBAR & PEBAR) ^ (Q_1 & Q_0 & SRBAR & MODE)}
+   XNOR3 = {(Q_3 & SRBAR & PEBAR) ^
+            (Q_2 & Q_1 & Q_0 & SRBAR & MODE)}
+   D0 = {XNOR0 | (P0 & PE & SRBAR)}
+   OR1 = {XNOR1 | (P1 & PE & SRBAR)}
+   D1 = {OR1 & (Q_0BAR | Q_1 | Q_2 | Q_3BAR) &
+        (Q_0BAR | Q_1 | Q_2BAR | Q_3BAR)}
+   D2 = {XNOR2 | (P2 & PE & SRBAR)}
+   OR3 = {XNOR3 | (P3 & PE & SRBAR)}
+   OR3A = {Q_0BAR | Q_1 | Q_2 | Q_3BAR}
+   OR3B = {Q_0BAR | Q_1 | Q_2BAR | Q_3BAR}
+   OR3C = {Q_0BAR | Q_1BAR | Q_2 | Q_3BAR}
+   D3 = {OR3 & OR3A & OR3B & OR3C}
+   T_C = {CET & Q_0 & Q_1BAR & Q_2BAR & Q_3}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ D0 D1 D2 D3 Q_0 Q_1 Q_2 Q_3 Q_0BAR Q_1BAR Q_2BAR Q_3BAR
+ D0_EFF IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3 T_C
+ CP CET
+ Q0 Q1 Q2 Q3 TC
+ IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CP,0)}
+          TRICKLE = {CHANGED(CET,0)}
+ PINDLY:
+          Q0 Q1 Q2 Q3 = {
+           CASE(
+             EDGE & (TRN_LH | TRN_HL), DELAY(2NS,-1,9NS),
+             DELAY(3NS,-1,10NS))}
+          TC = {
+           CASE(
+             TRICKLE & TRN_LH, DELAY(2NS,-1,7NS),
+             TRICKLE & TRN_HL, DELAY(2NS,-1,8NS),
+             EDGE & (TRN_LH | TRN_HL), DELAY(2NS,-1,11NS),
+             DELAY(3NS,-1,12NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP P0 P1 P2 P3 PEBAR CEP CET SRBAR
+ IO_AC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(4) = P0 P1 P2 P3
+             SETUPTIME = 6NS
+             HOLDTIME = 1NS
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(1) = PEBAR
+             SETUPTIME = 7NS
+             HOLDTIME = 1NS
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(2) = CEP CET
+             SETUPTIME = 5NS
+             HOLDTIME = 1NS
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(1) = SRBAR
+             SETUPTIME = 7NS
+             HOLDTIME = 1NS
+ WIDTH:
+        NODE = CP
+        MIN_HI = 5NS
+        MIN_LO = 5NS
+        WHEN = {(SRBAR == '1) & (PEBAR == '0)}
+ WIDTH:
+        NODE = CP
+        MIN_HI = 4.5NS
+        MIN_LO = 4.5NS
+        WHEN = {(SRBAR == '1) & (PEBAR == '1) & (CET == '1) & (CEP == '1)}
+ FREQ:
+        NODE = CP
+        MAXFREQ = 100MEG

.ENDS 74AC162

*------------------------------------------------------------74ACT162----

* Synchronous Presettable BCD Decade Counter
* Motorola FACT Data, 1993, pages 5-109 to 5-121
* jat 8/27/96

.SUBCKT 74ACT162
+ SRBAR PEBAR CEP CET CP P0 P1 P2 P3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,5) DPWR DGND
+ PEBAR CET CEP P0 P1 P2 P3 QAO QBO QCO QDO QDBARO SRBAR
+ DA DB DC DD TCO
+ D0_GATE IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {PEBAR & CET & CEP}
+   XORA = {(PEBAR & QAO) ^ MODE}
+   DA = {SRBAR & (XORA | (~PEBAR & P0))}
+   ANDB1 = {(~(MODE & QAO)) & PEBAR & QBO}
+   ANDB2 = {(~(PEBAR & QBO)) & MODE & QAO & QDBARO}
+   DB = {SRBAR & (ANDB1 | ANDB2 | (~PEBAR & P1))}
+   XORC = {(PEBAR & QCO) ^ (MODE & QAO & QBO)}
+   DC = {SRBAR & (XORC | (~PEBAR & P2))}
+   ANDD1 = {(~(MODE & QAO)) & PEBAR & QDO}
+   ANDD2 = {(~(PEBAR & QDO)) & MODE & QAO & QBO & QCO}
+   DD = {SRBAR & (ANDD1 | ANDD2 | (~PEBAR & P3))}
+   TCO = {CET & QAO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ QAO QBO QCO QDO TCO
+ CP ENT
+ Q0 Q1 Q2 Q3 TC
+ IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  TRICKLE = {CHANGED(ENT,0)}
+  EDGE = {CHANGED_LH(CP,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     EDGE & (TRN_LH | TRN_HL), DELAY(2NS,6NS,10NS),
+     DELAY(3NS,-1,11NS))}
+  TC = {
+   CASE(
+     EDGE & (TRN_LH | TRN_HL), DELAY(2NS,8NS,13NS),
+     TRICKLE & TRN_LH, DELAY(2NS,6NS,9NS),
+     TRICKLE & TRN_HL, DELAY(2NS,6NS,9NS),
+     DELAY(3NS,9NS,14NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CP PEBAR SRBAR CET P0 P1 P2 P3
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 120MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 2NS
+  MIN_LO = 2NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = P0 P1 P2 P3
+  SETUPTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = CET
+  SETUPTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 4NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = SRBAR
+  SETUPTIME = 5NS

.ENDS 74ACT162

*------------------------------------------------------------74ALS162----

* BCD Decade Counter with Synchrnous Reset
* Motorola Schottky TTL Logic Databook, 1983, pages 5-42 to 5-50
* jat 8/20/96

.SUBCKT 74ALS162
+ CLRBAR LOADBAR ENT ENP CLK A B C D QA QB QC QD RCO
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(13,5) DPWR DGND
+ LOADBAR ENT ENP A B C D QAO QBO QCO QDO QDBARO CLRBAR
+ DA DB DC DD RCOO
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {LOADBAR & ENT & ENP & CLRBAR}
+   X1 = {~LOADBAR & CLRBAR}
+   X2 = {LOADBAR & CLRBAR}
+   XORA = {(X2 & QAO) ^ MODE}
+   DA = {XORA | (X1 & A)}
+   ANDB1 = {(~(MODE & QAO)) & X2 & QBO}
+   ANDB2 = {(~(X2 & QBO)) & MODE & QAO & QDBARO}
+   DB = {ANDB1 | ANDB2 | (X1 & B)}
+   XORC = {(X2 & QCO) ^ (MODE & QAO & QBO)}
+   DC = {XORC | (X1 & C)}
+   ANDD1 = {(~(MODE & QAO)) & X2 & QDO}
+   ANDD2 = {(~(X2 & QDO)) & MODE & QAO & QBO & QCO}
+   DD = {ANDD1 | ANDD2 | (X1 & D)}
+   RCOO = {ENT & QAO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CLK
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ ENT CLK
+ QA QB QC QD RCO
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLK,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+ PINDLY:
+  QA QB QC QD = {
+   CASE(
+     EDGE & TRN_LH, DELAY(4NS,-1,22NS),
+     EDGE & TRN_HL, DELAY(6NS,-1,28NS),
+     DELAY(7NS,-1,29NS))}
+  RCO = {
+   CASE(
+     EDGE & TRN_LH, DELAY(8NS,-1,23NS),
+     EDGE & TRN_HL, DELAY(7NS,-1,20NS),
+     TRICKLE & TRN_LH, DELAY(5NS,-1,20NS),
+     TRICKLE & TRN_HL, DELAY(4NS,-1,16NS),
+     DELAY(9NS,-1,24NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLK CLRBAR A B C D ENT ENP
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 15NS
+  MIN_LO = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = A B C D
+  SETUPTIME = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(2) = ENT ENP
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 15NS
+  SETUPTIME_LO = 25NS

.ENDS 74ALS162

* ----------------------------------------------------------- 74ALS162B ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/24/94
*
.SUBCKT 74ALS162B A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS162B LOGICEXP (14, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_ALS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(3ns,-1,13ns),
+                   ENABLET & TRN_LH, DELAY(3ns,-1,13ns),
+                   CLOCK & TRN_LH, DELAY(5ns,-1,20ns),
+                   CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                   DELAY(6ns,-1,24ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(4ns,-1,15ns),
+                       CLOCK & TRN_HL, DELAY(6ns,-1,20ns),
+                       DELAY(9ns,-1,25ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 12.5ns
+         MIN_LO = 12.5ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 15n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 15n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 15NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 10NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 15NS

.ENDS 74ALS162B

* ----------------------------------------------------------- 74AS162 ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/24/94
*
.SUBCKT 74AS162 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS162 LOGICEXP (14, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O QDBAR_O CLRBAR
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_AS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_AS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(1.5ns,-1,9ns),
+                   ENABLET & TRN_LH, DELAY(1ns,-1,8.5ns),
+                   LOADRisHIGH & TRN_LH, DELAY(1ns,-1,8ns),
+                   LOADRisLO & TRN_LH, DELAY(3ns,-1,16.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,-1,12.5ns),
+                   DELAY(4ns,-1,17.5ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(1ns,-1,7ns),
+                       CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                       DELAY(3ns,-1,14ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_AS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 75MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 6.7ns
+         MIN_LO = 6.7ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 8n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 8n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 8NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 8NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 8NS

.ENDS 74AS162
*
*
* ----------------------------------------------------------- 74F162A ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The Philips FAST Logic Data Book, 1986, Pages 2-149 to 2-158
*  jds    3/24/94
*
.SUBCKT 74F162A D0 D1 D2 D3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F162A LOGICEXP (14, 10) DPWR DGND
+        D0 D1 D2 D3 CP CEP CET PEBAR Q0_O Q1_O Q2_O Q3_O Q3BAR_O MRBAR
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~(PEBAR & MRBAR)) }
+      TC_O = { ( CET & Q0_O & Q3_O ) }
+      ia2 = { (~(load & D0 & MRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & D1 & MRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt & Q3BAR_O)) }
+      ic2 = { (~(load & D2 & MRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & D3 & MRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & Q0_O & Q1_O & Q2_O) | (pnt & Q0_O & Q3_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar Q3BAR_O
+    D0_EFF IO_F

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5s,4ns,6.5ns),
+                   ENABLET & TRN_HL, DELAY(2.5ns,5ns,7ns),
+                   CLOCK & TRN_LH, DELAY(4.5ns,8ns,10.5ns),
+                   CLOCK & TRN_HL, DELAY(4.5ns,7.5ns,9.5ns),
+                   DELAY(7ns,9ns,11.5ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(2ns,4.5ns,7ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(4ns,7ns,10ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(2ns,4.5ns,7.5ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(4ns,6ns,8.5ns),
+                       DELAY(7.5ns,10ns,13ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 130MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 4ns
+         MIN_LO = 5ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 5n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME_HI = 11NS
+        SETUPTIME_HI = 7NS
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 5NS
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME_HI = 11NS
+        SETUPTIME_LO = 7NS

.ENDS 74F162A
*
*
* ----------------------------------------------------------- 74HC162 ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-217 to 2-228
*  jds    3/25/94
*
.SUBCKT 74HC162 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC162 LOGICEXP (14, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_HC

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,17ns,39ns),
+                   ENABLET & TRN_LH, DELAY(-1,17ns,39ns),
+                   CLOCK & TRN_LH, DELAY(-1,24ns,43ns),
+                   CLOCK & TRN_HL, DELAY(-1,24ns,43ns),
+                   DELAY(-1,25ns,45ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(-1,25ns,41ns),
+                       CLOCK & TRN_HL, DELAY(-1,25ns,41ns),
+                       DELAY(-1,26ns,42ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+         MIN_LO = 16ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 16n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 30n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 34NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 27NS

.ENDS 74HC162

*------------------------------------------------------------74HCT162----

* Presettable Synchronous BCD Decade Counter; Synchronous Reset
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 335 to 341
* jat 9/5/96

.SUBCKT 74HCT162
+ MRBAR PEBAR CEP CET CP D0 D1 D2 D3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) DPWR DGND
+ PEBAR CET CEP D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO MRBAR
+ DATA0 DATA1 DATA2 DATA3 TCO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CE = {~(CET & CEP)}
+   XNOR0 = {~(Q0BARO ^ ~CE)}
+   XNOR1 = {(CE & Q1O) | (~CE & (Q3BARO & (Q1O ^ Q0O)))}
+   XNOR2 = {(CE & Q2O) | (~CE & ((Q3BARO & Q2O & (Q1BARO | Q0BARO)) | (Q2BARO & Q1O & Q0O)))}
+   XNOR3 = {(CE & Q3O) | (~CE & ((Q3O & Q0BARO) | (Q3BARO & Q2O & Q1O & Q0O)))}
+   DATA0 = {MRBAR & ((~PEBAR & D0) | (PEBAR & XNOR0))}
+   DATA1 = {MRBAR & ((~PEBAR & D1) | (PEBAR & XNOR1))}
+   DATA2 = {MRBAR & ((~PEBAR & D2) | (PEBAR & XNOR2))}
+   DATA3 = {MRBAR & ((~PEBAR & D3) | (PEBAR & XNOR3))}
+   TCO = {CET & Q0O & Q1BARO & Q2BARO & Q3O}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ DATA0 DATA1 DATA2 DATA3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO
+ CP CET
+ Q0 Q1 Q2 Q3 TC
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  TRICKLE = {CHANGED(CET,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     EDGE & (TRN_LH | TRN_HL), DELAY(-1,24NS,43NS),
+     DELAY(-1,25NS,44NS))}
+  TC = {
+   CASE(
+     EDGE & TRN_LH, DELAY(-1,22NS,45NS),
+     EDGE & TRN_HL, DELAY(-1,30NS,51NS),
+     TRICKLE & TRN_LH, DELAY(-1,12NS,24NS),
+     TRICKLE & TRN_HL, DELAY(-1,18NS,35NS),
+     DELAY(-1,31NS,52NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP PEBAR CEP CET MRBAR D0 D1 D2 D3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 29MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 7NS
+  MIN_LO = 7NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(4) = D0 D1 D2 D3
+  SETUPTIME = 9NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CET CEP
+  SETUPTIME = 23NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 16NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = MRBAR
+  SETUPTIME = 12NS

.ENDS 74HCT162

* ----------------------------------------------------------- 74LS162A ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/25/94
*
.SUBCKT 74LS162A A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS162A LOGICEXP (14, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_LS

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,9ns,14ns),
+                   ENABLET & TRN_LH, DELAY(-1,9ns,14ns),
+                   CLOCK & TRN_LH, DELAY(-1,20ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,18ns,35ns),
+                   DELAY(-1,21ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,20ns,28ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,18ns,27ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,18ns,27ns),
+                       DELAY(-1,21ns,29ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 20n
+        HOLDTIME = 3n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(3) = LOADBAR ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME_HI = 25NS
+        SETUPTIME_LO = 20NS


.ENDS 74LS162A
*
*
* ----------------------------------------------------------- 74S162 ------
*  Synchronous 4-Bit Decade Counter w/ Sync Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/25/94
*
.SUBCKT 74S162 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S162 LOGICEXP (14, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR QA_O QB_O QC_O QD_O CLRBAR QDBAR_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_S IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt & QDBAR_O)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | ((pnt & QA_O & QB_O & QC_O) | (pnt & QA_O & QD_O))) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar QDBAR_O
+    D0_EFF IO_S

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,10ns,15ns),
+                   ENABLET & TRN_LH, DELAY(-1,10ns,15ns),
+                   CLOCK & TRN_LH, DELAY(-1,14ns,25ns),
+                   CLOCK & TRN_HL, DELAY(-1,17ns,25ns),
+                   DELAY(-1,18ns,26ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(-1,8ns,15ns),
+                       CLOCK & TRN_HL, DELAY(-1,10ns,15ns),
+                       DELAY(-1,11ns,16ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_S
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 10ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 10n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 4n
+        HOLDTIME = 3n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = ENT ENP
+        SETUPTIME = 12n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME_LO = 14NS
+        SETUPTIME_HI = 12NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME_LO = 14NS
+        SETUPTIME_HI = 12NS

.ENDS 74S162
*
*
* ----------------------------------------------------------- 74163 ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/23/94
*
.SUBCKT 74163 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74163 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR CLRBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (QA_O & QB_O & QC_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_STD

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,11ns,16ns),
+                   ENABLET & TRN_LH, DELAY(-1,11ns,16ns),
+                   CLOCK & TRN_LH, DELAY(-1,23ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                   DELAY(-1,24ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,26ns,38ns),
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,20ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,15ns,23ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,17ns,25ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,19ns,29ns),
+                       DELAY(-1,27ns,39ns)
+                       )
+                     }

Ucnstr CONSTRAINT(8) DPWR DGND
+          CLRBAR LOADBAR CLK ENP A B C D
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(5) = A B C D ENP
+        SETUPTIME = 20n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS

.ENDS 74163

*------------------------------------------------------------74163A-------

* Synchronous 4-Bit Counters
* National LS/S/TTL Logic Data Handbook, 1989, pgaes 4-159 to 4-166
* jat 8/7/96

.SUBCKT 74163A DATAA DATAB DATAC DATAD CLRBAR CLOCK ENABP ENABT LDBAR
+ QA QB QC QD RCO
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(17,10) DPWR DGND
+ CLOCK DATAA DATAB DATAC DATAD CLRBAR LDBAR ENABP ENABT QA QB QC QD
+ QABAR QBBAR QCBAR QDBAR
+ CLOCKBAR JA JB JC JD KA KB KC KD RCOO
+ D0_GATE IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+  CLOCKBAR = {~CLOCK}
+  ENAB = {(CLRBAR & LDBAR) & ENABP & ENABT}
+  LOADENAB = {~(CLRBAR & LDBAR)}
+  JA = {(DATAA & CLRBAR & LOADENAB) | (ENAB & QABAR)}
+  KA = {(QA & ENAB) | (LOADENAB & ~JA)}
+  JB = {(DATAB & CLRBAR & LOADENAB) | (ENAB & QA & QBBAR)}
+  KB = {(QB & QA & ENAB) | (LOADENAB & ~JB)}
+  JC = {(DATAC & CLRBAR & LOADENAB) | (ENAB & QA & QB & QCBAR)}
+  KC = {(QC & QB & QA & ENAB) | (LOADENAB & ~JC)}
+  JD = {(DATAD & CLRBAR & LOADENAB) | (ENAB & QA & QB & QC & QDBAR)}
+  KD = {(QD & QC & QB & QA & ENAB) | (LOADENAB & ~JD)}
+  RCOO = {~(ENABT & QABAR & QBBAR & QCBAR & QDBAR)}

U2 JKFF(4) DPWR DGND
+ $D_HI $D_HI CLOCKBAR
+ JA JB JC JD KA KB KC KD
+ QAO QBO QCO QDO QABAR QBBAR QCBAR QDBAR
+ D0_EFF IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,4) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ CLOCK CLRBAR ENABT LDBAR
+ QA QB QC QD RCO
+ IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CLOCK,0)}
+   TT = {CHANGED(ENABT,0)}
+ PINDLY:
+   QA QB QC QD = {
+      CASE(
+         EDGE & (CLRBAR == '0) & TRN_HL, DELAY(-1,-1,36NS),
+         EDGE & (LDBAR == '0) & TRN_LH, DELAY(-1,-1,21NS),
+         EDGE & (LDBAR == '0) & TRN_HL, DELAY(-1,-1,32NS),
+         EDGE & (LDBAR == '1) & TRN_LH, DELAY(-1,-1,20NS),
+         EDGE & (LDBAR == '1) & TRN_HL, DELAY(-1,-1,32NS),
+         DELAY(-1,-1,33NS))}
+   RCO = {
+      CASE(
+         TT & (TRN_LH | TRN_HL), DELAY(-1,-1,16NS),
+         EDGE & TRN_LH, DELAY(-1,-1,27NS),
+         EDGE & TRN_HL, DELAY(-1,-1,24NS),
+         DELAY(-1,-1,28NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLOCK CLRBAR DATA DATAB DATAC DATAD ENABP LDBAR
+ IO_STD IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 25MEG
+ WIDTH:
+  NODE = CLOCK
+  MIN_LO = 25NS
+  MIN_HI = 25NS
+ WIDTH:
+  NODE = CLRBAR
+  MIN_LO = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(4) = DATA DATAB DATAC DATAD
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = ENABP
+  SETUPTIME = 34NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LDBAR
+  SETUPTIME = 25NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 20NS

.ENDS 74163A

* ----------------------------------------------------------- 74AC163 ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989, National Semiconductor
*  jds    3/24/94                                                               Pages 4-83 to 4-90
*
.SUBCKT 74AC163 P0 P1 P2 P3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AC163 LOGICEXP (13, 10) DPWR DGND
+        P0 P1 P2 P3 CP CEP CET PEBAR Q0_O Q1_O Q2_O Q3_O MRBAR
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_AC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~(PEBAR & MRBAR)) }
+      TC_O = { ( CET & Q0_O & Q1_O & Q2_O & Q3_O ) }
+      ia2 = { (~(load & P0 & MRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & P1 & MRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt)) }
+      ic2 = { (~(load & P2 & MRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & P3 & MRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (Q0_O & Q1_O & Q2_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar qdbar
+    D0_EFF IO_AC

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_AC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5ns,5.5ns,6.5ns),
+                   ENABLET & TRN_HL, DELAY(2ns,6ns,8.5ns),
+                   CLOCK & TRN_LH, DELAY(2ns,7ns,10.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,8ns,11ns),
+                   DELAY(3ns,9ns,12ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(1.5ns,5.5ns,9ns),
+                       CLOCK & TRN_HL, DELAY(1.5ns,6ns,9.5ns),
+                       DELAY(2.5ns,7ns,10.5ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET P0 P1 P2 P3
+          IO_AC
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 140MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 2ns
+         MIN_LO = 2ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 2.5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 4ns
+        HOLDTIME = 5ns
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME = 2.5NS
+        HOLDTIME = 3NS
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+         HOLDTIME = 5.5NS
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        HOLDTIME = 5NS

.ENDS 74AC163
*
*
* ----------------------------------------------------------- 74ACT163 ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  FACT Advanced CMOS Logic Data Book, 1989,  National Semiconductor
*  jds    3/24/94                                                               Pages 4-83 to 4-90
*
.SUBCKT 74ACT163 P0 P1 P2 P3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ACT163 LOGICEXP (13, 10) DPWR DGND
+        P0 P1 P2 P3 CP CEP CET PEBAR MRBAR Q0_O Q1_O Q2_O Q3_O 
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_ACT IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~(PEBAR & MRBAR)) }
+      TC_O = { ( CET & Q0_O & Q1_O & Q2_O & Q3_O ) }
+      ia2 = { (~(load & P0 & MRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & P1 & MRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt)) }
+      ic2 = { (~(load & P2 & MRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & P3 & MRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (Q0_O & Q1_O & Q2_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar Q3BAR_O
+    D0_EFF IO_ACT

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_ACT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(2ns,5.5ns,9ns),
+                   ENABLET & TRN_HL, DELAY(2ns,6ns,10ns),
+                   CLOCK & TRN_LH, DELAY(2.5ns,7ns,11ns),
+                   CLOCK & TRN_HL, DELAY(3ns,8ns,13.5ns),
+                   DELAY(3.5ns,9ns,14.5ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(1.5ns,5.5ns,10ns),
+                       CLOCK & TRN_HL, DELAY(1.5ns,6ns,11ns),
+                       DELAY(2.5ns,7ns,12ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET P0 P1 P2 P3
+          IO_ACT
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 140MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 2ns
+         MIN_LO = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = P0 P1 P2 P3
+        SETUPTIME = 4ns
+         HOLDTIME = 5ns
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME = 2.5ns
+        HOLDTIME = 3ns
+      SETUP_HOLD:
+        DATA(2) = PEBAR MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 4NS
+        HOLDTIME = 5.5NS

.ENDS 74ACT163

*------------------------------------------------------------74ALS163----

* 4-Bit Binary Counter with Synchrnous Reset
* Motorola Schottky TTL Logic Databook, 1983, pages 5-42 to 5-50
* jat 8/20/96

.SUBCKT 74ALS163
+ CLRBAR LOADBAR ENT ENP CLK A B C D QA QB QC QD RCO
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,5) DPWR DGND
+ LOADBAR ENT ENP A B C D QAO QBO QCO QDO CLRBAR
+ DA DB DC DD RCOO
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   MODE = {LOADBAR & ENT & ENP & CLRBAR}
+   X1 = {~LOADBAR & CLRBAR}
+   X2 = {LOADBAR & CLRBAR}
+   XORA = {(X2 & QAO) ^ MODE}
+   DA = {XORA | (X1 & A)}
+   XORB = {(X2 & QBO) ^ (MODE & QAO)}
+   DB = {XORB | (X1 & B)}
+   XORC = {(X2 & QCO) ^ (MODE & QAO & QBO)}
+   DC = {XORC | (X1 & C)}
+   XORD = {(X2 & QDO) ^ (MODE & QAO & QBO & QCO)}
+   DD = {XORD | (X1 & D)}
+   RCOO = {ENT & QAO & QBO & QCO & QDO}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CLK
+ DA DB DC DD QAO QBO QCO QDO QABARO QBBARO QCBARO QDBARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ QAO QBO QCO QDO RCOO
+ ENT CLK
+ QA QB QC QD RCO
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLK,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+ PINDLY:
+  QA QB QC QD = {
+   CASE(
+     EDGE & TRN_LH, DELAY(4NS,-1,22NS),
+     EDGE & TRN_HL, DELAY(6NS,-1,28NS),
+     DELAY(7NS,-1,29NS))}
+  RCO = {
+   CASE(
+     EDGE & TRN_LH, DELAY(8NS,-1,28NS),
+     EDGE & TRN_HL, DELAY(7NS,-1,20NS),
+     TRICKLE & TRN_LH, DELAY(5NS,-1,20NS),
+     TRICKLE & TRN_HL, DELAY(4NS,-1,16NS),
+     DELAY(9NS,-1,29NS))}

U4 CONSTRAINT(8) DPWR DGND
+ CLK CLRBAR A B C D ENT ENP
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLK
+  MIN_HI = 15NS
+  MIN_LO = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(4) = A B C D
+  SETUPTIME = 15NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(2) = ENT ENP
+  SETUPTIME = 20NS
+ SETUP_HOLD:
+  CLOCK LH = CLK
+  DATA(1) = CLRBAR
+  SETUPTIME_HI = 15NS
+  HOLDTIME_HI = 20NS

.ENDS 74ALS163

* ----------------------------------------------------------- 74ALS163A ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/25/94
*
.SUBCKT 74ALS163B  A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS163A LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR CLRBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (QA_O & QB_O & QC_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_ALS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(3ns,-1,13ns),
+                   ENABLET & TRN_LH, DELAY(3ns,-1,13ns),
+                   CLOCK & TRN_LH, DELAY(5ns,-1,20ns),
+                   CLOCK & TRN_HL, DELAY(5ns,-1,20ns),
+                   DELAY(6ns,-1,21ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(4ns,-1,15ns),
+                       CLOCK & TRN_HL, DELAY(6ns,-1,20ns),
+                       DELAY(7ns,-1,21ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_ALS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 12.5ns
+         MIN_LO = 12.5ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 15n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 15n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 15NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 10NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 15NS

.ENDS 74ALS163B
*
*
* ----------------------------------------------------------- 74AS163 ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The ALS/AS Logic Data Book, 1986, TI Pages 2-149 to 2-158
*  jds    3/24/94
*
.SUBCKT 74AS163 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74AS163 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR CLRBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_AS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (QA_O & QB_O & QC_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_AS00

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_AS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(1.5ns,-1,9ns),
+                   ENABLET & TRN_LH, DELAY(1ns,-1,8.5ns),
+                   LOADRisHIGH & TRN_LH, DELAY(1ns,-1,8ns),
+                   LOADRisLO & TRN_LH, DELAY(3ns,-1,16.5ns),
+                   CLOCK & TRN_HL, DELAY(2ns,-1,12.5ns),
+                   DELAY(4ns,-1,17.5ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(1ns,-1,7ns),
+                       CLOCK & TRN_HL, DELAY(2ns,-1,13ns),
+                       DELAY(3ns,-1,14ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_AS00
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 75MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 6.7ns
+         MIN_LO = 6.7ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 8n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 8n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 8NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 8NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 8NS

.ENDS 74AS163
*
*
* ----------------------------------------------------------- 74F163A ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The Philips FAST Logic Data Book, 1986, Pages 2-149 to 2-158
*  jds    3/25/94
*
.SUBCKT 74F163A D0 D1 D2 D3 MRBAR CP CEP CET TC PEBAR Q0 Q1 Q2 Q3
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F163A LOGICEXP (13, 10) DPWR DGND
+        D0 D1 D2 D3 CP CEP CET PEBAR MRBAR Q0_O Q1_O Q2_O Q3_O 
+        TC_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CP) }
+      pnt = { ( CEP & CET) }
+      load = { (~(PEBAR & MRBAR)) }
+      TC_O = { ( CET & Q0_O & Q1_O & Q2_O & Q3_O ) }
+      ia2 = { (~(load & D0 & MRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & D1 & MRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (Q0_O & pnt)) }
+      ic2 = { (~(load & D2 & MRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & Q0_O & Q1_O)) }
+      id2 = { (~(load & D3 & MRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (Q0_O & Q1_O & Q2_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    Q0_O Q1_O Q2_O Q3_O qabar qbbar qcbar qdbar
+    D0_EFF IO_F

Udly PINDLY (5,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O TC_O
+    MRBAR CP CET PEBAR
+    Q0 Q1 Q2 Q3 TC
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+       ENABLET = { CHANGED(CET,0) }
+       LOADRisHIGH = { (PEBAR == '1)}
+       LOADRisLO = { (PEBAR == '0)}
+
+    PINDLY:
+       TC = {
+              CASE(
+                   ENABLET & TRN_LH, DELAY(1.5ns,3.5ns,6.5ns),
+                   ENABLET & TRN_HL, DELAY(2.5ns,5ns,7.5ns),
+                   CLOCK & TRN_LH, DELAY(5ns,7.5ns,10.5ns),
+                   CLOCK & TRN_HL, DELAY(4.5ns,7.5ns,10.5ns),
+                   DELAY(6ns,9.5ns,11.5ns)
+                   )
+             }
+       Q0 Q1 Q2 Q3 = {
+                   CASE(
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(2ns,4ns,6.5ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(4ns,6.5ns,10ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(2ns,4.5ns,6ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(3.5ns,5.5ns,8.5ns),
+                       DELAY(7ns,9.5ns,13ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          MRBAR PEBAR CP CEP CET D0 D1 D2 D3
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 130MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 4ns
+         MIN_LO = 6ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 4.5n
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(4) = D0 D1 D2 D3
+        SETUPTIME = 5n
+        WHEN = { (MRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = CEP CET
+        CLOCK LH = CP
+        SETUPTIME_HI = 10.5ns
+        SETUPTIME_HI = 6ns 
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 6ns
+      SETUP_HOLD:
+        DATA(1) = PEBAR
+        CLOCK LH = CP
+        SETUPTIME_HI = 9ns
+        SETUPTIME_LO = 6.5ns

.ENDS 74F163A
*
*
* ----------------------------------------------------------- 74HC163------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-217 to 2-228
*  jds    3/25/94
*
.SUBCKT 74HC163  A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC163  LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR CLRBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (QA_O & QB_O & QC_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }

uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_HC

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,17ns,39ns),
+                   ENABLET & TRN_LH, DELAY(-1,17ns,39ns),
+                   CLOCK & TRN_LH, DELAY(-1,24ns,43ns),
+                   CLOCK & TRN_HL, DELAY(-1,24ns,43ns),
+                   DELAY(-1,25ns,45ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(-1,25ns,41ns),
+                       CLOCK & TRN_HL, DELAY(-1,25ns,41ns),
+                       DELAY(-1,26ns,43ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+         MIN_LO = 16ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 16n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 30n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(2) = ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 34NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME = 27NS

.ENDS 74HC163

*------------------------------------------------------------74HC163A----

* Presettable Counter
* Motorola High-Speed CMOS Logic Data, 1993, pages 5-171 to 5-181
* jat 9/5/96

.SUBCKT 74HC163A
+ RESET LOAD ENP ENT CLOCK P0 P1 P2 P3 Q0 Q1 Q2 Q3 RCO
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) DPWR DGND
+ LOAD ENT ENP P0 P1 P2 P3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO RESET
+ DATA0 DATA1 DATA2 DATA3 RCOO
+ D0_GATE IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CE = {~(ENT & ENP)}
+   XNOR0 = {~(Q0BARO ^ ~CE)}
+   XNOR1 = {~(Q1BARO ^ (~(CE | Q0BARO)))}
+   XNOR2 = {~(Q2BARO ^ (~(CE | Q1BARO | Q0BARO)))}
+   NOR3 = {~(CE | Q2BARO | Q1BARO | Q0BARO)}
+   OR3 = {(NOR3 & Q3BARO) | (~(NOR3 | Q3BARO))}
+   DATA0 = {RESET & ((~LOAD & P0) | (LOAD & XNOR0))}
+   DATA1 = {RESET & ((~LOAD & P1) | (LOAD & XNOR1))}
+   DATA2 = {RESET & ((~LOAD & P2) | (LOAD & XNOR2))}
+   DATA3 = {RESET & ((~LOAD & P3) | (LOAD & OR3))}
+   RCOO = {ENT & Q0O & Q1O & Q2O & Q3O}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CLOCK
+ DATA0 DATA1 DATA2 DATA3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_EFF IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O RCOO
+ CLOCK ENT
+ Q0 Q1 Q2 Q3 RCO
+ IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CLOCK,0)}
+  TRICKLE = {CHANGED(ENT,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     EDGE & TRN_LH, DELAY(-1,-1,20NS),
+     EDGE & TRN_HL, DELAY(-1,-1,22NS),
+     DELAY(-1,-1,23NS))}
+  RCO = {
+   CASE(
+     EDGE & TRN_LH, DELAY(-1,-1,22NS),
+     EDGE & TRN_HL, DELAY(-1,-1,22NS),
+     TRICKLE & TRN_LH, DELAY(-1,-1,16NS),
+     TRICKLE & TRN_HL, DELAY(-1,-1,18NS),
+     DELAY(-1,-1,23NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CLOCK RESET P0 P1 P2 P3 LOAD ENT ENP
+ IO_HC IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLOCK
+  MAXFREQ = 30MEG
+ WIDTH:
+  NODE = CLOCK
+  MIN_HI = 12NS
+  MIN_LO = 12NS
+ WIDTH:
+  NODE = RESET
+  MIN_LO = 12NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(4) = P0 P1 P2 P3
+  SETUPTIME = 15NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(2) = ENT ENP
+  SETUPTIME = 20NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LOAD
+  SETUPTIME = 15NS
+  HOLDTIME = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = RESET
+  SETUPTIME_LO = 20NS
+  HOLDTIME_LO = 3NS
+ SETUP_HOLD:
+  CLOCK LH = CLOCK
+  DATA(1) = LOAD
+  SETUPTIME_HI = 15NS

.ENDS 74HC163A

*------------------------------------------------------------74HCT163----

* Presettable Synchronous 4 Bit Binary Counter; Synchronous Reset
* Philips High-Speed CMOS Logic Family Data Handbook, 1994, pages 343 to 349
* jat 9/5/96

.SUBCKT 74HCT163
+ MRBAR PEBAR CEP CET CP D0 D1 D2 D3 Q0 Q1 Q2 Q3 TC
+ OPTIONAL:  DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS:  MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(16,5) DPWR DGND
+ PEBAR CET CEP D0 D1 D2 D3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO MRBAR
+ DATA0 DATA1 DATA2 DATA3 TCO
+ D0_GATE IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CE = {~(CET & CEP)}
+   XNOR0 = {~(Q0BARO ^ ~CE)}
+   XNOR1 = {~(Q1BARO ^ (~(CE | Q0BARO)))}
+   XNOR2 = {~(Q2BARO ^ (~(CE | Q1BARO | Q0BARO)))}
+   NOR3 = {~(CE | Q2BARO | Q1BARO | Q0BARO)}
+   OR3 = {(NOR3 & Q3BARO) | (~(NOR3 | Q3BARO))}
+   DATA0 = {MRBAR & ((~PEBAR & D0) | (PEBAR & XNOR0))}
+   DATA1 = {MRBAR & ((~PEBAR & D1) | (PEBAR & XNOR1))}
+   DATA2 = {MRBAR & ((~PEBAR & D2) | (PEBAR & XNOR2))}
+   DATA3 = {MRBAR & ((~PEBAR & D3) | (PEBAR & OR3))}
+   TCO = {CET & Q0O & Q1O & Q2O & Q3O}

U2 DFF(4) DPWR DGND
+ $D_HI $D_HI CP
+ DATA0 DATA1 DATA2 DATA3 Q0O Q1O Q2O Q3O Q0BARO Q1BARO Q2BARO Q3BARO
+ D0_EFF IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(5,0,2) DPWR DGND
+ Q0O Q1O Q2O Q3O TCO
+ CP CET
+ Q0 Q1 Q2 Q3 TC
+ IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+  EDGE = {CHANGED_LH(CP,0)}
+  TRICKLE = {CHANGED(CET,0)}
+ PINDLY:
+  Q0 Q1 Q2 Q3 = {
+   CASE(
+     EDGE & (TRN_LH | TRN_HL), DELAY(-1,23NS,39NS),
+     DELAY(-1,24NS,40NS))}
+  TC = {
+   CASE(
+     EDGE & TRN_LH, DELAY(-1,29NS,49NS),
+     EDGE & TRN_HL, DELAY(-1,29NS,49NS),
+     TRICKLE & TRN_LH, DELAY(-1,17NS,32NS),
+     TRICKLE & TRN_HL, DELAY(-1,17NS,32NS),
+     DELAY(-1,30NS,50NS))}

U4 CONSTRAINT(9) DPWR DGND
+ CP PEBAR CEP CET MRBAR D0 D1 D2 D3
+ IO_HCT IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CP
+  MAXFREQ = 45MEG
+ WIDTH:
+  NODE = CP
+  MIN_HI = 6NS
+  MIN_LO = 6NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(5) = D0 D1 D2 D3 MRBAR
+  SETUPTIME = 9NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(2) = CET CEP
+  SETUPTIME = 24NS
+ SETUP_HOLD:
+  CLOCK LH = CP
+  DATA(1) = PEBAR
+  SETUPTIME = 11NS

.ENDS 74HCT163

* ----------------------------------------------------------- 74LS163A ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/24/94
*
.SUBCKT 74LS163A A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS163A LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR CLRBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (QA_O & QB_O & QC_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_LS

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,9ns,14ns),
+                   ENABLET & TRN_LH, DELAY(-1,9ns,14ns),
+                   CLOCK & TRN_LH, DELAY(-1,20ns,35ns),
+                   CLOCK & TRN_HL, DELAY(-1,18ns,35ns),
+                   DELAY(-1,21ns,36ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & LOADRisHIGH & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisHIGH & TRN_HL, DELAY(-1,18ns,27ns),
+                       CLOCK & LOADRisLO & TRN_LH, DELAY(-1,13ns,24ns),
+                       CLOCK & LOADRisLO & TRN_HL, DELAY(-1,18ns,27ns),
+                       DELAY(-1,21ns,29ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 20n
+        HOLDTIME = 3n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(3) = LOADBAR ENP ENT
+        CLOCK LH = CLK
+        SETUPTIME = 20NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 25NS


.ENDS 74LS163A
*
*
* ----------------------------------------------------------- 74S163 ------
*  Synchronous 4-Bit Binary Counter w/ Sync Clear
*
*  The TTL Logic Data Book, 1988, TI Pages 2-493 to 2-513
*  jds    3/25/94
*
.SUBCKT 74S163 A B C D CLRBAR CLK ENP ENT RCO LOADBAR QA QB QC QD
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74S163 LOGICEXP (13, 10) DPWR DGND
+        A B C D CLK ENP ENT LOADBAR CLRBAR QA_O QB_O QC_O QD_O
+        RCO_O ja jb jc jd ka kb kc kd clkbar
+        D0_GATE IO_S IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clkbar = { (~CLK) }
+      pnt = { ( ENP & ENT) }
+      load = { (~(LOADBAR & CLRBAR)) }
+      RCO_O = { ( ENT & QA_O & QB_O & QC_O & QD_O ) }
+      ia2 = { (~(load & A & CLRBAR)) }
+      ia1 = { (~(load & ia2)) }
+      ia3 = { (pnt | load) }
+      ib2 = { (~(load & B & CLRBAR)) }
+      ib1 = { (~(ib2 & load)) }
+      ib3 = { (load | (QA_O & pnt)) }
+      ic2 = { (~(load & C & CLRBAR)) }
+      ic1 = { (~(ic2 & load)) }
+      ic3 = { (load | (pnt & QA_O & QB_O)) }
+      id2 = { (~(load & D & CLRBAR)) }
+      id1 = { (~(load & id2)) }
+      id3 = { ( load | (QA_O & QB_O & QC_O & pnt) ) }
+      ja  = { (ia1 & ia3) }
+      jb  = { (ib1 & ib3) }
+      jc  = { (ic1 & ic3) }
+      jd  = { (id1 & id3) }
+      ka  = { (ia2 & ia3) }
+      kb  = { (ib2 & ib3) }
+      kc  = { (ic2 & ic3) }
+      kd  = { (id2 & id3) }


uf0  JKff(4)  DPWR DGND
+    $D_HI $D_HI clkbar
+    ja jb jc jd ka kb kc kd
+    QA_O QB_O QC_O QD_O qabar qbbar qcbar qdbar
+    D0_EFF IO_S

Udly PINDLY (5,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O RCO_O
+    CLRBAR CLK ENT LOADBAR
+    QA QB QC QD RCO
+    IO_S MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+       ENABLET = { CHANGED(ENT,0) }
+       LOADRisHIGH = { (LOADBAR == '1)}
+       LOADRisLO = { (LOADBAR == '0)}
+
+    PINDLY:
+       RCO = {
+              CASE(
+                   ENABLET & TRN_HL, DELAY(-1,10ns,15ns),
+                   ENABLET & TRN_LH, DELAY(-1,10ns,15ns),
+                   CLOCK & TRN_LH, DELAY(-1,14ns,25ns),
+                   CLOCK & TRN_HL, DELAY(-1,17ns,25ns),
+                   DELAY(-1,18ns,26ns)
+                   )
+             }
+       QA QB QC QD = {
+                   CASE(
+                       CLOCK & TRN_LH, DELAY(-1,8ns,15ns),
+                       CLOCK & TRN_HL, DELAY(-1,10ns,15ns),
+                       DELAY(-1,11ns,16ns)
+                       )
+                     }

Ucnstr CONSTRAINT(9) DPWR DGND
+          CLRBAR LOADBAR CLK ENP ENT A B C D
+          IO_S
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 40MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 10ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 10n
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(4) = A B C D
+        SETUPTIME = 4n
+        HOLDTIME = 3n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = ENT ENP
+        SETUPTIME = 12n
+        WHEN = { (CLRBAR != '0) }
+      SETUP_HOLD:
+        DATA(1) = LOADBAR
+        CLOCK LH = CLK
+        SETUPTIME_LO = 14NS
+        SETUPTIME_HI = 12NS
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME_LO = 14NS
+        SETUPTIME_HI = 12NS

.ENDS 74S163
*
*
* ----------------------------------------------------------- 74164 ------
*  8-Bit Parallel-Out Serial Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-515 to 2-520
*  jds    3/28/94
*
.SUBCKT 74164 A B CLRBAR CLK QA QB QC QD QE QF QG QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74164 LOGICEXP (3,3) DPWR DGND
+        CLK A B
+        r0 s0 clkbar
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      r0 = { (~(A & B)) }
+      s0 = { (~r0) }
+      clkbar = { (~CLK) }


uf0  JKff(8)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    s0 QA_O QB_O QC_O QD_O QE_O QF_O QG_O
+    r0 qabar qbbar qcbar qdbar qebar qfbar qgbar
+    QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_STD

Udly PINDLY (8,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+    CLRBAR CLK A B
+    QA QB QC QD QE QF QG QH
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(A,0) | CHANGED(B,0) ) }
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD QE QF QG QH  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,24ns,36ns),
+                       CLOCK & TRN_LH, DELAY(8ns,17ns,27ns),
+                       CLOCK & TRN_HL, DELAY(10ns,21ns,32ns),
+                       DELAY(-1,25ns,37ns)
+                       )
+                     }

Ucnstr CONSTRAINT(4) DPWR DGND
+          CLRBAR CLK  A B
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = A B
+        SETUPTIME = 15ns
+        HOLDTIME = 5ns
+        WHEN = { CLRBAR != '0 }
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 20ns

.ENDS 74164
*
*
*------------------------------------------------------------74AC164----
*
* The 74AC164 8-Bit Serial-In/Parallel Out Shift Register
* (6 Page Fax) Harris Advanced CMOS Logic, File Number 1954
* jat 7/27/95

.SUBCKT 74AC164
+ DS1 DS2 Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 MRBAR CP
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_GND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 AND(2) DPWR DGND
+ DS1 DS2
+ D
+ D0_GATE IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(8) DPWR DGND
+ $D_HI MRBAR CP
+ D Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,0,2) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7
+ CP MRBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_AC
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CP,0)}
+          RESET = {CHANGED(MRBAR,0)}
+ PINDLY:
+         Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 = {
+           CASE(
+             RESET & TRN_HL, DELAY(3.6NS,-1,12.6NS),
+             EDGE & (TRN_LH | TRN_HL), DELAY(3.2NS,-1,11.4NS),
+             DELAY(4.6NS,-1,13.6NS))}

U4 CONSTRAINT(4) DPWR DGND
+ CP DS1 DS2 MRBAR
+ IO_AC IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(2) = DS1 DS2
+             SETUPTIME = 2.2NS
+             HOLDTIME = 2.2NS
+ WIDTH:
+             NODE = CP
+             MIN_LO = 5.9NS
+             MIN_HI = 5.9NS
+ WIDTH:
+             NODE = MRBAR
+             MIN_LO = 3.9NS
+             MIN_HI = 3.9NS
+ FREQ:
+             NODE = CP
+             MAXFREQ = 86MEG

.ENDS 74AC164
*
*
*------------------------------------------------------------74ACT164----
*
* The 74ACT164 8-Bit Serial-In/Parallel Out Shift Register
* National Semiconductor FACT Advanced CMOS Logic Databook, 1993,
* pages 4-112 to 4-115
* jat 7/27/95

.SUBCKT 74ACT164
+ A B Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 MRBAR CP
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_GND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 AND(2) DPWR DGND
+ A B
+ D
+ D0_GATE IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(8) DPWR DGND
+ $D_HI MRBAR CP
+ D Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,0,2) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7
+ CP MRBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_ACT
+ MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CP,0)}
+          RESET = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+         Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 = {
+           CASE(
+             RESET & TRN_HL, DELAY(1NS,6NS,13NS),
+             EDGE & (TRN_LH | TRN_HL), DELAY(1NS,6NS,11.5NS),
+             DELAY(2NS,7NS,14NS))}

U4 CONSTRAINT(4) DPWR DGND
+ CP A B MRBAR
+ IO_ACT IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(2) = A B
+             SETUPTIME = 8NS
+             HOLDTIME = 1.5NS
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(1) = MRBAR
+             SETUPTIME_HI = 2NS
+             SETUPTIME_LO = 8NS
+ FREQ:
+             NODE = CP
+             MAXFREQ = 80MEG

.ENDS 74ACT164
*
*
*-------------------------------------------------------------74ALS164----

* 8-Bit Parallel-Out Serial Shift Register
* TI ALS/AS Logic Data Book, 1986, pages 2-159 to 2-161
* jat 12/29/95

.SUBCKT 74ALS164 CLRBAR CLK A B QA QB QC QD QE QF QG QH
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(3,3) DPWR DGND
+ A B CLK
+ J K CLKBAR
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   J = {A & B}
+   K = {~J}
+   CLKBAR = {~CLK}

U2 JKFF(8) DPWR DGND
+ $D_HI CLRBAR CLKBAR
+ J QAO QBO QCO QDO QEO QFO QGO
+ K QABARO QBBARO QCBARO QDBARO QEBARO QFBARO QGBARO
+ QAO QBO QCO QDO QEO QFO QGO QHO
+ QABARO QBBARO QCBARO QDBARO QEBARO QFBARO QGBARO QHBARO
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,0,2) DPWR DGND
+ QAO QBO QCO QDO QEO QFO QGO QHO
+ CLK CLRBAR
+ QA QB QC QD QE QF QG QH
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+   QA QB QC QD QE QF QG QH = {
+    CASE(
+      CLEAR & TRN_HL, DELAY(-1,12NS,-1),
+      EDGE & TRN_LH, DELAY(-1,10NS,-1),
+      EDGE & TRN_HL, DELAY(-1,11NS,-1),
+      DELAY(-1,13NS,-1))}

U4 CONSTRAINT(1) DPWR DGND
+ CLK
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+  NODE = CLK
+  MAXFREQ = 60MEG

.ENDS 74ALS164

* ----------------------------------------------------------- 74F164 ------
*  8-Bit Parallel-Out Serial Shift Register
*
*  The Fast TTL Logic Series, 1992, Philips, pages 210- 214
*  jds    3/28/94
*
.SUBCKT 74F164 DSA DSB MRBAR CP Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F164 LOGICEXP (3,3) DPWR DGND
+        CP DSA DSB
+        r0 s0 clkbar
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      r0 = { (~(DSA & DSB)) }
+      s0 = { (~r0) }
+      clkbar = { (~CP) }


uf0  JKff(8)  DPWR DGND
+    $D_HI MRBAR clkbar
+    s0 Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O
+    r0 Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar Q6bar
+    Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+    Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar Q6bar Q7bar
+    D0_EFF IO_F

Udly PINDLY (8,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+    MRBAR CP DSA DSB
+    Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(DSA,0) | CHANGED(DSB,0) ) }
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+
+    PINDLY:
+       Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(5.5ns,7.5ns,10.5ns),
+                       CLOCK & TRN_LH, DELAY(3ns,5ns,8ns),
+                       CLOCK & TRN_HL, DELAY(5ns,7ns,10ns),
+                       DELAY(6ns,8.5ns,11.5ns)
+                       )
+                     }

Ucnstr CONSTRAINT(4) DPWR DGND
+          MRBAR CP  DSA DSB
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 100MEG
+      WIDTH:
+         NODE = CP
+         MIN_LO = 7ns
+         MIN_HI = 4ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 7ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = DSA DSB
+        SETUPTIME = 7ns
+        HOLDTIME = 1ns
+        WHEN = { MRBAR != '0 }
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 7ns

.ENDS 74F164

*------------------------------------------------------------74F164A----
*
* Serial-In,Parallel-Out Shift Register
* National Advanced Bipolar Logic Databook, 1995, pages 7-126 to 7-129
* jat 7/9/96

.SUBCKT 74F164A
+ A B Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 MRBAR CP
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_GND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 AND(2) DPWR DGND
+ A B
+ D
+ D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U2 DFF(8) DPWR DGND
+ $D_HI MRBAR CP
+ D Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7
+ $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC 
+ D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(8,0,2) DPWR DGND
+ Q_0 Q_1 Q_2 Q_3 Q_4 Q_5 Q_6 Q_7
+ CP MRBAR
+ Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+ IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+          EDGE = {CHANGED_LH(CP,0)}
+          RESET = {CHANGED_HL(MRBAR,0)}
+ PINDLY:
+         Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7 = {
+           CASE(
+             RESET & TRN_HL, DELAY(5NS,7NS,10NS),
+             EDGE & TRN_LH, DELAY(3NS,4.8NS,7.5NS),
+             EDGE & TRN_HL, DELAY(3.5NS,5NS,8NS),
+             DELAY(6NS,8NS,11NS))}

U4 CONSTRAINT(4) DPWR DGND
+ CP A B MRBAR
+ IO_F IO_LEVEL={IO_LEVEL}
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(2) = A B
+             SETUPTIME_HI = 4.5NS
+             SETUPTIME_LO = 4NS
+             HOLDTIME = 1NS
+ SETUP_HOLD:
+             CLOCK LH = CP
+             DATA(1) = MRBAR
+             SETUPTIME_HI = 5NS
+ FREQ:
+             NODE = CP
+             MAXFREQ = 120MEG
+ WIDTH:
+   NODE = CP
+   MIN_LO = 7NS
+   MIN_HI = 4NS
+ WIDTH:
+   NODE = MRBAR
+   MIN_LO = 4NS

.ENDS 74F164A
*
*
* ----------------------------------------------------------- 74HCT164 ------
*  8-Bit Parallel-Out Serial Shift Register
*
*  The High Speed CMOS Logic Family, 1994, Philips, pages 351 to 356
*  jds    3/28/94
*
.SUBCKT 74HCT164 DSA DSB MRBAR CP Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HCT164 LOGICEXP (3,3) DPWR DGND
+        CP DSA DSB
+        r0 s0 clkbar
+        D0_GATE IO_HCT IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      r0 = { (~(DSA & DSB)) }
+      s0 = { (~r0) }
+      clkbar = { (~CP) }


uf0  JKff(8)  DPWR DGND
+    $D_HI MRBAR clkbar
+    s0 Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O
+    r0 Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar Q6bar
+    Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+    Q0bar Q1bar Q2bar Q3bar Q4bar Q5bar Q6bar Q7bar
+    D0_EFF IO_HCT

Udly PINDLY (8,0,4) DPWR DGND
+    Q0_O Q1_O Q2_O Q3_O Q4_O Q5_O Q6_O Q7_O
+    MRBAR CP DSA DSB
+    Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(DSA,0) | CHANGED(DSB,0) ) }
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+
+    PINDLY:
+       Q0 Q1 Q2 Q3 Q4 Q5 Q6 Q7  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,19ns,38ns),
+                       CLOCK & TRN_LH, DELAY(-1,17ns,36ns),
+                       CLOCK & TRN_HL, DELAY(-1,17ns,36ns),
+                       DELAY(-1,20ns,39ns)
+                       )
+                     }

Ucnstr CONSTRAINT(4) DPWR DGND
+          MRBAR CP  DSA DSB
+          IO_HCT
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 55MEG
+      WIDTH:
+         NODE = CP
+         MIN_LO = 7ns
+         MIN_HI = 7ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 10ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = DSA DSB
+        SETUPTIME = 6ns
+        HOLDTIME = 2ns
+        WHEN = { MRBAR != '0 }
+      SETUP_HOLD:
+        DATA(1) = MRBAR
+        CLOCK LH = CP
+        SETUPTIME = 7ns

.ENDS 74HCT164
*
*
* ----------------------------------------------------------- 74HC164 ------
*  8-Bit Parallel-Out Serial Shift Register
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-231 to 2-234
*  jds    3/28/94
*
.SUBCKT 74HC164 A B CLRBAR CLK QA QB QC QD QE QF QG QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC164 LOGICEXP (3,3) DPWR DGND
+        CLK A B
+        r0 s0 clkbar
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      r0 = { (~(A & B)) }
+      s0 = { (~r0) }
+      clkbar = { (~CLK) }


uf0  JKff(8)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    s0 QA_O QB_O QC_O QD_O QE_O QF_O QG_O
+    r0 qabar qbbar qcbar qdbar qebar qfbar qgbar
+    QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_HC

Udly PINDLY (8,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+    CLRBAR CLK A B
+    QA QB QC QD QE QF QG QH
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(A,0) | CHANGED(B,0) ) }
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD QE QF QG QH  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,28ns,41ns),
+                       CLOCK & TRN_LH, DELAY(-1,23ns,35ns),
+                       CLOCK & TRN_HL, DELAY(-1,23ns,35ns),
+                       DELAY(-1,29ns,42ns)
+                       )
+                     }

Ucnstr CONSTRAINT(4) DPWR DGND
+          CLRBAR CLK  A B
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_LO = 16ns
+         MIN_HI = 16ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = A B
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+        WHEN = { CLRBAR != '0 }
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 20ns

.ENDS 74HC164
*
*
* ----------------------------------------------------------- 74LS164 ------
*  8-Bit Parallel-Out Serial Shift Registor
*
*  The TTL Logic Data Book, 1988, TI Pages 2-515 to 2-520
*  jds    3/28/94
*
.SUBCKT 74LS164 A B CLRBAR CLK QA QB QC QD QE QF QG QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS164 LOGICEXP (3,3) DPWR DGND
+        CLK A B
+        r0 s0 clkbar
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      r0 = { (~(A & B)) }
+      s0 = { (~r0) }
+      clkbar = { (~CLK) }


uf0  JKff(8)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    s0 QA_O QB_O QC_O QD_O QE_O QF_O QG_O
+    r0 qabar qbbar qcbar qdbar qebar qfbar qgbar
+    QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_LS

Udly PINDLY (8,0,4) DPWR DGND
+    QA_O QB_O QC_O QD_O QE_O QF_O QG_O QH_O
+    CLRBAR CLK A B
+    QA QB QC QD QE QF QG QH
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(A,0) | CHANGED(B,0) ) }
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QA QB QC QD QE QF QG QH  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,24ns,36ns),
+                       CLOCK & TRN_LH, DELAY(-1,17ns,27ns),
+                       CLOCK & TRN_HL, DELAY(-1,21ns,32ns),
+                       DELAY(-1,25ns,37ns)
+                       )
+                     }

Ucnstr CONSTRAINT(4) DPWR DGND
+          CLRBAR CLK  A B
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = A B
+        SETUPTIME = 15ns
+        HOLDTIME = 5ns
+        WHEN = { CLRBAR != '0 }
+      SETUP_HOLD:
+        DATA(1) = CLRBAR
+        CLOCK LH = CLK
+        SETUPTIME = 20ns

.ENDS 74LS164
*
*
* ----------------------------------------------------------- 74165 ------
*  Parallel-Load 8-Bit Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-521 to 2-528
*  jds    4/14/94
*
.SUBCKT 74165 SH/LDBAR CLK_INH CLK SER A B C D E F G H QH QHBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74165 LOGICEXP (11,17) DPWR DGND
+        SH/LDBAR CLK_INH CLK A B C D E F G H
+        r0 s0 r1 s1 r2 s2 r3 s3 r4 s4 r5 s5 r6 s6 r7 s7 clock
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clock = { (CLK_INH | CLK) }
+      shbar/ld = { (~(SH/LDBAR)) }
+      s0 = { (~(shbar/ld & A)) }
+      r0 = { (~(s0 & shbar/ld)) }
+      s1 = { (~(shbar/ld & B)) }
+      r1 = { (~(s1 & shbar/ld)) }
+      s2 = { (~(shbar/ld & C)) }
+      r2 = { (~(s2 & shbar/ld)) }
+      s3 = { (~(shbar/ld & D)) }
+      r3 = { (~(s3 & shbar/ld)) }
+      s4 = { (~(shbar/ld & E)) }
+      r4 = { (~(s4 & shbar/ld)) }
+      s5 = { (~(shbar/ld & F)) }
+      r5 = { (~(s5 & shbar/ld)) }
+      s6 = { (~(shbar/ld & G)) }
+      r6 = { (~(s6 & shbar/ld)) }
+      s7 = { (~(shbar/ld & H)) }
+      r7 = { (~(s7 & shbar/ld)) }     

uf0  Dff(1)  DPWR DGND
+    s0 r0  clock
+    SER  QA qabar 
+    D0_EFF IO_STD

uf1  Dff(1)  DPWR DGND
+    s1 r1 clock
+    QA QB qbbar 
+    D0_EFF IO_STD

uf2  Dff(1)  DPWR DGND
+    s2 r2  clock
+    QB QC qcbar 
+    D0_EFF IO_STD

uf3  Dff(1)  DPWR DGND
+    s3 r3  clock
+    QC QD qdbar 
+    D0_EFF IO_STD

uf4  Dff(1)  DPWR DGND
+    s4 r4  clock
+    QD QE qebar 
+    D0_EFF IO_STD

uf5  Dff(1)  DPWR DGND
+    s5 r5  clock
+    QE QF qfbar 
+    D0_EFF IO_STD

uf6  Dff(1)  DPWR DGND
+    s6 r6  clock
+    QF QG qgbar 
+    D0_EFF IO_STD

uf7  Dff(1)  DPWR DGND
+    s7 r7  clock
+    QG QH_O QHBAR_O 
+    D0_EFF IO_STD

Udly PINDLY (2,0,5) DPWR DGND
+    QH_O QHBAR_O
+    CLK SH/LDBAR H SER CLK_INH
+    QH QHBAR
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { CHANGED(H,0) }
+       CLKS= { (CHANGED(CLK,0) | CHANGED(CLK_INH,0)) }
+       SERIAL= { CHANGED(SER,0) }
+       LOAD= { CHANGED(SH/LDBAR,0) }
+
+    PINDLY:
+       QH  = {
+                   CASE(
+                       LOAD & TRN_LH, DELAY(-1,21ns,31ns),
+                       LOAD & TRN_HL, DELAY(-1,27ns,40ns),
+                       CLKS & TRN_LH, DELAY(-1,16ns,24ns),
+                       CLKS & TRN_HL, DELAY(-1,21ns,31ns),
+                       DATA & TRN_LH, DELAY(-1,11ns,17ns),
+                       DATA & TRN_HL, DELAY(-1,24ns,36ns),
+                       DELAY(-1,28ns,41ns)
+                       )
+                     }
+       QHBAR  = {
+                   CASE(
+                       LOAD & TRN_LH, DELAY(-1,21ns,31ns),
+                       LOAD & TRN_HL, DELAY(-1,27ns,40ns),
+                       CLKS & TRN_LH, DELAY(-1,16ns,24ns),
+                       CLKS & TRN_HL, DELAY(-1,21ns,31ns),
+                       DATA & TRN_LH, DELAY(-1,18ns,27ns),
+                       DATA & TRN_HL, DELAY(-1,18ns,27ns),
+                       DELAY(-1,28ns,41ns)
+                       )
+                     }


Ucnstr CONSTRAINT(12) DPWR DGND
+          CLK SH/LDBAR SER CLK_INH A B C D E F G H
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 20MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = SH/LDBAR
+         MIN_LO = 15ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLK_INH
+        SETUPTIME = 30ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 10ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SH/LDBAR
+        SETUPTIME_HI = 45ns

.ENDS 74165
*
*
* ----------------------------------------------------------- 74ALS165 ------
*  Parallel-Load 8-Bit Shift Register
*
*  The  ALS/AS Logic Data Book, 1986, TI Pages 2-521 to 2-528
*  jds    4/14/94
*
.SUBCKT 74ALS165 SH/LDBAR CLK_INH CLK SER A B C D E F G H QH QHBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74ALS165 LOGICEXP (11,17) DPWR DGND
+        SH/LDBAR CLK_INH CLK A B C D E F G H
+        r0 s0 r1 s1 r2 s2 r3 s3 r4 s4 r5 s5 r6 s6 r7 s7 clock
+        D0_GATE IO_ALS00 IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clock = { (CLK_INH | CLK) }
+      shbar/ld = { (~(SH/LDBAR)) }
+      s0 = { (~(shbar/ld & A)) }
+      r0 = { (~(s0 & shbar/ld)) }
+      s1 = { (~(shbar/ld & B)) }
+      r1 = { (~(s1 & shbar/ld)) }
+      s2 = { (~(shbar/ld & C)) }
+      r2 = { (~(s2 & shbar/ld)) }
+      s3 = { (~(shbar/ld & D)) }
+      r3 = { (~(s3 & shbar/ld)) }
+      s4 = { (~(shbar/ld & E)) }
+      r4 = { (~(s4 & shbar/ld)) }
+      s5 = { (~(shbar/ld & F)) }
+      r5 = { (~(s5 & shbar/ld)) }
+      s6 = { (~(shbar/ld & G)) }
+      r6 = { (~(s6 & shbar/ld)) }
+      s7 = { (~(shbar/ld & H)) }
+      r7 = { (~(s7 & shbar/ld)) }     

uf0  Dff(1)  DPWR DGND
+    s0 r0  clock
+    SER  QA qabar 
+    D0_EFF IO_ALS00

uf1  Dff(1)  DPWR DGND
+    s1 r1 clock
+    QA QB qbbar 
+    D0_EFF IO_ALS00

uf2  Dff(1)  DPWR DGND
+    s2 r2  clock
+    QB QC qcbar 
+    D0_EFF IO_ALS00

uf3  Dff(1)  DPWR DGND
+    s3 r3  clock
+    QC QD qdbar 
+    D0_EFF IO_ALS00

uf4  Dff(1)  DPWR DGND
+    s4 r4  clock
+    QD QE qebar 
+    D0_EFF IO_ALS00

uf5  Dff(1)  DPWR DGND
+    s5 r5  clock
+    QE QF qfbar 
+    D0_EFF IO_ALS00

uf6  Dff(1)  DPWR DGND
+    s6 r6  clock
+    QF QG qgbar 
+    D0_EFF IO_ALS00

uf7  Dff(1)  DPWR DGND
+    s7 r7  clock
+    QG QH_O QHBAR_O 
+    D0_EFF IO_ALS00

Udly PINDLY (2,0,5) DPWR DGND
+    QH_O QHBAR_O
+    CLK SH/LDBAR H SER CLK_INH
+    QH QHBAR
+    IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { CHANGED(H,0) }
+       CLKS= { (CHANGED(CLK,0) | CHANGED(CLK_INH,0)) }
+       SERIAL= { CHANGED(SER,0) }
+       LOAD= { CHANGED(SH/LDBAR,0) }
+
+    PINDLY:
+       QH  = {
+                   CASE(
+                       LOAD & TRN_LH, DELAY(-1,21ns,-1),
+                       LOAD & TRN_HL, DELAY(-1,26ns,-1),
+                       CLKS & TRN_LH, DELAY(-1,14ns,-1),
+                       CLKS & TRN_HL, DELAY(-1,16ns,-1),
+                       DATA & TRN_LH, DELAY(-1,13ns,-1),
+                       DATA & TRN_HL, DELAY(-1,24ns,-1),
+                       DELAY(-1,27ns,-1)
+                       )
+                     }
+       QHBAR  = {
+                   CASE(
+                       LOAD & TRN_LH, DELAY(-1,21ns,-1),
+                       LOAD & TRN_HL, DELAY(-1,26ns,-1),
+                       CLKS & TRN_LH, DELAY(-1,14ns,-1),
+                       CLKS & TRN_HL, DELAY(-1,16ns,-1),
+                       DATA & TRN_LH, DELAY(-1,19ns,-1),
+                       DATA & TRN_HL, DELAY(-1,17ns,-1),
+                       DELAY(-1,27ns,-1)
+                       )
+                     }

.ENDS 74ALS165
*
*
* ----------------------------------------------------------- 74HC165 ------
*  Parallel-Load 8-Bit Shift Register
*
*  High Speed CMOS Logic Data Book, 1989, TI Pages 2-235 to 2-239
*  jds    4/15/94
*
.SUBCKT 74HC165 SH/LDBAR CLK_INH CLK SER A B C D E F G H QH QHBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC165 LOGICEXP (11,17) DPWR DGND
+        SH/LDBAR CLK_INH CLK A B C D E F G H
+        r0 s0 r1 s1 r2 s2 r3 s3 r4 s4 r5 s5 r6 s6 r7 s7 clock
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clock = { (CLK_INH | CLK) }
+      shbar/ld = { (~(SH/LDBAR)) }
+      s0 = { (~(shbar/ld & A)) }
+      r0 = { (~(s0 & shbar/ld)) }
+      s1 = { (~(shbar/ld & B)) }
+      r1 = { (~(s1 & shbar/ld)) }
+      s2 = { (~(shbar/ld & C)) }
+      r2 = { (~(s2 & shbar/ld)) }
+      s3 = { (~(shbar/ld & D)) }
+      r3 = { (~(s3 & shbar/ld)) }
+      s4 = { (~(shbar/ld & E)) }
+      r4 = { (~(s4 & shbar/ld)) }
+      s5 = { (~(shbar/ld & F)) }
+      r5 = { (~(s5 & shbar/ld)) }
+      s6 = { (~(shbar/ld & G)) }
+      r6 = { (~(s6 & shbar/ld)) }
+      s7 = { (~(shbar/ld & H)) }
+      r7 = { (~(s7 & shbar/ld)) }     

uf0  Dff(1)  DPWR DGND
+    s0 r0  clock
+    SER  QA qabar 
+    D0_EFF IO_HC

uf1  Dff(1)  DPWR DGND
+    s1 r1 clock
+    QA QB qbbar 
+    D0_EFF IO_HC

uf2  Dff(1)  DPWR DGND
+    s2 r2  clock
+    QB QC qcbar 
+    D0_EFF IO_HC

uf3  Dff(1)  DPWR DGND
+    s3 r3  clock
+    QC QD qdbar 
+    D0_EFF IO_HC

uf4  Dff(1)  DPWR DGND
+    s4 r4  clock
+    QD QE qebar 
+    D0_EFF IO_HC

uf5  Dff(1)  DPWR DGND
+    s5 r5  clock
+    QE QF qfbar 
+    D0_EFF IO_HC

uf6  Dff(1)  DPWR DGND
+    s6 r6  clock
+    QF QG qgbar 
+    D0_EFF IO_HC

uf7  Dff(1)  DPWR DGND
+    s7 r7  clock
+    QG QH_O QHBAR_O 
+    D0_EFF IO_HC

Udly PINDLY (2,0,5) DPWR DGND
+    QH_O QHBAR_O
+    CLK SH/LDBAR H SER CLK_INH
+    QH QHBAR
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { CHANGED(H,0) }
+       CLKS= { (CHANGED(CLK,0) | CHANGED(CLK_INH,0)) }
+       SERIAL= { CHANGED(SER,0) }
+       LOAD= { CHANGED(SH/LDBAR,0) }
+
+    PINDLY:
+       QH  QHBAR = {
+                   CASE(
+                       LOAD, DELAY(-1,20ns,30ns),
+                       CLKS, DELAY(-1,15ns,30ns),
+                       DATA, DELAY(-1,15ns,30ns),
+                       DELAY(-1,21ns,31ns)
+                       )
+                     }

Ucnstr CONSTRAINT(12) DPWR DGND
+          CLK SH/LDBAR SER CLK_INH A B C D E F G H
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+      WIDTH:
+         NODE = SH/LDBAR
+         MIN_LO = 16ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLK_INH
+        SETUPTIME = 8ns
+      SETUP_HOLD:
+        CLOCK HL = SH/LDBAR
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 20ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 8ns
+        HOLDTIME = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SH/LDBAR
+        SETUPTIME_HI = 16ns

.ENDS 74HC165
*
*
* ----------------------------------------------------------- 74HCT165 ------
*  Parallel-Load 8-Bit Shift Register
*
*  High Speed CMOS Logic Family, 1994, Philips pages 357-362
*  jds    4/15/94
*
.SUBCKT 74HCT165 PLBAR CEBAR CP DS D0 D1 D2 D3 D4 D5 D6 D7 Q7 Q7BAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC165 LOGICEXP (11,17) DPWR DGND
+        PLBAR CEBAR CP D0 D1 D2 D3 D4 D5 D6 D7
+        r0 s0 r1 s1 r2 s2 r3 s3 r4 s4 r5 s5 r6 s6 r7 s7 clock
+        D0_GATE IO_HCT IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clock = { (CEBAR | CP) }
+      shbar/ld = { (~(PLBAR)) }
+      s0 = { (~(shbar/ld & D0)) }
+      r0 = { (~(s0 & shbar/ld)) }
+      s1 = { (~(shbar/ld & D1)) }
+      r1 = { (~(s1 & shbar/ld)) }
+      s2 = { (~(shbar/ld & D2)) }
+      r2 = { (~(s2 & shbar/ld)) }
+      s3 = { (~(shbar/ld & D3)) }
+      r3 = { (~(s3 & shbar/ld)) }
+      s4 = { (~(shbar/ld & D4)) }
+      r4 = { (~(s4 & shbar/ld)) }
+      s5 = { (~(shbar/ld & D5)) }
+      r5 = { (~(s5 & shbar/ld)) }
+      s6 = { (~(shbar/ld & D6)) }
+      r6 = { (~(s6 & shbar/ld)) }
+      s7 = { (~(shbar/ld & D7)) }
+      r7 = { (~(s7 & shbar/ld)) }     

uf0  Dff(1)  DPWR DGND
+    s0 r0  clock
+    DS  Q0 q0bar 
+    D0_EFF IO_HCT

uf1  Dff(1)  DPWR DGND
+    s1 r1 clock
+    Q0 Q1 q1bar 
+    D0_EFF IO_HCT

uf2  Dff(1)  DPWR DGND
+    s2 r2  clock
+    Q1 Q2 q2bar 
+    D0_EFF IO_HCT

uf3  Dff(1)  DPWR DGND
+    s3 r3  clock
+    Q2 Q3 q3bar 
+    D0_EFF IO_HCT

uf4  Dff(1)  DPWR DGND
+    s4 r4  clock
+    Q3 Q4 q4bar 
+    D0_EFF IO_HCT

uf5  Dff(1)  DPWR DGND
+    s5 r5  clock
+    Q4 Q5 q5bar 
+    D0_EFF IO_HCT

uf6  Dff(1)  DPWR DGND
+    s6 r6  clock
+    Q5 Q6 q6bar 
+    D0_EFF IO_HCT

uf7  Dff(1)  DPWR DGND
+    s7 r7  clock
+    Q6 Q7_O Q7BAR_O 
+    D0_EFF IO_HCT

Udly PINDLY (2,0,5) DPWR DGND
+    Q7_O Q7BAR_O
+    CP PLBAR D7 DS CEBAR
+    Q7 Q7BAR
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { CHANGED(D7,0) }
+       CLKS= { (CHANGED(CP,0) | CHANGED(CEBAR,0)) }
+       SERIAL= { CHANGED(DS,0) }
+       LOAD= { CHANGED(PLBAR,0) }
+
+    PINDLY:
+       Q7  Q7BAR = {
+                   CASE(
+                       LOAD, DELAY(-1,18ns,33ns),
+                       CLKS, DELAY(-1,19ns,33ns),
+                       DATA, DELAY(-1,13ns,24ns),
+                       DELAY(-1,20ns,34ns)
+                       )
+                     }

Ucnstr CONSTRAINT(12) DPWR DGND
+          CP PLBAR DS CEBAR D0 D1 D2 D3 D4 D5 D6 D7
+          IO_HCT
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 51MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 6ns
+      WIDTH:
+         NODE = PLBAR
+         MIN_LO = 5ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = CEBAR
+        SETUPTIME = 8ns
+        HOLDTIME = 6ns
+      SETUP_HOLD:
+        CLOCK HL = PLBAR
+        DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+        SETUPTIME = 8ns
+        HOLDTIME = 2ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = DS
+        SETUPTIME = 4ns
+        HOLDTIME = 2ns

.ENDS 74HCT165

*-------------------------------------------------------------74LS165----

* 8-Bit Parallel-In/Serial-Out Shift Registers
* National LS/S/TTL Logic Data Handbook, 1989, pages 2-191 to 2-194
* jat 8/7/96

.SUBCKT 74LS165 SER A B C D E F G H CLKINH CLK QH QHBAR SH/LDBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(12,18) DPWR DGND
+ CLK CLKINH SH/LDBAR SER A B C D E F G H
+ CLKBAR KA SETA SETB SETC SETD SETE SETF SETG SETH CLRA CLRB CLRC CLRD
+ CLRE CLRF CLRG CLRH
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKBAR = {~CLK | CLKINH}
+   KA = {~SER}
+   SETA = {~(~SH/LDBAR & A)}
+   SETB = {~(~SH/LDBAR & B)}
+   SETC = {~(~SH/LDBAR & C)}
+   SETD = {~(~SH/LDBAR & D)}
+   SETE = {~(~SH/LDBAR & E)}
+   SETF = {~(~SH/LDBAR & F)}
+   SETG = {~(~SH/LDBAR & G)}
+   SETH = {~(~SH/LDBAR & H)}
+   CLRA = {~(~SH/LDBAR & SETA)}
+   CLRB = {~(~SH/LDBAR & SETB)}
+   CLRC = {~(~SH/LDBAR & SETC)}
+   CLRD = {~(~SH/LDBAR & SETD)}
+   CLRE = {~(~SH/LDBAR & SETE)}
+   CLRF = {~(~SH/LDBAR & SETF)}
+   CLRG = {~(~SH/LDBAR & SETG)}
+   CLRH = {~(~SH/LDBAR & SETH)}

U2 JKFF(1) DPWR DGND
+ SETA CLRA CLKBAR
+ SER KA QA QABAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 JKFF(1) DPWR DGND
+ SETB CLRB CLKBAR
+ QA QABAR QB QBBAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U4 JKFF(1) DPWR DGND
+ SETC CLRC CLKBAR
+ QB QBBAR QC QCBAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U5 JKFF(1) DPWR DGND
+ SETD CLRD CLKBAR
+ QC QCBAR QD QDBAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U6 JKFF(1) DPWR DGND
+ SETE CLRE CLKBAR
+ QD QDBAR QE QEBAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U7 JKFF(1) DPWR DGND
+ SETF CLRF CLKBAR
+ QE QEBAR QF QFBAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U8 JKFF(1) DPWR DGND
+ SETG CLRG CLKBAR
+ QF QFBAR QG QGBAR
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U9 JKFF(1) DPWR DGND
+ SETH CLRH CLKBAR
+ QG QGBAR QHO QHBARO
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U10 PINDLY(2,0,3) DPWR DGND
+ QHO QHBARO
+ CLK SH/LDBAR H
+ QH QHBAR
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   EDGE = {CHANGED_LH(CLK,0)}
+   LOAD = {CHANGED(SH/LDBAR,0)}
+   HH = {CHANGED(H,0)}
+ PINDLY:
+   QH = {
+     CASE(
+   LOAD & TRN_LH, DELAY(-1,-1,37NS),
+   LOAD & TRN_HL, DELAY(-1,-1,42NS),
+   EDGE & TRN_LH, DELAY(-1,-1,42NS),
+   EDGE & TRN_HL, DELAY(-1,-1,47NS),
+   HH & TRN_LH, DELAY(-1,-1,27NS),
+   HH & TRN_HL, DELAY(-1,-1,37NS),
+   DELAY(-1,-1,48NS))}
+   QHBAR = {
+     CASE(
+   LOAD & TRN_LH, DELAY(-1,-1,37NS),
+   LOAD & TRN_HL, DELAY(-1,-1,42NS),
+   EDGE & TRN_LH, DELAY(-1,-1,42NS),
+   EDGE & TRN_HL, DELAY(-1,-1,47NS),
+   HH & TRN_LH, DELAY(-1,-1,32NS),
+   HH & TRN_HL, DELAY(-1,-1,32NS),
+   DELAY(-1,-1,48NS))}

U11 CONSTRAINT(12) DPWR DGND
+ CLK CLKINH SER SH/LDBAR A B C D E F G H
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 25NS
+   MIN_LO = 25NS
+ WIDTH:
+   NODE = SH/LDBAR
+   MIN_HI = 15NS
+   MIN_LO = 15NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = SH/LDBAR
+   SETUPTIME = 30NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(8) = A B C D E F G H
+   SETUPTIME = 10NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = SER
+   SETUPTIME = 20NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = CLKINH
+   SETUPTIME_LO = 30NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = SH/LDBAR
+   SETUPTIME_HI = 45NS

.ENDS 74LS165

* ----------------------------------------------------------- 74LS165A ------
*  Parallel-Load 8-Bit Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-521 to 2-528
*  jds    4/14/94
*
.SUBCKT 74LS165A SH/LDBAR CLK_INH CLK SER A B C D E F G H QH QHBAR
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS165A LOGICEXP (11,17) DPWR DGND
+        SH/LDBAR CLK_INH CLK A B C D E F G H
+        r0 s0 r1 s1 r2 s2 r3 s3 r4 s4 r5 s5 r6 s6 r7 s7 clock
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      clock = { (CLK_INH | CLK) }
+      shbar/ld = { (~(SH/LDBAR)) }
+      s0 = { (~(shbar/ld & A)) }
+      r0 = { (~(s0 & shbar/ld)) }
+      s1 = { (~(shbar/ld & B)) }
+      r1 = { (~(s1 & shbar/ld)) }
+      s2 = { (~(shbar/ld & C)) }
+      r2 = { (~(s2 & shbar/ld)) }
+      s3 = { (~(shbar/ld & D)) }
+      r3 = { (~(s3 & shbar/ld)) }
+      s4 = { (~(shbar/ld & E)) }
+      r4 = { (~(s4 & shbar/ld)) }
+      s5 = { (~(shbar/ld & F)) }
+      r5 = { (~(s5 & shbar/ld)) }
+      s6 = { (~(shbar/ld & G)) }
+      r6 = { (~(s6 & shbar/ld)) }
+      s7 = { (~(shbar/ld & H)) }
+      r7 = { (~(s7 & shbar/ld)) }     

uf0  Dff(1)  DPWR DGND
+    s0 r0  clock
+    SER  QA qabar 
+    D0_EFF IO_LS

uf1  Dff(1)  DPWR DGND
+    s1 r1 clock
+    QA QB qbbar 
+    D0_EFF IO_LS

uf2  Dff(1)  DPWR DGND
+    s2 r2  clock
+    QB QC qcbar 
+    D0_EFF IO_LS

uf3  Dff(1)  DPWR DGND
+    s3 r3  clock
+    QC QD qdbar 
+    D0_EFF IO_LS

uf4  Dff(1)  DPWR DGND
+    s4 r4  clock
+    QD QE qebar 
+    D0_EFF IO_LS

uf5  Dff(1)  DPWR DGND
+    s5 r5  clock
+    QE QF qfbar 
+    D0_EFF IO_LS

uf6  Dff(1)  DPWR DGND
+    s6 r6  clock
+    QF QG qgbar 
+    D0_EFF IO_LS

uf7  Dff(1)  DPWR DGND
+    s7 r7  clock
+    QG QH_O QHBAR_O 
+    D0_EFF IO_LS

Udly PINDLY (2,0,5) DPWR DGND
+    QH_O QHBAR_O
+    CLK SH/LDBAR H SER CLK_INH
+    QH QHBAR
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { CHANGED(H,0) }
+       CLKS= { (CHANGED(CLK,0) | CHANGED(CLK_INH,0)) }
+       SERIAL= { CHANGED(SER,0) }
+       LOAD= { CHANGED(SH/LDBAR,0) }
+
+    PINDLY:
+       QH  = {
+                   CASE(
+                       LOAD & TRN_LH, DELAY(-1,21ns,35ns),
+                       LOAD & TRN_HL, DELAY(-1,26ns,35ns),
+                       CLKS & TRN_LH, DELAY(-1,14ns,25ns),
+                       CLKS & TRN_HL, DELAY(-1,16ns,25ns),
+                       DATA & TRN_LH, DELAY(-1,13ns,25ns),
+                       DATA & TRN_HL, DELAY(-1,24ns,30ns),
+                       DELAY(-1,27ns,36ns)
+                       )
+                     }
+       QHBAR  = {
+                   CASE(
+                       LOAD & TRN_LH, DELAY(-1,21ns,35ns),
+                       LOAD & TRN_HL, DELAY(-1,26ns,35ns),
+                       CLKS & TRN_LH, DELAY(-1,14ns,25ns),
+                       CLKS & TRN_HL, DELAY(-1,16ns,25ns),
+                       DATA & TRN_LH, DELAY(-1,19ns,30ns),
+                       DATA & TRN_HL, DELAY(-1,17ns,25ns),
+                       DELAY(-1,27ns,36ns)
+                       )
+                     }


Ucnstr CONSTRAINT(12) DPWR DGND
+          CLK SH/LDBAR SER CLK_INH A B C D E F G H
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 15ns
+         MIN_LO =25ns
+      WIDTH:
+         NODE = SH/LDBAR
+         MIN_HI = 25ns
+         MIN_LO = 17ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = CLK_INH
+        SETUPTIME = 30ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 10ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SH/LDBAR
+        SETUPTIME_HI = 45ns

.ENDS 74LS165A
*
*
* ----------------------------------------------------------- 74166 ------
*  Parallel Load 8-Bit Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-529 to 2-536
*  jds    4/15/94
*
.SUBCKT 74166 CLK CLK_INH SH/LDBAR SER CLRBAR A B C D E F G H QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74166 LOGICEXP (20,17) DPWR DGND
+        CLK  CLK_INH A B C D E F G H CLRBAR SER SH/LDBAR qa qb qc qd qe qf qg
+        j0 k0 j1 k1 j2 k2 j3 k3 j4 k4 j5 k5 j6 k6 j7 k7 clkbar
+        D0_GATE IO_STD IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      u0 = { (SER & SH/LDBAR) }
+      v0 = {  (~SH/LDBAR & A) }
+      k0 = { ~(v0 | u0) }
+      j0 = {(~k0)}
+      u1 = { (qa & SH/LDBAR) }
+      v1 = {  (~SH/LDBAR & B) }
+      k1 = { ~(v1 | u1) }
+      j1 = {(~k1)}
+      u2 = { (qb & SH/LDBAR) }
+      v2 = {  (~SH/LDBAR & C) }
+      k2 = { ~(v2 | u2) }
+      j2 = {(~k2)}
+      u3 = { (qc & SH/LDBAR) }
+      v3 = {  (~SH/LDBAR & D) }
+      k3 = { ~(v3 | u3) }
+      j3 = {(~k3)}
+      u4 = { (qd & SH/LDBAR) }
+      v4 = {  (~SH/LDBAR & E) }
+      k4 = { ~(v4 | u4) }
+      j4 = {(~k4)}
+      u5 = { (qe & SH/LDBAR) }
+      v5 = {  (~SH/LDBAR & F) }
+      k5 = { ~(v5 | u5) }
+      j5 = {(~k5)}
+      u6 = { (qf & SH/LDBAR) }
+      v6 = {  (~SH/LDBAR & G) }
+      k6 = { ~(v6 | u6) }
+      j6 = {(~k6)}
+      u7 = { (qg & SH/LDBAR) }
+      v7 = {  (~SH/LDBAR & H) }
+      k7 = { ~(v7 | u7) }
+      j7 = {(~k7)}
+      clkbar = { ~(CLK | CLK_INH) }


uf0  JKff(8)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    j0 j1 j2 j3 j4 j5 j6 j7  k0 k1 k2 k3 k4 k5 k6 k7
+    qa qb qc qd qe qf qg QH_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_STD

Udly PINDLY (1,0,13) DPWR DGND
+    QH_O
+    CLRBAR CLK A B C D E F G H CLK_INH SER SH/LDBAR
+    QH
+    IO_STD MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(A,0) | CHANGED(B,0) |  CHANGED(C,0) | CHANGED(D,0) | 
+                          CHANGED(E,0) | CHANGED(F,0) |  CHANGED(G,0) | CHANGED(H,0)  ) }
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QH  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,23ns,35ns),
+                       CLOCK & TRN_HL, DELAY(-1,20ns,30ns),
+                       CLOCK & TRN_LH, DELAY(-1,17ns,26ns),
+                       DELAY(-1,24ns,36ns)
+                       )
+                     }

Ucnstr CONSTRAINT(13) DPWR DGND
+          CLRBAR CLK  A B C D E F G H SER CLK_INH SH/LDBAR 
+          IO_STD
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 20ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = SH/LDBAR CLK_INH
+        SETUPTIME = 30ns
+        WHEN = { CLRBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 20ns
+        WHEN={SH/LDBAR!='1}
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 20ns

.ENDS 74166
*
*
*-------------------------------------------------------------74ALS166----

* Parallel-Load 8-Bit Shift Registers
* TI ALS/AS Logic Data Book, 1986, pages 2-167 to 2-170
* jat 12/29/95

.SUBCKT 74ALS166 SER A B C D E F G H CLKINH CLK CLRBAR QH SH/LDBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(19,17) DPWR DGND
+ CLK CLKINH SH/LDBAR SER A B C D E F G H QA QB QC QD QE QF QG
+ CLKBAR JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ D0_GATE IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKBAR = {~(CLK | CLKINH)}
+   JA = {(SH/LDBAR & SER) | ((~SH/LDBAR) & A)}
+   JB = {(SH/LDBAR & QA) | ((~SH/LDBAR) & B)}
+   JC = {(SH/LDBAR & QB) | ((~SH/LDBAR) & C)}
+   JD = {(SH/LDBAR & QC) | ((~SH/LDBAR) & D)}
+   JE = {(SH/LDBAR & QD) | ((~SH/LDBAR) & E)}
+   JF = {(SH/LDBAR & QE) | ((~SH/LDBAR) & F)}
+   JG = {(SH/LDBAR & QF) | ((~SH/LDBAR) & G)}
+   JH = {(SH/LDBAR & QG) | ((~SH/LDBAR) & H)}
+   KA = {~JA}
+   KB = {~JB}
+   KC = {~JC}
+   KD = {~JD}
+   KE = {~JE}
+   KF = {~JF}
+   KG = {~JG}
+   KH = {~JH}

U2 JKFF(8) DPWR DGND
+ $D_HI CLRBAR CLKBAR
+ JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ QA QB QC QD QE QF QG QHO $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(1,0,2) DPWR DGND
+ QHO
+ CLRBAR CLK
+ QH
+ IO_ALS00 MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+   QH = {
+     CASE(
+   CLEAR & TRN_HL, DELAY(-1,10NS,-1),
+   EDGE & TRN_LH, DELAY(-1,12NS,-1),
+   EDGE & TRN_HL, DELAY(-1,13NS,-1),
+   DELAY(-1,14NS,-1))}

U4 CONSTRAINT(1) DPWR DGND
+ CLK
+ IO_ALS00 IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 60MEG

.ENDS 74ALS166

* ----------------------------------------------------------- 74F166 ------
*  Parallel Load 8-Bit Shift Register
*
*  The  Fast TTL Logic Series, Philips Pages 215-220
*  jds    4/20/94
*
.SUBCKT 74F166 CP CEBAR PEBAR DS MRBAR D0 D1 D2 D3 D4 D5 D6 D7 Q7
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F166 LOGICEXP (20,17) DPWR DGND
+        CP CEBAR D0 D1 D2 D3 D4 D5 D6 D7 MRBAR DS PEBAR qa qb qc qd qe qf qg
+        j0 k0 j1 k1 j2 k2 j3 k3 j4 k4 j5 k5 j6 k6 j7 k7 clkbar
+        D0_GATE IO_F IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      u0 = { (DS & PEBAR) }
+      v0 = {  (~PEBAR & D0) }
+      k0 = { ~(v0 | u0) }
+      j0 = {(~k0)}
+      u1 = { (qa & PEBAR) }
+      v1 = {  (~PEBAR & D1) }
+      k1 = { ~(v1 | u1) }
+      j1 = {(~k1)}
+      u2 = { (qb & PEBAR) }
+      v2 = {  (~PEBAR & D2) }
+      k2 = { ~(v2 | u2) }
+      j2 = {(~k2)}
+      u3 = { (qc & PEBAR) }
+      v3 = {  (~PEBAR & D3) }
+      k3 = { ~(v3 | u3) }
+      j3 = {(~k3)}
+      u4 = { (qd & PEBAR) }
+      v4 = {  (~PEBAR & D4) }
+      k4 = { ~(v4 | u4) }
+      j4 = {(~k4)}
+      u5 = { (qe & PEBAR) }
+      v5 = {  (~PEBAR & D5) }
+      k5 = { ~(v5 | u5) }
+      j5 = {(~k5)}
+      u6 = { (qf & PEBAR) }
+      v6 = {  (~PEBAR & D6) }
+      k6 = { ~(v6 | u6) }
+      j6 = {(~k6)}
+      u7 = { (qg & PEBAR) }
+      v7 = {  (~PEBAR & D7) }
+      k7 = { ~(v7 | u7) }
+      j7 = {(~k7)}
+      clkbar = { ~(CP | CEBAR) }


uf0  JKff(8)  DPWR DGND
+    $D_HI MRBAR clkbar
+    j0 j1 j2 j3 j4 j5 j6 j7  k0 k1 k2 k3 k4 k5 k6 k7
+    qa qb qc qd qe qf qg Q7_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_F

Udly PINDLY (1,0,13) DPWR DGND
+    Q7_O
+    MRBAR CP D0 D1 D2 D3 D4 D5 D6 D7 CEBAR DS PEBAR
+    Q7
+    IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(D0,0) | CHANGED(D1,0) |  CHANGED(D2,0) | CHANGED(D3,0) |
+                          CHANGED(D4,0) | CHANGED(D5,0) |  CHANGED(D6,0) | CHANGED(D7,0)  ) }
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+
+    PINDLY:
+       Q7  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(4ns,6.5ns,8.5ns),
+                       CLOCK & TRN_HL, DELAY(4ns,6ns,8ns),
+                       CLOCK & TRN_LH, DELAY(5ns,7.5ns,10ns),
+                       DELAY(6ns,8.5ns,11ns)
+                       )
+                     }

Ucnstr CONSTRAINT(13) DPWR DGND
+          MRBAR CP D0 D1 D2 D3 D4 D5 D6 D7 DS CEBAR PEBAR 
+          IO_F
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 175MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 3ns
+         MIN_LO= 4.5ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 4ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = MRBAR
+        SETUPTIME_HI = 4ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = PEBAR
+        SETUPTIME = 3ns
+        WHEN = { MRBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = CEBAR
+        SETUPTIME_LO = 5ns
+        WHEN = { MRBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+        SETUPTIME_HI = 3ns
+        SETUPTIME_LO = 2.5ns
+        HOLDTIME_HI = 1.5ns
+        WHEN={PEBAR!='1}
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = DS
+        SETUPTIME_HI = 3ns
+        SETUPTIME_LO = 2.5ns
+        HOLDTIME_HI = 1.5ns

.ENDS 74F166
*
*
* ----------------------------------------------------------- 74F166A ------
*  Parallel Load 8-Bit Shift Register
*
*  The  F Logic Data Book, TI Pages 2-115 to 2-120
*  bss    12/11/95
*
.SUBCKT 74F166A CLK CLK_INH SH/LDBAR SER CLRBAR A B C D E F G H QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U166ALOG LOGICEXP(19,9) DPWR DGND
+  CLK CLK_INH SH/LDBAR SER A B C D E F G H qa qb qc qd qe qf qg
+  clkin da db dc dd de df dg dh
+  D0_GATE IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+  LOGIC:
+     shbarld = {~SH/LDBAR}
+     clkin = {CLK_INH | CLK}
+     da = {(SH/LDBAR & SER) | (shbarld & A)}
+     db = {(SH/LDBAR & qa) | (shbarld & B)}
+     dc = {(SH/LDBAR & qb) | (shbarld & C)}
+     dd = {(SH/LDBAR & qc) | (shbarld & D)}
+     de = {(SH/LDBAR & qd) | (shbarld & E)}
+     df = {(SH/LDBAR & qe) | (shbarld & F)}
+     dg = {(SH/LDBAR & qf) | (shbarld & G)}
+     dh = {(SH/LDBAR & qg) | (shbarld & H)}

U2 DFF(8) DPWR DGND
+  $D_HI CLRBAR clkin
+  da db dc dd de df dg dh
+  qa qb qc qd qe qf qg QH_O
+  $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+  D0_EFF IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U166ADLY PINDLY(1,0,2) DPWR DGND
+  QH_O
+  clkin CLRBAR
+  QH
+   IO_F MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(clkin,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QH  = {
+            CASE(
+                   CLEAR & TRN_HL, DELAY(4.8ns,6ns,7.1ns),
+                   CLOCK & TRN_LH, DELAY(4.6ns,5.9ns,7.1ns),
+                   CLOCK & TRN_HL, DELAY(4.6ns,5.8ns,6.9ns),
+                   DELAY(5.8ns,7ns,8.1ns))}

UCON CONSTRAINT(14) DPWR DGND
+ 	clkin CLRBAR CLK CLK_INH SH/LDBAR A B C D E F G H SER
+  IO_F IO_LEVEL={IO_LEVEL}
+    FREQ:
+       NODE=clkin
+       MAXFREQ=110Meg
+
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 4ns
+         MIN_LO = 4ns
+
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 4ns
+
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  CLK_INH
+        SETUPTIME_LO = 2.5ns
+        HOLDTIME_LO = 1.5ns
+
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  SH/LDBAR
+        SETUPTIME_HI = 2.5ns
+        HOLDTIME_HI = 1ns
+
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 4ns
+        HOLDTIME = 1ns
+        WHEN={SH/LDBAR != '1}
+
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 3.5ns
+        HOLDTIME = 1.5ns
+
+     SETUP_HOLD:
+        CLOCK LH=CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 2.5ns

.ENDS 74F166A
*
*
* ----------------------------------------------------------- 74HC166 ------
*  Parallel Load 8-Bit Shift Register
*
*  The High Speed CMOS Logic Data Book, 1989, TI Pages 2-241 to 2-246
*  jds    4/21/94
*
.SUBCKT 74HC166 CLK CLK_INH SH/LDBAR SER CLRBAR A B C D E F G H QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74HC166 LOGICEXP (20,17) DPWR DGND
+        CLK  CLK_INH A B C D E F G H CLRBAR SER SH/LDBAR qa qb qc qd qe qf qg
+        j0 k0 j1 k1 j2 k2 j3 k3 j4 k4 j5 k5 j6 k6 j7 k7 clkbar
+        D0_GATE IO_HC IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      u0 = { (SER & SH/LDBAR) }
+      v0 = {  (~SH/LDBAR & A) }
+      k0 = { ~(v0 | u0) }
+      j0 = {(~k0)}
+      u1 = { (qa & SH/LDBAR) }
+      v1 = {  (~SH/LDBAR & B) }
+      k1 = { ~(v1 | u1) }
+      j1 = {(~k1)}
+      u2 = { (qb & SH/LDBAR) }
+      v2 = {  (~SH/LDBAR & C) }
+      k2 = { ~(v2 | u2) }
+      j2 = {(~k2)}
+      u3 = { (qc & SH/LDBAR) }
+      v3 = {  (~SH/LDBAR & D) }
+      k3 = { ~(v3 | u3) }
+      j3 = {(~k3)}
+      u4 = { (qd & SH/LDBAR) }
+      v4 = {  (~SH/LDBAR & E) }
+      k4 = { ~(v4 | u4) }
+      j4 = {(~k4)}
+      u5 = { (qe & SH/LDBAR) }
+      v5 = {  (~SH/LDBAR & F) }
+      k5 = { ~(v5 | u5) }
+      j5 = {(~k5)}
+      u6 = { (qf & SH/LDBAR) }
+      v6 = {  (~SH/LDBAR & G) }
+      k6 = { ~(v6 | u6) }
+      j6 = {(~k6)}
+      u7 = { (qg & SH/LDBAR) }
+      v7 = {  (~SH/LDBAR & H) }
+      k7 = { ~(v7 | u7) }
+      j7 = {(~k7)}
+      clkbar = { ~(CLK | CLK_INH) }

uf0  JKff(8)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    j0 j1 j2 j3 j4 j5 j6 j7  k0 k1 k2 k3 k4 k5 k6 k7
+    qa qb qc qd qe qf qg QH_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_HC

Udly PINDLY (1,0,2) DPWR DGND
+    QH_O
+    CLRBAR CLK
+    QH
+    IO_HC MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QH  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,18ns,24ns),
+                       CLOCK, DELAY(-1,15ns,30ns),
+                       DELAY(-1,19ns,31ns)
+                       )
+                     }

Ucnstr CONSTRAINT(13) DPWR DGND
+          CLRBAR CLK  A B C D E F G H SER CLK_INH SH/LDBAR 
+          IO_HC
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 31MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 16ns
+         MIN_LO = 16ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  CLK_INH
+        SETUPTIME_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) =  SH/LDBAR
+        SETUPTIME = 29ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 16ns
+        HOLDTIME = 5ns
+        WHEN={SH/LDBAR!='1}
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 16ns
+        HOLDTIME = 5ns
+     SETUP_HOLD:
+        CLOCK LH=CLK
+        DATA(1) = CLRBAR
+        SETUPTIME_HI = 8ns

.ENDS 74HC166
*
*
* ----------------------------------------------------------- 74HCT166 ------
*  Parallel Load 8-Bit Shift Register
*
*  The  High Speed Logic Series, Philips Pages 363-368
*  jds    4/20/94
*
.SUBCKT 74HCT166 CP CEBAR PEBAR DS MRBAR D0 D1 D2 D3 D4 D5 D6 D7 Q7
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74F166 LOGICEXP (20,17) DPWR DGND
+        CP CEBAR D0 D1 D2 D3 D4 D5 D6 D7 MRBAR DS PEBAR qa qb qc qd qe qf qg
+        j0 k0 j1 k1 j2 k2 j3 k3 j4 k4 j5 k5 j6 k6 j7 k7 clkbar
+        D0_GATE IO_HCT IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      u0 = { (DS & PEBAR) }
+      v0 = {  (~PEBAR & D0) }
+      k0 = { ~(v0 | u0) }
+      j0 = {(~k0)}
+      u1 = { (qa & PEBAR) }
+      v1 = {  (~PEBAR & D1) }
+      k1 = { ~(v1 | u1) }
+      j1 = {(~k1)}
+      u2 = { (qb & PEBAR) }
+      v2 = {  (~PEBAR & D2) }
+      k2 = { ~(v2 | u2) }
+      j2 = {(~k2)}
+      u3 = { (qc & PEBAR) }
+      v3 = {  (~PEBAR & D3) }
+      k3 = { ~(v3 | u3) }
+      j3 = {(~k3)}
+      u4 = { (qd & PEBAR) }
+      v4 = {  (~PEBAR & D4) }
+      k4 = { ~(v4 | u4) }
+      j4 = {(~k4)}
+      u5 = { (qe & PEBAR) }
+      v5 = {  (~PEBAR & D5) }
+      k5 = { ~(v5 | u5) }
+      j5 = {(~k5)}
+      u6 = { (qf & PEBAR) }
+      v6 = {  (~PEBAR & D6) }
+      k6 = { ~(v6 | u6) }
+      j6 = {(~k6)}
+      u7 = { (qg & PEBAR) }
+      v7 = {  (~PEBAR & D7) }
+      k7 = { ~(v7 | u7) }
+      j7 = {(~k7)}
+      clkbar = { ~(CP | CEBAR) }


uf0  JKff(8)  DPWR DGND
+    $D_HI MRBAR clkbar
+    j0 j1 j2 j3 j4 j5 j6 j7  k0 k1 k2 k3 k4 k5 k6 k7
+    qa qb qc qd qe qf qg Q7_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_HCT

Udly PINDLY (1,0,13) DPWR DGND
+    Q7_O
+    MRBAR CP D0 D1 D2 D3 D4 D5 D6 D7 CEBAR DS PEBAR
+    Q7
+    IO_HCT MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(D0,0) | CHANGED(D1,0) |  CHANGED(D2,0) | CHANGED(D3,0) |
+                          CHANGED(D4,0) | CHANGED(D5,0) |  CHANGED(D6,0) | CHANGED(D7,0)  ) }
+       CLOCK= { CHANGED(CP,0) }
+       CLEAR= { CHANGED(MRBAR,0) }
+
+    PINDLY:
+       Q7  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,22ns,40ns),
+                       CLOCK, DELAY(-1,23ns,40ns),
+                       DELAY(-1,19ns,33ns)
+                       )
+                     }

Ucnstr CONSTRAINT(13) DPWR DGND
+          MRBAR CP D0 D1 D2 D3 D4 D5 D6 D7 DS CEBAR PEBAR 
+          IO_HCT
+
+      FREQ:
+         NODE = CP
+         MAXFREQ = 45MEG
+      WIDTH:
+         NODE = CP
+         MIN_HI = 9ns
+         MIN_LO= 9ns
+      WIDTH:
+         NODE = MRBAR
+         MIN_LO = 11ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = MRBAR
+        SETUPTIME_HI = 7ns
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(1) = PEBAR
+        SETUPTIME = 15ns
+        HOLDTIME = 13ns
+        WHEN = { MRBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(8) = D0 D1 D2 D3 D4 D5 D6 D7
+        SETUPTIME = 8ns
+        HOLDTIME = 3ns
+        WHEN={PEBAR!='1}
+      SETUP_HOLD:
+        CLOCK LH = CP
+        DATA(2) = DS CEBAR
+        SETUPTIME = 8ns
+        HOLDTIME = 3ns

.ENDS 74HCT166

*-------------------------------------------------------------74LS166----

* 8-Bit Parallel-In/Serial-Out Shift Registers
* National LS/S/TTL Logic Data Handbook, 1989, pages 2-195 to 2-198
* jat 8/7/96

.SUBCKT 74LS166 SER A B C D E F G H CLKINH CLK CLRBAR QH SH/LDBAR
+ OPTIONAL: DPWR=$G_DPWR DGND=$G_DGND
+ PARAMS: MNTYMXDLY=0 IO_LEVEL=0

U1 LOGICEXP(19,17) DPWR DGND
+ CLK CLKINH SH/LDBAR SER A B C D E F G H QA QB QC QD QE QF QG
+ CLKBAR JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ D0_GATE IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ LOGIC:
+   CLKBAR = {~CLK | CLKINH}
+   JA = {(SH/LDBAR & SER) | ((~SH/LDBAR) & A)}
+   JB = {(SH/LDBAR & QA) | ((~SH/LDBAR) & B)}
+   JC = {(SH/LDBAR & QB) | ((~SH/LDBAR) & C)}
+   JD = {(SH/LDBAR & QC) | ((~SH/LDBAR) & D)}
+   JE = {(SH/LDBAR & QD) | ((~SH/LDBAR) & E)}
+   JF = {(SH/LDBAR & QE) | ((~SH/LDBAR) & F)}
+   JG = {(SH/LDBAR & QF) | ((~SH/LDBAR) & G)}
+   JH = {(SH/LDBAR & QG) | ((~SH/LDBAR) & H)}
+   KA = {~JA}
+   KB = {~JB}
+   KC = {~JC}
+   KD = {~JD}
+   KE = {~JE}
+   KF = {~JF}
+   KG = {~JG}
+   KH = {~JH}

U2 JKFF(8) DPWR DGND
+ $D_HI CLRBAR CLKBAR
+ JA JB JC JD JE JF JG JH KA KB KC KD KE KF KG KH
+ QA QB QC QD QE QF QG QHO $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC $D_NC
+ D0_EFF IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}

U3 PINDLY(1,0,2) DPWR DGND
+ QHO
+ CLRBAR CLK
+ QH
+ IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+ BOOLEAN:
+   CLEAR = {CHANGED_HL(CLRBAR,0)}
+   EDGE = {CHANGED_LH(CLK,0)}
+ PINDLY:
+   QH = {
+     CASE(
+   CLEAR & TRN_HL, DELAY(6NS,-1,30NS),
+   EDGE & (TRN_LH | TRN_HL), DELAY(8NS,-1,35NS),
+   DELAY(9NS,-1,36NS))}

U4 CONSTRAINT(11) DPWR DGND
+ CLK CLRBAR SH/LDBAR A B C D E F G H
+ IO_LS IO_LEVEL={IO_LEVEL}
+ FREQ:
+   NODE = CLK
+   MAXFREQ = 25MEG
+ WIDTH:
+   NODE = CLK
+   MIN_HI = 20NS
+   MIN_LO = 20NS
+ WIDTH:
+   NODE = CLRBAR
+   MIN_LO = 20NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(1) = SH/LDBAR
+   SETUPTIME = 30NS
+ SETUP_HOLD:
+   CLOCK LH = CLK
+   DATA(8) = A B C D E F G H
+   SETUPTIME = 20NS

.ENDS 74LS166

* ----------------------------------------------------------- 74LS166A ------
*  Parallel Load 8-Bit Shift Register
*
*  The TTL Logic Data Book, 1988, TI Pages 2-529 to 2-536
*  jds    4/21/94
*
.SUBCKT 74LS166A CLK CLK_INH SH/LDBAR SER CLRBAR A B C D E F G H QH
+  optional: DPWR=$G_DPWR DGND=$G_DGND
+  params: MNTYMXDLY=0 IO_LEVEL=0

U74LS166A LOGICEXP (20,17) DPWR DGND
+        CLK  CLK_INH A B C D E F G H CLRBAR SER SH/LDBAR qa qb qc qd qe qf qg
+        j0 k0 j1 k1 j2 k2 j3 k3 j4 k4 j5 k5 j6 k6 j7 k7 clkbar
+        D0_GATE IO_LS IO_LEVEL={IO_LEVEL}
+
+    LOGIC:
+      u0 = { (SER & SH/LDBAR) }
+      v0 = {  (~SH/LDBAR & A) }
+      k0 = { ~(v0 | u0) }
+      j0 = {(~k0)}
+      u1 = { (qa & SH/LDBAR) }
+      v1 = {  (~SH/LDBAR & B) }
+      k1 = { ~(v1 | u1) }
+      j1 = {(~k1)}
+      u2 = { (qb & SH/LDBAR) }
+      v2 = {  (~SH/LDBAR & C) }
+      k2 = { ~(v2 | u2) }
+      j2 = {(~k2)}
+      u3 = { (qc & SH/LDBAR) }
+      v3 = {  (~SH/LDBAR & D) }
+      k3 = { ~(v3 | u3) }
+      j3 = {(~k3)}
+      u4 = { (qd & SH/LDBAR) }
+      v4 = {  (~SH/LDBAR & E) }
+      k4 = { ~(v4 | u4) }
+      j4 = {(~k4)}
+      u5 = { (qe & SH/LDBAR) }
+      v5 = {  (~SH/LDBAR & F) }
+      k5 = { ~(v5 | u5) }
+      j5 = {(~k5)}
+      u6 = { (qf & SH/LDBAR) }
+      v6 = {  (~SH/LDBAR & G) }
+      k6 = { ~(v6 | u6) }
+      j6 = {(~k6)}
+      u7 = { (qg & SH/LDBAR) }
+      v7 = {  (~SH/LDBAR & H) }
+      k7 = { ~(v7 | u7) }
+      j7 = {(~k7)}
+      clkbar = { ~(CLK | CLK_INH) }


uf0  JKff(8)  DPWR DGND
+    $D_HI CLRBAR clkbar
+    j0 j1 j2 j3 j4 j5 j6 j7  k0 k1 k2 k3 k4 k5 k6 k7
+    qa qb qc qd qe qf qg QH_O
+    qabar qbbar qcbar qdbar qebar qfbar qgbar qhbar
+    D0_EFF IO_LS

Udly PINDLY (1,0,13) DPWR DGND
+    QH_O
+    CLRBAR CLK A B C D E F G H CLK_INH SER SH/LDBAR
+    QH
+    IO_LS MNTYMXDLY={MNTYMXDLY} IO_LEVEL={IO_LEVEL}
+
+    BOOLEAN:
+       DATA=  { ( CHANGED(A,0) | CHANGED(B,0) |  CHANGED(C,0) | CHANGED(D,0) | 
+                          CHANGED(E,0) | CHANGED(F,0) |  CHANGED(G,0) | CHANGED(H,0)  ) }
+       CLOCK= { CHANGED(CLK,0) }
+       CLEAR= { CHANGED(CLRBAR,0) }
+
+    PINDLY:
+       QH  = {
+                   CASE(
+                       CLEAR & TRN_HL, DELAY(-1,19ns,30ns),
+                       CLOCK & TRN_HL, DELAY(7ns,14ns,25ns),
+                       CLOCK & TRN_LH, DELAY(5ns,11ns,20ns),
+                       DELAY(8ns,20ns,31ns)
+                       )
+                     }

Ucnstr CONSTRAINT(13) DPWR DGND
+          CLRBAR CLK  A B C D E F G H SER CLK_INH SH/LDBAR 
+          IO_LS
+
+      FREQ:
+         NODE = CLK
+         MAXFREQ = 25MEG
+      WIDTH:
+         NODE = CLK
+         MIN_HI = 25ns
+      WIDTH:
+         NODE = CLRBAR
+         MIN_LO = 20ns
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(2) = SH/LDBAR CLK_INH
+        SETUPTIME = 30ns
+        WHEN = { CLRBAR != '0 }
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(8) = A B C D E F G H
+        SETUPTIME = 20ns
+        WHEN={SH/LDBAR!='1}
+      SETUP_HOLD:
+        CLOCK LH = CLK
+        DATA(1) = SER
+        SETUPTIME = 20ns

.ENDS 74LS166A

